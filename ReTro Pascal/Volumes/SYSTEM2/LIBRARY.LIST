     2   1    1:D     1 {.fs} {$L LIBRARIAN.LIST[*]} { LIST file helps debugging (has all proc nos etc.) }     3   1    1:D     1      4   1    1:D     1         (*******************************************************************)     5   1    1:D     1         (*                                                                 *)     6   1    1:D     1         (*  Copyright (c) 1979 Regents of the University of California.    *)     7   1    1:D     1         (*  Permission to copy or distribute this software or documen-     *)     8   1    1:D     1         (*  tation in hard or soft copy granted only by written license    *)     9   1    1:D     1         (*  obtained form the Institute for Information Systems.           *)    10   1    1:D     1         (*                                                                 *)    11   1    1:D     1         (*******************************************************************)    12   1    1:D     1     13   1    1:D     1 {*************************************}    14   1    1:D     1 {*                                   *}    15   1    1:D     1 {*      Pascal System Librarian      *}    16   1    1:D     1 {*          (Version II.0)           *}    17   1    1:D     1 {*                                   *}    18   1    1:D     1 {*      I.5 release version          *}    19   1    1:D     1 {*        written Summer '78         *}    20   1    1:D     1 {*        by Roger Sumner            *}    21   1    1:D     1 {*                                   *}    22   1    1:D     1 {*      Modified March 1979          *}    23   1    1:D     1 {*        by Gary Dismukes           *}    24   1    1:D     1 {*      to handle byte-flipped       *}    25   1    1:D     1 {*      files;                       *}    26   1    1:D     1 {*      also Procedure Copyinterface *}    27   1    1:D     1 {*      rewritten.                   *}    28   1    1:D     1 {*                                   *}    29   1    1:D     1 {*************************************}    30   1    1:D     1 {.fs# (*$S+,U-,F+*)}    { FLIP?? $U- only used to get ERASEEOL char }    31   1    1:D     1 {.fs} (*$G+*)           { allow GOTO }    32   1    1:D     1     33   1    1:D     1 {.fs} PROGRAM SYSTEMLIBRARIAN;    34   1    1:D     3     35   1    1:D     3 CONST    36   1    1:D     3      MAXSEG = 15;	(*MAX CODE SEGMENT NUMBER*)    37   1    1:D     3     38   1    1:D     3 TYPE    39   1    1:D     3 					(*CODE SEGMENT LAYOUTS*)    40   1    1:D     3     41   1    1:D     3      SEGRANGE = 0..MAXSEG;    42   1    1:D     3      SEGDESC = RECORD    43   1    1:D     3 		 DISKADDR: INTEGER;	(*REL BLK IN CODE...ABS IN SYSCOM^*)    44   1    1:D     3 		 CODELENG: INTEGER	(*# BYTES TO READ IN*)    45   1    1:D     3 	       END (*SEGDESC*) ;    46   1    1:D     3 					(*SYSTEM COMMUNICATION AREA*)    47   1    1:D     3 					(*SEE INTERPRETERS...NOTE  *)    48   1    1:D     3 					(*THAT WE ASSUME BACKWARD  *)    49   1    1:D     3 					(*FIELD ALLOCATION IS DONE *)    50   1    1:D     3     51   1    1:D     3 {.fs#  --- no need to pull in SYSCOMREC at all ---    52   1    1:D     3      SYSCOMREC = RECORD    53   1    1:D     3 		   IORSLT: INTEGER ;	(*RESULT OF LAST IO CALL*)    54   1    1:D     3 		   XEQERR: INTEGER;	(*REASON FOR EXECERROR CALL*)    55   1    1:D     3 		   SYSUNIT: INTEGER;	(*PHYSICAL UNIT OF BOOTLOAD*)    56   1    1:D     3 		   BUGSTATE: INTEGER;	(*DEBUGGER INFO*)    57   1    1:D     3 		   GDIRP: INTEGER;	    58   1    1:D     3 		   LASTMP,STKBASE,BOMBP: INTEGER;    59   1    1:D     3 		   MEMTOP,SEG,JTAB: INTEGER;    60   1    1:D     3 		   BOMBIPC: INTEGER;	(*WHERE XEQERR BLOWUP WAS*)    61   1    1:D     3 		   HLTLINE: INTEGER;	(*MORE DEBUGGER STUFF*)    62   1    1:D     3 		   BRKPTS: ARRAY [0..3] OF INTEGER;    63   1    1:D     3 		   RETRIES: INTEGER;	(*DRIVERS PUT RETRY COUNTS*)    64   1    1:D     3 		   EXPANSION: ARRAY [0..8] OF INTEGER;    65   1    1:D     3 		   HIGHTIME,LOWTIME: INTEGER;    66   1    1:D     3 		   MISCINFO: PACKED RECORD    67   1    1:D     3 			       NOBREAK,STUPID,SLOWTERM,    68   1    1:D     3 			       HASXYCRT,HASLCCRT,HAS8510A,HASCLOCK: BOOLEAN    69   1    1:D     3 			     END;    70   1    1:D     3 		   CRTTYPE: INTEGER;    71   1    1:D     3 		   CRTCTRL: PACKED RECORD    72   1    1:D     3 			      RLF,NDFS,ERASEEOL,ERASEEOS,HOME,ESCAPE: CHAR;    73   1    1:D     3 			      BACKSPACE: CHAR;    74   1    1:D     3 			      FILLCOUNT: 0..255;    75   1    1:D     3 			      EXPANSION: PACKED ARRAY [0..3] OF CHAR    76   1    1:D     3 			    END;    77   1    1:D     3 		   CRTINFO: PACKED RECORD    78   1    1:D     3 			      WIDTH,HEIGHT: INTEGER;    79   1    1:D     3 			      RIGHT,LEFT,DOWN,UP: CHAR;    80   1    1:D     3 			      BADCH,CHARDEL,STOP,BREAK,FLUSH,EOF: CHAR;    81   1    1:D     3 			      ALTMODE,LINEDEL: CHAR;    82   1    1:D     3 			      EXPANSION: PACKED ARRAY [0..5] OF CHAR    83   1    1:D     3 			    END;    84   1    1:D     3 		   SEGTABLE: ARRAY [SEGRANGE] OF    85   1    1:D     3 			       RECORD    86   1    1:D     3 				 CODEUNIT: INTEGER;    87   1    1:D     3 				 CODEDESC: SEGDESC    88   1    1:D     3 			       END    89   1    1:D     3 		 END (*SYSCOM*);    90   1    1:D     3     91   1    1:D     3 VAR    92   1    1:D     3     SYSCOM: ^SYSCOMREC;			(*MAGIC PARAM...SET UP IN BOOT*)    93   1    1:D     3 }    94   1    1:D     3     95   1    1:D     3 {.fs# SEGMENT PROCEDURE LIBRARIAN(III,JJJ: INTEGER); }  { no need for system mode }    96   1    1:D     3     97   1    2:D     1 PROCEDURE LIBRARIAN;    98   1    2:D     1     99   1    2:D     1 CONST   100   1    2:D     1   WINDOW = 2;   101   1    2:D     1   ERROR = 23;   102   1    2:D     1   MARKCODE = 15;   103   1    2:D     1   MARKIN = 5;   104   1    2:D     1    105   1    2:D     1    106   1    2:D     1 TYPE   107   1    2:D     1      BLOCK0P = ^BLOCK0;   108   1    2:D     1      BLOCK0 = RECORD   109   1    2:D     1 		SEGDSC: ARRAY [SEGRANGE] OF SEGDESC;   110   1    2:D     1 		SEGNAME: ARRAY [SEGRANGE] OF   111   1    2:D     1 			   PACKED ARRAY [0..7] OF CHAR;   112   1    2:D     1 		SEGKIND: ARRAY [SEGRANGE] OF INTEGER;   113   1    2:D     1 		EXTRA: ARRAY [SEGRANGE] OF INTEGER;   114   1    2:D     1 		FILLER: ARRAY [1..88] OF INTEGER;   115   1    2:D     1 		NOTICE: STRING[79]   116   1    2:D     1 	      END;   117   1    2:D     1    118   1    2:D     1    119   1    2:D     1 VAR NBLOCKS,RSLT,OUTBLOCK: INTEGER;   120   1    2:D     4     BUF: BLOCK0P;   121   1    2:D     5     DSEG,SSEG: SEGRANGE;   122   1    2:D     7     PL,TITLE: STRING;   123   1    2:D    89     CODETBL: BLOCK0;   124   1    2:D   345     CODE,INFILE: FILE;   125   1    2:D   425     firstfile, flipped: Boolean;   126   1    2:D   427    127   1    2:D   427    128   1    3:D     1 procedure byteswap(var word: integer);   129   1    3:D     2   var  temp1,temp2: packed record   130   1    3:D     2 		      case boolean of   131   1    3:D     2 			TRUE:  (val: integer);   132   1    3:D     2 			FALSE: (lowbyte: 0..255;   133   1    3:D     2 				highbyte:0..255);   134   1    3:D     2 		    end;   135   1    3:0     0 begin   136   1    3:1     0   temp1.val:= word;   137   1    3:1     4   temp2.lowbyte:= temp1.highbyte;   138   1    3:1    19   temp2.highbyte:= temp1.lowbyte;   139   1    3:1    34   word:= temp2.val;   140   1    3:0    37 end;   141   1    3:0    50    142   1    4:D     3 Function Table_flipped( var Table: block0 ): Boolean;   143   1    4:D     4   label 1;   144   1    4:D     4   var s: segrange;   145   1    4:D     5       highbyte: 0..1;   146   1    4:D     6       int: record   147   1    4:D     6 	     case boolean of   148   1    4:D     6 	       TRUE: (val: integer);   149   1    4:D     6 	       FALSE:(byte: packed array [0..1] of 0..255)   150   1    4:D     6 	     end;   151   1    4:0     0 begin   152   1    4:1     0   Table_flipped := FALSE;   153   1    4:1     3   {First determine sex of this machine}   154   1    4:1     3   int.val := 1;   155   1    4:1     6   highbyte := ord(int.byte[0] = 1);   156   1    4:1    20    157   1    4:1    20   for s:= 0 to MAXSEG do   158   1    4:2    37     with Table.segdsc[s] do   159   1    4:3    46     begin   160   1    4:4    46       int.val:= diskaddr;   161   1    4:4    50       if int.byte[highbyte] <> 0 then   162   1    4:5    61       begin   163   1    4:6    61 	Table_flipped:= TRUE;   164   1    4:6    64 	goto 1;   165   1    4:5    66       end;   166   1    4:3    66     end;   167   1    4:1    73 1:end;   168   1    4:1    88    169   1    5:D     1 procedure fliptable(var table: block0);   170   1    5:D     2   var  s: segrange;   171   1    5:0     0 begin   172   1    5:1     0   for s := 0 to MAXSEG do   173   1    5:2    17     with table, segdsc[s] do   174   1    5:3    29     begin   175   1    5:4    29       byteswap(diskaddr);   176   1    5:4    32       byteswap(codeleng);   177   1    5:4    37       byteswap(segkind[s]);   178   1    5:4    48       byteswap(extra[s]);   179   1    5:3    59     end;   180   1    5:0    66 end;   181   1    5:0    80    182   1    6:D     1 PROCEDURE NEWLINKER;   183   1    6:D     1    184   1    6:D     1 VAR CCH: CHAR;   185   1    6:D     2     INTBL: BLOCK0P;   186   1    6:D     3     NTITLE: STRING;   187   1    6:D    44     CODETABLE: BLOCK0P;   188   1    6:D    45     PL: STRING;   189   1    6:D    86    190   1    7:D     1 PROCEDURE PROMPT(AT: INTEGER);   191   1    7:0     0 BEGIN   192   1    7:1     0   GOTOXY(0,AT);   193   1    7:1     5   IF AT = ERROR THEN WRITE(CHR(7));   194   1    7:1    20   WRITE(PL);   195   1    7:1    32 {.fs# WITH SYSCOM^.CRTCTRL DO WRITE(ESCAPE,ERASEEOL); } { avoid SYSCOM }   196   1    7:1    32   WRITE(CHR(29));   { ERASEEOL }   197   1    7:0    42 END;   198   1    7:0    54    199   1    8:D     3 FUNCTION CHECKIO:BOOLEAN;   200   1    8:D     3 VAR RSLT:INTEGER;   201   1    8:0     0 BEGIN   202   1    8:1     0   CHECKIO:=IORESULT=0;   203   1    8:1     6   IF IORESULT <> 0 THEN   204   1    8:2    12     BEGIN   205   1    8:3    12       RSLT:=IORESULT;   206   1    8:3    16       PL := 'I/O error # ';   207   1    8:3    36       PROMPT(ERROR);   208   1    8:3    39       WRITE(OUTPUT,RSLT);   209   1    8:2    49     END;   210   1    8:0    49 END; (* CHECKIO *)   211   1    8:0    62    212   1    9:D     1 PROCEDURE OPENFILE;   213   1    9:0     0 BEGIN   214   1    9:1     0   REPEAT   215   1    9:2     0     PL := 'Link Code File -> ';   216   1    9:2    26     PROMPT(4);   217   1    9:2    29     READLN(INPUT,NTITLE);   218   1    9:2    49     if ntitle = '*' then   219   1    9:3    57       ntitle:= '*SYSTEM.LIBRARY';   220   1    9:2    80     IF LENGTH(NTITLE) > 0 THEN   221   1    9:3    89       BEGIN   222   1    9:4    89 	TITLE := NTITLE;   223   1    9:4    97 	RESET(INFILE,NTITLE);   224   1    9:3   111       END;   225   1    9:1   111   UNTIL (CHECKIO) OR (LENGTH(NTITLE) = 0);   226   1    9:0   125 END (*OPENFILE*) ;   227   1    9:0   140    228   1   10:D     1 PROCEDURE DISPLAY(AT: INTEGER; WHAT: BLOCK0P);   229   1   10:D     3 VAR   230   1   10:D     3   T: INTEGER;   231   1   10:0     0 BEGIN   232   1   10:1     0   GOTOXY(0,AT);   233   1   10:1     5   WITH WHAT^ DO   234   1   10:2     8     FOR T := 0 TO 3 DO   235   1   10:3    19       BEGIN   236   1   10:4    19 	WRITE(T:3,'-',SEGNAME[T],SEGDSC[T].CODELENG:6);   237   1   10:4    75 	WRITE(T+4:5,'-',SEGNAME[T+4],SEGDSC[T+4].CODELENG:6);   238   1   10:4   137 	WRITE(T+8:5,'-',SEGNAME[T+8],SEGDSC[T+8].CODELENG:6);   239   1   10:4   199 	WRITELN(T+12:5,'-',SEGNAME[T+12],SEGDSC[T+12].CODELENG:6)   240   1   10:3   269       END;   241   1   10:1   276   PL := 'Code file length - ';   242   1   10:1   303   PROMPT(12);   243   1   10:1   306   WRITE(OUTPUT,OUTBLOCK);   244   1   10:0   318 END;   245   1   10:0   334    246   1   10:0   334    247   1   11:D     1 PROCEDURE LINKCODE;   248   1   11:D     1   VAR NBLOCKS: INTEGER;   249   1   11:D     2    250   1   12:D     1   PROCEDURE LINKIT;   251   1   12:D     1    252   1   13:D     1     PROCEDURE COPYLINKINFO(INFOBLK: INTEGER);   253   1   13:D     2       VAR N, NRECS: INTEGER;   254   1   13:D     4 	  DONE: BOOLEAN;   255   1   13:D     5 	  REC: ARRAY [0..7] OF INTEGER;   256   1   13:D    13 	  BUF: ARRAY [0..31, 0..7] OF INTEGER;   257   1   13:D   269    258   1   14:D     1 	PROCEDURE GETREC;   259   1   14:0     0 	BEGIN   260   1   14:1     0 	  IF NRECS = 0 THEN   261   1   14:2     7 	    IF BLOCKREAD(INFILE, BUF, 1, INFOBLK) <> 1 THEN   262   1   14:3    31 	      BEGIN   263   1   14:4    31 		PL := 'Link info read err';   264   1   14:4    57 		PROMPT(ERROR);   265   1   14:4    60 		DONE := TRUE   266   1   14:3    60 	      END   267   1   14:2    64 	    ELSE   268   1   14:3    66 	      IF BLOCKWRITE(CODE, BUF, 1, OUTBLOCK) <> 1 THEN   269   1   14:4    90 		BEGIN   270   1   14:5    90 		  PL := 'Code file overflow';   271   1   14:5   116 		  PROMPT(ERROR);   272   1   14:5   119 		  DONE := TRUE   273   1   14:4   119 		END   274   1   14:3   123 	      ELSE   275   1   14:4   125 		BEGIN   276   1   14:5   125 		  OUTBLOCK := OUTBLOCK+1;   277   1   14:5   133 		  INFOBLK := INFOBLK+1;   278   1   14:5   141 		  NRECS := 32   279   1   14:4   141 		END;   280   1   14:1   145 	  IF NOT DONE THEN   281   1   14:2   151 	    REC := BUF[32-NRECS];   282   1   14:1   169 	  NRECS := NRECS-1   283   1   14:0   172 	END { GETREC } ;   284   1   14:0   192    285   1   13:0     0     BEGIN { COPYLINKINFO }   286   1   13:1     0       NRECS := 0; DONE := FALSE;   287   1   13:1     6       REPEAT   288   1   13:2     6 	GETREC;   289   1   13:2     8 	if flipped then   290   1   13:3    14 	  byteswap(rec[4]);   291   1   13:2    24 	IF NOT (REC[4] IN [0..14]) THEN   292   1   13:3    41 	  BEGIN   293   1   13:4    41 	    PL := 'Bad link info';   294   1   13:4    62 	    PROMPT(ERROR);   295   1   13:4    65 	    REC[4] := 0   296   1   13:3    73 	  END;   297   1   13:2    75 	DONE := REC[4] = 0;   298   1   13:2    88 	IF NOT DONE THEN   299   1   13:3    92 	  IF REC[4] IN [1..5,13,14] THEN   300   1   13:4   108 	    BEGIN { COPY REF LIST }   301   1   13:5   108 	      if flipped then   302   1   13:6   114 		byteswap(rec[6]);   303   1   13:5   124 	      N := (REC[6]+7) DIV 8;   304   1   13:5   139 	      WHILE N > 0 DO   305   1   13:6   144 		BEGIN GETREC; N := N-1 END   306   1   13:4   151 	    END   307   1   13:1   153       UNTIL DONE   308   1   13:0   153     END { COPYLINKINFO } ;   309   1   13:0   172    310   1   15:D     1       Procedure Copyinterface (start: integer);   311   1   15:D     2         { Rewritten March 4, 1979 by G. Dismukes for II.0 }   312   1   15:D     2 	var blkcount, ifsize: integer;   313   1   15:D     4             done: Boolean;   314   1   15:D     5 	    buf: packed array [0..1023] of char;   315   1   15:0     0       begin   316   1   15:1     0         if (start <= 0) or (start > 200) then   317   1   15:2    11 	  exit(Copyinterface);   318   1   15:1    15 	ifsize:= intbl^.segdsc[sseg].diskaddr - start;   319   1   15:1    31 	if (ifsize <= 0) or odd(ifsize) then   320   1   15:2    38 	begin   321   1   15:3    38 	  pl:= 'Interface error';   322   1   15:3    61 	  prompt(error);   323   1   15:3    64 	  exit(Copyinterface);   324   1   15:2    68 	end;   325   1   15:1    68 	codetable^.extra[dseg]:= outblock;   326   1   15:1    85 	done:= FALSE;   327   1   15:1    88 	blkcount:= 0;   328   1   15:1    91 	repeat   329   1   15:2    91 	  if blockread(infile, buf, 2, start+blkcount) <> 2 then   330   1   15:3   114 	  begin   331   1   15:4   114 	    pl:= 'Interface read err';   332   1   15:4   140 	    prompt(error);   333   1   15:4   143 	    done:= TRUE;   334   1   15:3   146 	  end   335   1   15:2   146 	  else   336   1   15:3   148 	    if blockwrite(code, buf, 2, outblock) <> 2 then   337   1   15:4   171 	    begin   338   1   15:5   171 	      pl:= 'Interface write err';   339   1   15:5   198 	      prompt(error);   340   1   15:5   201 	      done:= TRUE;   341   1   15:4   204 	    end   342   1   15:3   204 	    else   343   1   15:4   206 	    begin   344   1   15:5   206 	      outblock:= outblock + 2;   345   1   15:5   214 	      blkcount:= blkcount + 2;   346   1   15:5   219 	      done:= (blkcount = ifsize);   347   1   15:4   224 	    end;   348   1   15:1   224         until done;   349   1   15:0   227       end;   350   1   15:0   242    351   1   12:0     0     BEGIN   352   1   12:1     0       WITH INTBL^,SEGDSC[SSEG] DO   353   1   12:2    16 	BEGIN   354   1   12:3    16 	  CODETABLE^.EXTRA[DSEG] := 0;   355   1   12:3    31 	  IF (SEGKIND[SSEG] IN [3,4]) THEN   356   1   12:4    48 	    COPYINTERFACE(EXTRA[SSEG]);   357   1   12:3    62 	  NBLOCKS := (CODELENG+511) DIV 512;   358   1   12:3    75 	  IF BLOCKREAD(INFILE,BUF^,NBLOCKS,DISKADDR) <> NBLOCKS THEN   359   1   12:4   102 	    BEGIN   360   1   12:5   102 	      PL := 'Error reading seg ';   361   1   12:5   128 	      PROMPT(ERROR);   362   1   12:5   131 	      WRITE(OUTPUT,SSEG);   363   1   12:4   143 	    END   364   1   12:3   143 	  ELSE   365   1   12:4   145 	    IF BLOCKWRITE(CODE,BUF^,NBLOCKS,OUTBLOCK) <> NBLOCKS THEN   366   1   12:5   173 	      BEGIN   367   1   12:6   173 		PL := 'I/O error - no room on disk';   368   1   12:6   208 		PROMPT(ERROR);   369   1   12:5   211 	      END   370   1   12:4   211 	    ELSE   371   1   12:5   213 	      BEGIN   372   1   12:6   213 		CODETABLE^.SEGNAME[DSEG] := SEGNAME[SSEG];   373   1   12:6   239 		CODETABLE^.SEGDSC[DSEG].CODELENG := CODELENG;   374   1   12:6   255 		CODETABLE^.SEGDSC[DSEG].DISKADDR := OUTBLOCK;   375   1   12:6   270 		OUTBLOCK := OUTBLOCK+NBLOCKS;   376   1   12:6   280 		IF (SEGKIND[SSEG] < 0) OR (SEGKIND[SSEG] > 4) THEN   377   1   12:7   311 		  SEGKIND[SSEG] := 0;   378   1   12:6   324 		CODETABLE^.SEGKIND[DSEG] := SEGKIND[SSEG];   379   1   12:6   350 		IF SEGKIND[SSEG] <> 0 THEN   380   1   12:7   366 		  COPYLINKINFO(DISKADDR+NBLOCKS);   381   1   12:5   374 	      END   382   1   12:2   374 	END;   383   1   12:1   374       DISPLAY(MARKCODE,CODETABLE);   384   1   12:0   380     END;   385   1   12:0   396    386   1   16:D     3 FUNCTION CONFIRM: BOOLEAN;   387   1   16:D     3   VAR   388   1   16:D     3     N: INTEGER;   389   1   16:0     0   BEGIN   390   1   16:1     0     CONFIRM:=FALSE;   391   1   16:1     3     (*get segment*)   392   1   16:1     3     N:= 0;   393   1   16:1     6     PL := '';   394   1   16:1    14     PROMPT(WINDOW);   395   1   16:1    17     REPEAT   396   1   16:2    17       READ(CCH);   397   1   16:2    28       IF CCH = CHR(8) THEN   398   1   16:3    35 	N := N DIV 10;   399   1   16:2    40       IF CCH IN ['0'..'9'] THEN   400   1   16:3    58 	N := N*10 + ORD(CCH)-ORD('0')   401   1   16:1    66     UNTIL NOT (CCH IN [CHR(8),'0'..'9']);   402   1   16:1    90     IF CCH <> ' ' THEN (*probably N or Q*)   403   1   16:2    97       EXIT(CONFIRM);   404   1   16:1   101     IF N IN [0..MAXSEG] THEN (*good segment number*)   405   1   16:2   110       WITH INTBL^ DO   406   1   16:3   115 	IF SEGDSC[N].CODELENG > 0 THEN (*any chunk of code*)   407   1   16:4   127 	  BEGIN   408   1   16:5   127 	    SSEG := N;   409   1   16:5   134 	    REPEAT   410   1   16:6   134 	      PL := 'Seg to link into? ';   411   1   16:6   160 	      PROMPT(WINDOW);   412   1   16:6   163 	      READ(DSEG)   413   1   16:5   174 	    UNTIL DSEG IN [0..MAXSEG];   414   1   16:5   185 	    READ(CCH); { EAT XTRA CHAR }   415   1   16:5   196 	    CCH := 'Y'; (* TRICK THE REPLACEMENT BELOW *)   416   1   16:5   200 	    IF (CODETABLE^.SEGDSC[DSEG].CODELENG <> 0) THEN (*linking again*)   417   1   16:6   216 	      BEGIN   418   1   16:7   216 		PL :=   419   1   16:7   219 'WARNING - Segment already linked.  Please Reconfirm (y/n) - ';   420   1   16:7   284 		PROMPT(WINDOW);   421   1   16:7   287 		READ(INPUT,CCH);   422   1   16:7   298 		WRITELN(OUTPUT);   423   1   16:6   306 	      END;   424   1   16:5   306 	    CONFIRM := CCH IN ['Y','y']   425   1   16:4   309 	  END;   426   1   16:0   332   END; (* CONFIRM *)   427   1   16:0   352    428   1   11:0     0 BEGIN   429   1   11:1     0   IF LENGTH(NTITLE)>0 THEN   430   1   11:2     9     IF BLOCKREAD(INFILE,INTBL^,1,0) = 1 THEN   431   1   11:3    31       DISPLAY(MARKIN,INTBL)   432   1   11:2    35     ELSE   433   1   11:3    39       BEGIN   434   1   11:4    39 	RSLT:=IORESULT;   435   1   11:4    44 	PL := 'Read error # ';   436   1   11:4    65 	PROMPT(ERROR);   437   1   11:4    68 	WRITE(OUTPUT,RSLT);   438   1   11:3    80       END;   439   1   11:1    80   if firstfile then   440   1   11:2    86     if tableflipped(intbl^) then   441   1   11:3    95     begin   442   1   11:4    95       fliptable(intbl^);   443   1   11:4   100       flipped:= TRUE;   444   1   11:3   105     end   445   1   11:2   105     else   446   1   11:1   107   else   447   1   11:2   109     if flipped <> tableflipped(intbl^) then   448   1   11:3   124     begin   449   1   11:4   124       pl:= 'Incompatible byte sex';   450   1   11:4   153       prompt(error);   451   1   11:3   156     end   452   1   11:2   156     else   453   1   11:3   158       if flipped then   454   1   11:4   164 	fliptable(intbl^);   455   1   11:1   169   PL :=   456   1   11:1   172 'Segment # to link and <space>, N(ew file, Q(uit, A(bort';   457   1   11:1   232   PROMPT(0);   458   1   11:1   235   REPEAT   459   1   11:2   235     IF CONFIRM THEN   460   1   11:3   241     begin   461   1   11:4   241       if firstfile then   462   1   11:5   247 	firstfile:= FALSE;   463   1   11:4   252       LINKIT;   464   1   11:3   254     end;   465   1   11:1   254   UNTIL CCH IN ['N','Q','A','n','q','a'];   466   1   11:1   280   CLOSE(INFILE)   467   1   11:0   290 END (*LINKCODE*) ;   468   1   11:0   304    469   1    6:0     0 BEGIN   470   1    6:1     0   PAGE(OUTPUT);   471   1    6:1    10   PL := 'Pascal System Librarian [II.0]';   472   1    6:1    47   PROMPT(0);   473   1    6:1    50   NEW(CODETABLE);   474   1    6:1    57   NEW(INTBL);   475   1    6:1    64   PL := 'Output code file -> ';   476   1    6:1    91   REPEAT   477   1    6:2    91     PROMPT(11);   478   1    6:2    94     READLN(INPUT,TITLE);   479   1    6:2   114     if title = '*' then   480   1    6:3   122       title:= '*SYSTEM.LIBRARY';   481   1    6:2   145     IF LENGTH(TITLE) = 0 THEN EXIT(LIBRARIAN)   482   1    6:2   158     ELSE REWRITE(CODE,TITLE)   483   1    6:1   174   UNTIL (LENGTH(TITLE) = 0) OR (CHECKIO);   484   1    6:1   188   OUTBLOCK := 1; NEW(BUF);   485   1    6:1   200   IF SIZEOF(BLOCK0) <> 512 THEN   486   1    6:2   209     HALT;   487   1    6:1   211   FILLCHAR(CODETABLE^, SIZEOF(BLOCK0), 0);   488   1    6:1   220   WITH CODETABLE^ DO   489   1    6:2   224     FOR DSEG := 0 TO MAXSEG DO   490   1    6:3   245       SEGNAME[DSEG] := '        ';   491   1    6:1   280   firstfile:= TRUE;   492   1    6:1   285   flipped:= FALSE;   493   1    6:1   290   REPEAT   494   1    6:2   290     OPENFILE;   495   1    6:2   292     LINKCODE;   496   1    6:1   294   UNTIL CCH IN ['Q','q','A','a'];   497   1    6:1   318   IF CCH IN ['A','a'] THEN EXIT(LIBRARIAN);   498   1    6:1   344   PL := 'Notice? ';   499   1    6:1   359   PROMPT(23);   500   1    6:1   362   READLN(CODETABLE^.NOTICE);   501   1    6:1   384   if flipped then   502   1    6:2   390     fliptable(codetable^);   503   1    6:1   394   IF BLOCKWRITE(CODE,CODETABLE^,1,0) = 1 THEN   504   1    6:2   415     CLOSE(CODE,LOCK)   505   1    6:1   425   ELSE   506   1    6:2   427     WRITELN(OUTPUT,'Code write error ')   507   1    6:0   464 END { NEWLINKER } ;   508   1    6:0   482    509   1    2:0     0 BEGIN   510   1    2:1     0   NEWLINKER   511   1    2:0    26 END { LIBRARIAN } ;   512   1    2:0    54    513   1    2:0    54 {.fs# BEGIN END. }   514   1    1:0     0 {.fs} BEGIN LIBRARIAN END.