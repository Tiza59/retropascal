     3   1    1:D     1 {.fs} {$L L.COMPILER.TEXT[*]} { LIST file helps debugging since it has all proc nos etc. }
     4   1    1:D     1 
     5   1    1:D     1 {(*$C COPYRIGHT (C) 1979 REGENTS UCSD II.0.A.1*)}
     6   1    1:D     1 (*$T+*) (*$S+*)
     7   1    1:D     1 
     8   1    1:D     1 (* --- COMPGLBLS.TEXT --- *)
     9   1    1:D     1 (*$U-*)
    10   1    1:D     1 
    11   0    1:D     1 PROGRAM PASCALSYSTEM;  (* VERSION II.0  1-31-79 *)
    12   0    1:D     1 
    13   0    1:D     1 
    14   0    1:D     1 (************************************************)
    15   0    1:D     1 (*                                              *)
    16   0    1:D     1 (*        UCSD  PASCAL  COMPILER                *)
    17   0    1:D     1 (*                                              *)
    18   0    1:D     1 (*    BASED ON ZURICH P2 PORTABLE               *)
    19   0    1:D     1 (*    COMPILER, EXTENSIVLY                      *)
    20   0    1:D     1 (*    MODIFIED BY ROGER T. SUMNER               *)
    21   0    1:D     1 (*    SHAWN FANNING AND ALBERT A. HOFFMAN       *)
    22   0    1:D     1 (*    1976..1979                                *)
    23   0    1:D     1 (*                                              *)
    24   0    1:D     1 (*    RELEASE LEVEL: I.3 AUGUST, 1977		*)
    25   0    1:D     1 (*                   I.4 JANUARY, 1978          *)
    26   0    1:D     1 (*                   I.5 SEPTEMBER, 1978        *)
    27   0    1:D     1 (*                  II.0 JANUARY, 1979          *)
    28   0    1:D     1 (*						*)
    29   0    1:D     1 (*    INSTITUTE FOR INFORMATION SYSTEMS         *)
    30   0    1:D     1 (*    UC SAN DIEGO, LA JOLLA, CA 92093          *)
    31   0    1:D     1 (*                                              *)
    32   0    1:D     1 (*    KENNETH L. BOWLES, DIRECTOR               *)
    33   0    1:D     1 (*                                              *)
    34   0    1:D     1 (*    COPYRIGHT (C) 1979, REGENTS OF THE	*)
    35   0    1:D     1 (*    UNIVERSITY OF CALIFORNIA, SAN DIEGO	*)
    36   0    1:D     1 (*                                              *)
    37   0    1:D     1 (************************************************)
    38   0    1:D     1 TYPE PHYLE = FILE;
    39   0    1:D     1 INFOREC = RECORD
    40   0    1:D     1 	    WORKSYM,WORKCODE: ^PHYLE;
    41   0    1:D     1 	    ERRSYM,ERRBLK,ERRNUM: INTEGER;
    42   0    1:D     1 	    SLOWTERM,STUPID: BOOLEAN;
    43   0    1:D     1 	    ALTMODE: CHAR
    44   0    1:D     1 	  END;
    45   0    1:D     1 
    46   0    1:D     1 
    47   0    1:D     1 {.fs#} { interface does not exist; instead using the same mechanism as EDITOR }
    48   0    1:D     1 {.fs# SEGMENT PROCEDURE USERPROGRAM;   }
    49   0    1:D     1 
    50   0    1:D     1 {.fs#   SEGMENT PROCEDURE FILEHANDLER; }
    51   0    1:D     1 {.fs#   BEGIN END;                     }
    52   0    1:D     1 
    53   0    1:D     1 {.fs#   SEGMENT PROCEDURE DEBUGGER;    }
    54   0    1:D     1 {.fs#   BEGIN END;                     }
    55   0    1:D     1 
    56   0    1:D     1 {.fs#   SEGMENT PROCEDURE PRINTERROR;  }
    57   0    1:D     1 {.fs#   BEGIN END;                     }
    58   0    1:D     1 
    59   0    1:D     1 {.fs#   SEGMENT PROCEDURE INITIALIZE;  }
    60   0    1:D     1 {.fs#   BEGIN END;                     }
    61   0    1:D     1 
    62   0    1:D     1 {.fs#   SEGMENT PROCEDURE GETCMD;      }
    63   0    1:D     1 {.fs#   BEGIN END;                     }
    64   0    1:D     1 
    65   0    1:D     1 {.fs#   SEGMENT PROCEDURE NOTUSED1;    }
    66   0    1:D     1 {.fs#   BEGIN END;                     }
    67   0    1:D     1 
    68   0    1:D     1 {.fs#   SEGMENT PROCEDURE NOTUSED2;    }
    69   0    1:D     1 {.fs#   BEGIN END;                     }
    70   0    1:D     1 
    71   0    1:D     1 {.fs#   SEGMENT PROCEDURE NOTUSED3;    }
    72   0    1:D     1 {.fs#   BEGIN END;                     }
    73   0    1:D     1 
    74   0    1:D     1 {.fs# BEGIN END; (* USERPROGRAM *)     }
    75   0    1:D     1 
    76   0    1:D     1 {.fs# SEGMENT PROCEDURE PASCALCOMPILER(VAR USERINFO: INFOREC); }
    77   0    1:D     1 
    78   0    1:D     1 {.fs} { access to USERINFO through globals }
    79   0    1:D     1 {.fs} { (this is copied from EDITOR.TEXT) }
    80   0    1:D     1 {.fs} VAR (* I.4 Globals as of 30-Jan-78 *)
    81   0    1:D     1 {.fs}   TRASHY: ARRAY [0..6] OF INTEGER;
    82   0    1:D     8 {.fs}   USERINFO: INFOREC;
    83   0    1:D    16 
    84   1    1:D     1 {.fs} SEGMENT PROCEDURE PASCALCOMPILER(XXX,YYY: INTEGER);
    85   1    1:D     3 
    86   1    1:D     3 CONST DISPLIMIT = 12; MAXLEVEL = 8; MAXADDR = 28000;
    87   1    1:D     3       INTSIZE = 1; REALSIZE = 2; BITSPERWD = 16;
    88   1    1:D     3       CHARSIZE = 1; BOOLSIZE = 1; PTRSIZE = 1;
    89   1    1:D     3       FILESIZE = 300; NILFILESIZE = 40; BITSPERCHR = 8; CHRSPERWD = 2;
    90   1    1:D     3       STRINGSIZE = 0; STRGLGTH = 255; MAXINT = 32767; MAXDEC = 36;
    91   1    1:D     3       DEFSTRGLGTH = 80; LCAFTERMARKSTACK = 1; REFSPERBLK = 128;
    92   1    1:D     3       EOL = 13; MAXCURSOR = 1023; MAXCODE = 1299;
    93   1    1:D     3       MAXJTAB = 24; MAXSEG = 15; MAXPROCNUM = 149;
    94   1    1:D     3 
    95   1    1:D     3 TYPE
    96   1    1:D     3 		 (*BASIC SYMBOLS, MUST MATCH ORDER IN IDSEARCH*)
    97   1    1:D     3 
    98   1    1:D     3      SYMBOL =  (IDENT,COMMA,COLON,SEMICOLON,LPARENT,RPARENT,DOSY,TOSY,
    99   1    1:D     3 		DOWNTOSY,ENDSY,UNTILSY,OFSY,THENSY,ELSESY,BECOMES,LBRACK,
   100   1    1:D     3 		RBRACK,ARROW,PERIOD,BEGINSY,IFSY,CASESY,REPEATSY,WHILESY,
   101   1    1:D     3 		FORSY,WITHSY,GOTOSY,LABELSY,CONSTSY,TYPESY,VARSY,PROCSY,
   102   1    1:D     3 		FUNCSY,PROGSY,FORWARDSY,INTCONST,REALCONST,STRINGCONST,
   103   1    1:D     3 		NOTSY,MULOP,ADDOP,RELOP,SETSY,PACKEDSY,ARRAYSY,RECORDSY,
   104   1    1:D     3 		FILESY,OTHERSY,LONGCONST,USESSY,UNITSY,INTERSY,IMPLESY,
   105   1    1:D     3 		EXTERNLSY,SEPARATSY);
   106   1    1:D     3 
   107   1    1:D     3 
   108   1    1:D     3      OPERATOR = (MUL,RDIV,ANDOP,IDIV,IMOD,PLUS,MINUS,OROP,LTOP,LEOP,
   109   1    1:D     3 		 GEOP,GTOP,NEOP,EQOP,INOP,NOOP);
   110   1    1:D     3 
   111   1    1:D     3      SETOFSYS = SET OF SYMBOL;
   112   1    1:D     3 
   113   1    1:D     3      NONRESIDENT = (SEEK,FREADREAL,FWRITEREAL,FREADDEC,FWRITEDEC,DECOPS);
   114   1    1:D     3      NONRESPFLIST = ARRAY[NONRESIDENT] OF INTEGER;
   115   1    1:D     3 
   116   1    1:D     3 					      (*CONSTANTS*)
   117   1    1:D     3      CSTCLASS = (REEL,PSET,STRG,TRIX,LONG);
   118   1    1:D     3      CSP = ^ CONSTREC;
   119   1    1:D     3      CONSTREC = RECORD CASE CCLASS: CSTCLASS OF
   120   1    1:D     3 			 LONG: (LLENG,LLAST: INTEGER;
   121   1    1:D     3 				LONGVAL: ARRAY[1..9] OF INTEGER);
   122   1    1:D     3 			 TRIX: (CSTVAL: ARRAY [1..8] OF INTEGER);
   123   1    1:D     3 			       (*MUST COMPLETELY OVERLAP FOLLOWING FIELDS*)
   124   1    1:D     3 			 REEL: (RVAL: REAL);
   125   1    1:D     3 			 PSET: (PVAL: SET OF 0..127);
   126   1    1:D     3 			 STRG: (SLGTH: 0..STRGLGTH;
   127   1    1:D     3 				SVAL: PACKED ARRAY [1..STRGLGTH] OF CHAR)
   128   1    1:D     3 		       END;
   129   1    1:D     3 
   130   1    1:D     3      VALU = RECORD CASE BOOLEAN OF
   131   1    1:D     3 		     TRUE:  (IVAL: INTEGER);
   132   1    1:D     3 		     FALSE: (VALP: CSP)
   133   1    1:D     3 		   END;
   134   1    1:D     3 
   135   1    1:D     3 						  (*DATA STRUCTURES*)
   136   1    1:D     3      BITRANGE = 0..BITSPERWD; OPRANGE = 0..80;
   137   1    1:D     3      CURSRANGE = 0..MAXCURSOR; PROCRANGE = 0..MAXPROCNUM;
   138   1    1:D     3      LEVRANGE = 0..MAXLEVEL; ADDRRANGE = 0..MAXADDR;
   139   1    1:D     3      JTABRANGE = 0..MAXJTAB; SEGRANGE = 0..MAXSEG;
   140   1    1:D     3      DISPRANGE = 0..DISPLIMIT;
   141   1    1:D     3 
   142   1    1:D     3      STRUCTFORM = (SCALAR,SUBRANGE,POINTER,LONGINT,POWER,ARRAYS,
   143   1    1:D     3 		   RECORDS,FILES,TAGFLD,VARIANT);
   144   1    1:D     3 
   145   1    1:D     3      DECLKIND = (STANDARD,DECLARED,SPECIAL);
   146   1    1:D     3 
   147   1    1:D     3      STP = ^ STRUCTURE; CTP = ^ IDENTIFIER;
   148   1    1:D     3 
   149   1    1:D     3      STRUCTURE = RECORD
   150   1    1:D     3 		   SIZE: ADDRRANGE;
   151   1    1:D     3 		   CASE FORM: STRUCTFORM OF
   152   1    1:D     3 		     SCALAR:   (CASE SCALKIND: DECLKIND OF
   153   1    1:D     3 				  DECLARED: (FCONST: CTP));
   154   1    1:D     3 		     SUBRANGE: (RANGETYPE: STP; MIN,MAX: VALU);
   155   1    1:D     3 		     POINTER:  (ELTYPE: STP);
   156   1    1:D     3 		     POWER:    (ELSET: STP);
   157   1    1:D     3 		     ARRAYS:   (AELTYPE,INXTYPE: STP;
   158   1    1:D     3 				CASE AISPACKD:BOOLEAN OF
   159   1    1:D     3 				  TRUE: (ELSPERWD,ELWIDTH: BITRANGE;
   160   1    1:D     3 					 CASE AISSTRNG: BOOLEAN OF
   161   1    1:D     3 					  TRUE:(MAXLENG: 1..STRGLGTH)));
   162   1    1:D     3 		     RECORDS:  (FSTFLD: CTP; RECVAR: STP);
   163   1    1:D     3 		     FILES:    (FILTYPE: STP);
   164   1    1:D     3 		     TAGFLD:   (TAGFIELDP: CTP; FSTVAR: STP);
   165   1    1:D     3 		     VARIANT:  (NXTVAR,SUBVAR: STP; VARVAL: VALU)
   166   1    1:D     3 		   END;
   167   1    1:D     3 
   168   1    1:D     3 							    (*NAMES*)
   169   1    1:D     3      IDCLASS = (TYPES,KONST,FORMALVARS,ACTUALVARS,FIELD,
   170   1    1:D     3 		PROC,FUNC,MODULE);
   171   1    1:D     3      SETOFIDS = SET OF IDCLASS;
   172   1    1:D     3      IDKIND = (ACTUAL,FORMAL);
   173   1    1:D     3      ALPHA = PACKED ARRAY [1..8] OF CHAR;
   174   1    1:D     3      
   175   1    1:D     3      IDENTIFIER = RECORD
   176   1    1:D     3 		   NAME: ALPHA; LLINK, RLINK: CTP;
   177   1    1:D     3 		   IDTYPE: STP; NEXT: CTP;
   178   1    1:D     3 		   CASE KLASS: IDCLASS OF
   179   1    1:D     3 		     KONST: (VALUES: VALU);
   180   1    1:D     3 		FORMALVARS,
   181   1    1:D     3 		ACTUALVARS: (VLEV: LEVRANGE;
   182   1    1:D     3 			     VADDR: ADDRRANGE;
   183   1    1:D     3 			     CASE BOOLEAN OF
   184   1    1:D     3 			       TRUE: (PUBLIC: BOOLEAN));
   185   1    1:D     3 		     FIELD: (FLDADDR: ADDRRANGE;
   186   1    1:D     3 			     CASE FISPACKD: BOOLEAN OF
   187   1    1:D     3 			       TRUE: (FLDRBIT,FLDWIDTH: BITRANGE));
   188   1    1:D     3 		     PROC,
   189   1    1:D     3 		     FUNC:  (CASE PFDECKIND: DECLKIND OF
   190   1    1:D     3 			      SPECIAL:  (KEY: INTEGER);
   191   1    1:D     3 			      STANDARD: (CSPNUM: INTEGER);
   192   1    1:D     3 			      DECLARED: (PFLEV: LEVRANGE;
   193   1    1:D     3 					 PFNAME: PROCRANGE;
   194   1    1:D     3 					 PFSEG: SEGRANGE;
   195   1    1:D     3 					 CASE PFKIND: IDKIND OF
   196   1    1:D     3 					  ACTUAL: (LOCALLC: ADDRRANGE;
   197   1    1:D     3 						   FORWDECL: BOOLEAN;
   198   1    1:D     3 						   EXTURNAL: BOOLEAN;
   199   1    1:D     3 						   INSCOPE: BOOLEAN;
   200   1    1:D     3 						   CASE BOOLEAN OF
   201   1    1:D     3 						    TRUE: (IMPORTED:BOOLEAN))));
   202   1    1:D     3 		   MODULE: (SEGID: INTEGER)
   203   1    1:D     3 		   END;
   204   1    1:D     3 
   205   1    1:D     3 
   206   1    1:D     3      WHERE = (BLCK,CREC,VREC,REC);
   207   1    1:D     3 
   208   1    1:D     3 					      (*EXPRESSIONS*)
   209   1    1:D     3      ATTRKIND = (CST,VARBL,EXPR);
   210   1    1:D     3      VACCESS = (DRCT,INDRCT,PACKD,MULTI,BYTE);
   211   1    1:D     3 
   212   1    1:D     3      ATTR = RECORD TYPTR: STP;
   213   1    1:D     3 	      CASE KIND: ATTRKIND OF
   214   1    1:D     3 		CST:   (CVAL: VALU);
   215   1    1:D     3 		VARBL: (CASE ACCESS: VACCESS OF
   216   1    1:D     3 			  DRCT:   (VLEVEL: LEVRANGE; DPLMT: ADDRRANGE);
   217   1    1:D     3 			  INDRCT: (IDPLMT: ADDRRANGE))
   218   1    1:D     3 	    END;
   219   1    1:D     3 
   220   1    1:D     3      TESTP = ^ TESTPOINTER;
   221   1    1:D     3      TESTPOINTER = RECORD
   222   1    1:D     3 		     ELT1,ELT2 : STP;
   223   1    1:D     3 		     LASTTESTP : TESTP
   224   1    1:D     3 		   END;
   225   1    1:D     3 
   226   1    1:D     3 						   (*LABELS*)
   227   1    1:D     3      LBP = ^ CODELABEL;
   228   1    1:D     3      CODELABEL = RECORD
   229   1    1:D     3 		   CASE DEFINED: BOOLEAN OF
   230   1    1:D     3 		     FALSE: (REFLIST: ADDRRANGE);
   231   1    1:D     3 		     TRUE:  (OCCURIC: ADDRRANGE; JTABINX: JTABRANGE)
   232   1    1:D     3 		 END;
   233   1    1:D     3 
   234   1    1:D     3      LABELP = ^ USERLABEL;
   235   1    1:D     3      USERLABEL = RECORD
   236   1    1:D     3 		   LABVAL: INTEGER;
   237   1    1:D     3 		   NEXTLAB: LABELP;
   238   1    1:D     3 		   CODELBP: LBP
   239   1    1:D     3 		 END;
   240   1    1:D     3 
   241   1    1:D     3      REFARRAY = ARRAY[1..REFSPERBLK] OF
   242   1    1:D     3 		  RECORD
   243   1    1:D     3 		    KEY,OFFSET: INTEGER
   244   1    1:D     3 		  END;
   245   1    1:D     3 
   246   1    1:D     3      CODEARRAY = PACKED ARRAY [0..MAXCODE] OF CHAR;
   247   1    1:D     3      SYMBUFARRAY = PACKED ARRAY [CURSRANGE] OF CHAR;
   248   1    1:D     3      
   249   1    1:D     3      UNITFILE = (WORKCODE,SYSLIBRARY);
   250   1    1:D     3 
   251   1    1:D     3      LEXSTKREC = RECORD
   252   1    1:D     3 		   DOLDTOP: DISPRANGE;
   253   1    1:D     3 		   DOLDLEV: 0..MAXLEVEL;
   254   1    1:D     3 		   POLDPROC,SOLDPROC: PROCRANGE;
   255   1    1:D     3 		   DOLDSEG: SEGRANGE;
   256   1    1:D     3 		   DLLC: ADDRRANGE;
   257   1    1:D     3 		   BFSY: SYMBOL;
   258   1    1:D     3 		   DFPROCP: CTP;
   259   1    1:D     3 		   DMARKP: ^INTEGER;
   260   1    1:D     3 		   ISSEGMENT: BOOLEAN;
   261   1    1:D     3 		   PREVLEXSTACKP: ^LEXSTKREC
   262   1    1:D     3 		 END;
   263   1    1:D     3 
   264   1    1:D     3 
   265   1    1:D     3 (*--------------------------------------------------------------------*)
   266   1    1:D     3 
   267   1    1:D     3 VAR
   268   1    1:D     3 
   269   1    1:D     3     CODEP: ^ CODEARRAY;             (*CODE BUFFER UNTIL WRITEOUT*)
   270   1    1:D     4     SYMBUFP: ^ SYMBUFARRAY;         (*SYMBOLIC BUFFER...ASCII OR CODED*)
   271   1    1:D     5 
   272   1    1:D     5     GATTR: ATTR;                    (*DESCRIBES CURRENT EXPRESSION*)
   273   1    1:D    10 
   274   1    1:D    10     TOP: DISPRANGE;                 (*TOP OF DISPLAY*)
   275   1    1:D    11     LC,IC: ADDRRANGE;               (*LOCATION AND INSTRUCT COUNTERS*)
   276   1    1:D    13     TEST: BOOLEAN;
   277   1    1:D    14     INTPTR: STP;                    (*POINTER TO STANDARD INTEGER TYPE*)
   278   1    1:D    15     SEG: SEGRANGE;                  (*CURRENT SEGMENT NO.*)
   279   1    1:D    16 				    (*SCANNER GLOBALS...NEXT FOUR VARS*)
   280   1    1:D    16 				    (*MUST BE IN THIS ORDER FOR IDSEARCH*)
   281   1    1:D    16     SYMCURSOR: CURSRANGE;           (*CURRENT SCANNING INDEX IN SYMBUFP^*)
   282   1    1:D    17     SY: SYMBOL;                     (*SYMBOL FOUND BY INSYMBOL*)
   283   1    1:D    18     OP: OPERATOR;                   (*CLASSIFICATION OF LAST SYMBOL*)
   284   1    1:D    19     ID: ALPHA;                      (*LAST IDENTIFIER FOUND*)
   285   1    1:D    23 
   286   1    1:D    23     LGTH: INTEGER;                  (*LENGTH OF LAST STRING CONSTANT IN CHARS
   287   1    1:D    24 				      OR LEN OF LAST LONG INTEGER CONSTANT
   288   1    1:D    24 				       IN DIGITS*)
   289   1    1:D    24     VAL: VALU;                      (*VALUE OF LAST CONSTANT*)
   290   1    1:D    25     DISX: DISPRANGE;                (*LEVEL OF LAST ID SEARCHED*)
   291   1    1:D    26 
   292   1    1:D    26     LCMAX: ADDRRANGE;               (*TEMPORARIES LOCATION COUNTER*)
   293   1    1:D    27 
   294   1    1:D    27 				    (*SWITCHES:*)
   295   1    1:D    27 
   296   1    1:D    27     PRTERR,GOTOOK,RANGECHECK,DEBUGGING,
   297   1    1:D    27     NOISY,CODEINSEG,IOCHECK,BPTONLINE,
   298   1    1:D    27     CLINKERINFO,DLINKERINFO,LIST,TINY,LSEPPROC,
   299   1    1:D    27     DP,INCLUDING,USING,NOSWAP,SEPPROC,
   300   1    1:D    27     STARTINGUP,INMODULE,ININTERFACE,FLIPBYTES,
   301   1    1:D    27     LIBNOTOPEN,SYSCOMP,PUBLICPROCS,GETSTMTLEV: BOOLEAN;
   302   1    1:D    53 
   303   1    1:D    53 				    (*POINTERS:*)
   304   1    1:D    53     (*INTPTR,*)REALPTR,LONGINTPTR,
   305   1    1:D    53     CHARPTR,BOOLPTR,
   306   1    1:D    53     TEXTPTR,NILPTR,
   307   1    1:D    53     INTRACTVPTR,STRGPTR: STP;       (*POINTERS TO STANDARD IDS*)
   308   1    1:D    61 
   309   1    1:D    61     UTYPPTR,UCSTPTR,UVARPTR,
   310   1    1:D    61     UFLDPTR,UPRCPTR,UFCTPTR,        (*POINTERS TO UNDECLARED IDS*)
   311   1    1:D    61     MODPTR,INPUTPTR,OUTPUTPTR,
   312   1    1:D    61     OUTERBLOCK,FWPTR,USINGLIST: CTP;
   313   1    1:D    73 
   314   1    1:D    73     GLOBTESTP: TESTP;               (*LAST TESTPOINTER*)
   315   1    1:D    74 
   316   1    1:D    74     LEVEL: LEVRANGE;                (*CURRENT STATIC LEVEL*)
   317   1    1:D    75     BEGSTMTLEV,STMTLEV: INTEGER;    (*CURRENT STATEMENT NESTING LEVEL*)
   318   1    1:D    77     MARKP: ^INTEGER;                (*FOR MARKING HEAP*)
   319   1    1:D    78     TOS: ^LEXSTKREC;                (*TOP OF LEX STACK*)
   320   1    1:D    79     GLEV: DISPRANGE;                (*GLOBAL LEVEL OF DISPLAY*)
   321   1    1:D    80     NEWBLOCK: BOOLEAN;              (*INDICATES NEED TO PUSH LEX STACK*)
   322   1    1:D    81 
   323   1    1:D    81     NEXTSEG: SEGRANGE;              (*NEXT SEGMENT #*)
   324   1    1:D    82     SEGINX: INTEGER;                (*CURRENT INDEX IN SEGMENT*)
   325   1    1:D    83     SCONST: CSP;                    (*INSYMBOL STRING RESULTS*)
   326   1    1:D    84     STRGCSTIC: ADDRRANGE;           (*ADDR OF LAST STRING IN CODE*)
   327   1    1:D    85 
   328   1    1:D    85     LOWTIME,LINEINFO,SCREENDOTS,STARTDOTS,SYMBLK,SMALLESTSPACE: INTEGER;
   329   1    1:D    91     LINESTART: CURSRANGE;
   330   1    1:D    92 
   331   1    1:D    92     CURPROC,NEXTPROC: PROCRANGE;     (*PROCEDURE NUMBER ASSIGNMENT*)
   332   1    1:D    94 
   333   1    1:D    94     CONSTBEGSYS,SIMPTYPEBEGSYS,TYPEBEGSYS,
   334   1    1:D    94     BLOCKBEGSYS,SELECTSYS,FACBEGSYS,STATBEGSYS,TYPEDELS: SETOFSYS;
   335   1    1:D   126     VARS: SETOFIDS;
   336   1    1:D   127 
   337   1    1:D   127     DISPLAY: ARRAY [DISPRANGE] OF
   338   1    1:D   127 		RECORD
   339   1    1:D   127 		  FNAME: CTP;
   340   1    1:D   127 		  CASE OCCUR: WHERE OF
   341   1    1:D   127 		    BLCK: (FFILE: CTP; FLABEL: LABELP);
   342   1    1:D   127 		    CREC: (CLEV: LEVRANGE; CDSPL: ADDRRANGE);
   343   1    1:D   127 		    VREC: (VDSPL: ADDRRANGE)
   344   1    1:D   127 		  END;
   345   1    1:D   179 
   346   1    1:D   179     PFNUMOF: NONRESPFLIST;
   347   1    1:D   185 
   348   1    1:D   185     PROCTABLE: ARRAY [PROCRANGE] OF INTEGER;
   349   1    1:D   335 
   350   1    1:D   335     SEGTABLE: ARRAY [SEGRANGE] OF
   351   1    1:D   335 		RECORD
   352   1    1:D   335 		  DISKADDR,CODELENG: INTEGER;
   353   1    1:D   335 		  SEGNAME: ALPHA;
   354   1    1:D   335 		  SEGKIND,
   355   1    1:D   335 		  TEXTADDR: INTEGER
   356   1    1:D   335 		END (*SEGTABLE*) ;
   357   1    1:D   463 
   358   1    1:D   463     COMMENT: ^STRING;
   359   1    1:D   464     SYSTEMLIB: STRING[40];
   360   1    1:D   485     NEXTJTAB: JTABRANGE;
   361   1    1:D   486     JTAB: ARRAY [JTABRANGE] OF INTEGER;
   362   1    1:D   511 
   363   1    1:D   511     REFFILE: FILE;
   364   1    1:D   551     NREFS,REFBLK: INTEGER;
   365   1    1:D   553     REFLIST: ^REFARRAY;
   366   1    1:D   554     OLDSYMBLK,PREVSYMBLK: INTEGER;
   367   1    1:D   556     OLDSYMCURSOR,OLDLINESTART,PREVSYMCURSOR,PREVLINESTART: CURSRANGE;
   368   1    1:D   560     USEFILE: UNITFILE;
   369   1    1:D   561 {.fs# INCLFILE,LIBRARY: FILE; } { compiler bug, cannot handle multiple FILE decls }
   370   1    1:D   561 {.fs} LIBRARY: FILE; INCLFILE: FILE;
   371   1    1:D   641     LP: TEXT;
   372   1    1:D   942 
   373   1    1:D   942     CURBYTE, CURBLK: INTEGER;
   374   1    1:D   944     DISKBUF: PACKED ARRAY [0..511] OF CHAR;
   375   1    1:D  1200 
   376   1    1:D  1200 (*--------------------------------------------------------------------*)
   377   1    1:D  1200 
   378   1    1:D  1200 {.fs} { occupy the segments we should not get into (copied from EDITOR) }
   379   3    1:1     0 {.fs} SEGMENT PROCEDURE NUM2; BEGIN END;      SEGMENT PROCEDURE NUM3; BEGIN END;
   380   5    1:0     0 {.fs} SEGMENT PROCEDURE NUM4; BEGIN END;      SEGMENT PROCEDURE NUM5; BEGIN END;
   381   7    1:0     0 {.fs} SEGMENT PROCEDURE NUM6; BEGIN END;      SEGMENT PROCEDURE NUM7; BEGIN END;
   382   9    1:0     0 {.fs} SEGMENT PROCEDURE NUM8; BEGIN END;      SEGMENT PROCEDURE NUM9; BEGIN END;
   383   9    1:0    12 
   384   9    1:0    12 (* FORWARD DECLARED PROCEDURES NEEDED BY COMPINIT *)
   385   9    1:0    12 
   386   1    2:D     1 PROCEDURE ERROR(ERRORNUM: INTEGER);
   387   1    2:D     2   FORWARD;
   388   1    3:D     1 PROCEDURE GETNEXTPAGE;
   389   1    3:D     1   FORWARD;
   390   1    4:D     1 PROCEDURE PRINTLINE;
   391   1    4:D     1   FORWARD;
   392   1    5:D     1 PROCEDURE ENTERID(FCP: CTP);
   393   1    5:D     2   FORWARD;
   394   1    6:D     1 PROCEDURE INSYMBOL;
   395   1    6:D     1   FORWARD;
   396   1    6:D     1 
   397   1    6:D     1 (* FORWARD DECLARED PROCEDURES USED IN BOTH DECLARATIONPART AND BODYPART *)
   398   1    6:D     1 
   399   1    7:D     1 PROCEDURE SEARCHSECTION(FCP:CTP; VAR FCP1: CTP);
   400   1    7:D     3   FORWARD;
   401   1    8:D     1 PROCEDURE SEARCHID(FIDCLS: SETOFIDS; VAR FCP: CTP);
   402   1    8:D     3   FORWARD;
   403   1    9:D     1 PROCEDURE GETBOUNDS(FSP: STP; VAR FMIN,FMAX: INTEGER);
   404   1    9:D     4   FORWARD;
   405   1   10:D     1 PROCEDURE SKIP(FSYS: SETOFSYS);
   406   1   10:D     5   FORWARD;
   407   1   11:D     3 FUNCTION PAOFCHAR(FSP: STP): BOOLEAN;
   408   1   11:D     4   FORWARD;
   409   1   12:D     3 FUNCTION STRGTYPE(FSP: STP): BOOLEAN;
   410   1   12:D     4   FORWARD;
   411   1   13:D     3 FUNCTION DECSIZE(I: INTEGER): INTEGER;
   412   1   13:D     4   FORWARD;
   413   1   14:D     1 PROCEDURE CONSTANT(FSYS: SETOFSYS; VAR FSP: STP; VAR FVALU: VALU);
   414   1   14:D     7   FORWARD;
   415   1   15:D     3 FUNCTION COMPTYPES(FSP1,FSP2: STP): BOOLEAN;
   416   1   15:D     5   FORWARD;
   417   1   16:D     1 PROCEDURE GENBYTE(FBYTE: INTEGER);
   418   1   16:D     2   FORWARD;
   419   1   17:D     1 PROCEDURE GENWORD(FWORD: INTEGER);
   420   1   17:D     2   FORWARD;
   421   1   18:D     1 PROCEDURE WRITETEXT;
   422   1   18:D     1   FORWARD;
   423   1   19:D     1 PROCEDURE WRITECODE(FORCEBUF: BOOLEAN);
   424   1   19:D     2   FORWARD;
   425   1   20:D     1 PROCEDURE BLOCK(FSYS: SETOFSYS);
   426   1   20:D     5   FORWARD;
   427   1   20:D     5 
   428   1   20:D     5 (* --- COMPINIT.TEXT --- *)
   429   1   20:D     5 
   430  10    1:D     1 SEGMENT PROCEDURE COMPINIT;
   431  10    1:D     1 
   432  10    2:D     1   PROCEDURE ENTSTDTYPES;
   433  10    2:0     0   BEGIN
   434  10    2:1     0     NEW(INTPTR,SCALAR,STANDARD);
   435  10    2:1     5     WITH INTPTR^ DO
   436  10    2:2     8       BEGIN SIZE := INTSIZE; FORM := SCALAR; SCALKIND := STANDARD END;
   437  10    2:1    21     NEW(REALPTR,SCALAR,STANDARD);
   438  10    2:1    26     WITH REALPTR^ DO
   439  10    2:2    30       BEGIN SIZE := REALSIZE; FORM := SCALAR; SCALKIND := STANDARD END;
   440  10    2:1    43     NEW(LONGINTPTR,LONGINT);
   441  10    2:1    48     WITH LONGINTPTR^ DO
   442  10    2:2    52       BEGIN SIZE := DECSIZE((BITSPERWD-1)*100 DIV 332 + 1); FORM := LONGINT END;
   443  10    2:1    75     NEW(CHARPTR,SCALAR,STANDARD);
   444  10    2:1    80     WITH CHARPTR^ DO
   445  10    2:2    84       BEGIN SIZE := CHARSIZE; FORM := SCALAR; SCALKIND := STANDARD END;
   446  10    2:1    97     NEW(BOOLPTR,SCALAR,DECLARED);
   447  10    2:1   102     WITH BOOLPTR^ DO
   448  10    2:2   106       BEGIN SIZE := BOOLSIZE; FORM := SCALAR; SCALKIND := DECLARED END;
   449  10    2:1   119     NEW(NILPTR,POINTER);
   450  10    2:1   124     WITH NILPTR^ DO
   451  10    2:2   128       BEGIN SIZE := PTRSIZE; FORM := POINTER; ELTYPE := NIL END;
   452  10    2:1   141     NEW(TEXTPTR,FILES);
   453  10    2:1   146     WITH TEXTPTR^ DO
   454  10    2:2   150       BEGIN SIZE := FILESIZE+CHARSIZE; FORM := FILES; FILTYPE := CHARPTR END;
   455  10    2:1   168     NEW(INTRACTVPTR,FILES);
   456  10    2:1   173     WITH INTRACTVPTR^ DO
   457  10    2:2   177       BEGIN SIZE := FILESIZE+CHARSIZE; FORM := FILES; FILTYPE := CHARPTR END;
   458  10    2:1   195     NEW(STRGPTR,ARRAYS,TRUE,TRUE);
   459  10    2:1   200     WITH STRGPTR^ DO
   460  10    2:2   204       BEGIN FORM := ARRAYS; SIZE := (DEFSTRGLGTH + CHRSPERWD) DIV CHRSPERWD;
   461  10    2:3   216 	AISPACKD := TRUE; AISSTRNG := TRUE; INXTYPE := INTPTR;
   462  10    2:3   231 	ELWIDTH := BITSPERCHR; ELSPERWD := CHRSPERWD;
   463  10    2:3   241 	AELTYPE := CHARPTR; MAXLENG := DEFSTRGLGTH;
   464  10    2:2   252       END
   465  10    2:0   252   END (*ENTSTDTYPES*) ;
   466  10    2:0   264 
   467  10    3:D     1   PROCEDURE ENTSTDNAMES;
   468  10    3:D     1     VAR CP,CP1: CTP; I: INTEGER;
   469  10    3:0     0   BEGIN
   470  10    3:1     0     NEW(CP,TYPES);
   471  10    3:1     5     WITH CP^ DO
   472  10    3:2     8       BEGIN NAME := 'INTEGER '; IDTYPE := INTPTR; KLASS := TYPES END;
   473  10    3:1    32     ENTERID(CP);
   474  10    3:1    36     NEW(CP,TYPES);
   475  10    3:1    41     WITH CP^ DO
   476  10    3:2    44       BEGIN NAME := 'REAL    '; IDTYPE := REALPTR; KLASS := TYPES END;
   477  10    3:1    69     ENTERID(CP);
   478  10    3:1    73     NEW(CP,TYPES);
   479  10    3:1    78     WITH CP^ DO
   480  10    3:2    81       BEGIN NAME := 'CHAR    '; IDTYPE := CHARPTR; KLASS := TYPES END;
   481  10    3:1   106     ENTERID(CP);
   482  10    3:1   110     NEW(CP,TYPES);
   483  10    3:1   115     WITH CP^ DO
   484  10    3:2   118       BEGIN NAME := 'BOOLEAN '; IDTYPE := BOOLPTR; KLASS := TYPES END;
   485  10    3:1   143     ENTERID(CP);
   486  10    3:1   147     NEW(CP,TYPES);
   487  10    3:1   152     WITH CP^ DO
   488  10    3:2   155       BEGIN NAME := 'STRING  '; IDTYPE := STRGPTR; KLASS := TYPES END;
   489  10    3:1   180     ENTERID(CP);
   490  10    3:1   184     NEW(CP,TYPES);
   491  10    3:1   189     WITH CP^ DO
   492  10    3:2   192       BEGIN NAME := 'TEXT    '; IDTYPE := TEXTPTR; KLASS := TYPES END;
   493  10    3:1   217     ENTERID(CP);
   494  10    3:1   221     NEW(CP,TYPES);
   495  10    3:1   226     WITH CP^ DO
   496  10    3:2   229       BEGIN NAME := 'INTERACT'; IDTYPE := INTRACTVPTR; KLASS := TYPES END;
   497  10    3:1   254     ENTERID(CP);
   498  10    3:1   258     NEW(INPUTPTR,FORMALVARS,FALSE);
   499  10    3:1   263     WITH INPUTPTR^ DO
   500  10    3:2   267       BEGIN NAME := 'INPUT   '; IDTYPE := TEXTPTR; KLASS := FORMALVARS;
   501  10    3:3   292 	VLEV := 0; VADDR := 2
   502  10    3:2   300       END;
   503  10    3:1   302     ENTERID(INPUTPTR);
   504  10    3:1   307     NEW(OUTPUTPTR,FORMALVARS,FALSE);
   505  10    3:1   312     WITH OUTPUTPTR^ DO
   506  10    3:2   316       BEGIN NAME := 'OUTPUT  '; IDTYPE := TEXTPTR; KLASS := FORMALVARS;
   507  10    3:3   341 	VLEV := 0; VADDR := 3
   508  10    3:2   349       END;
   509  10    3:1   351     ENTERID(OUTPUTPTR);
   510  10    3:1   356     NEW(CP,FORMALVARS,FALSE);
   511  10    3:1   361     WITH CP^ DO
   512  10    3:2   364       BEGIN NAME := 'KEYBOARD'; IDTYPE := TEXTPTR; KLASS := FORMALVARS;
   513  10    3:3   389 	VLEV := 0; VADDR := 4
   514  10    3:2   397       END;
   515  10    3:1   399     ENTERID(CP);
   516  10    3:1   403     CP1 := NIL;
   517  10    3:1   406     FOR I := 0 TO 1 DO
   518  10    3:2   417       BEGIN NEW(CP,KONST);
   519  10    3:3   422 	WITH CP^ DO
   520  10    3:4   425 	  BEGIN IDTYPE := BOOLPTR;
   521  10    3:5   431 	    IF I = 0 THEN NAME := 'FALSE   '
   522  10    3:5   437 	    ELSE NAME := 'TRUE    ';
   523  10    3:5   466 	    NEXT := CP1; VALUES.IVAL := I; KLASS := KONST
   524  10    3:4   479 	  END;
   525  10    3:3   481 	ENTERID(CP); CP1 := CP
   526  10    3:2   485       END;
   527  10    3:1   495     BOOLPTR^.FCONST := CP;
   528  10    3:1   501     NEW(CP,KONST);
   529  10    3:1   506     WITH CP^ DO
   530  10    3:2   509       BEGIN NAME := 'NIL     '; IDTYPE := NILPTR;
   531  10    3:3   529 	NEXT := NIL; VALUES.IVAL := 0; KLASS := KONST
   532  10    3:2   542       END;
   533  10    3:1   544     ENTERID(CP);
   534  10    3:1   548     NEW(CP,KONST);
   535  10    3:1   553     WITH CP^ DO
   536  10    3:2   556       BEGIN
   537  10    3:3   556 	NAME := 'MAXINT  '; IDTYPE := INTPTR;
   538  10    3:3   575 	KLASS := KONST; VALUES.IVAL := MAXINT
   539  10    3:2   583       END;
   540  10    3:1   587     ENTERID(CP);
   541  10    3:0   591   END (*ENTSTDNAMES*) ;
   542  10    3:0   606 
   543  10    4:D     1   PROCEDURE ENTUNDECL;
   544  10    4:0     0   BEGIN
   545  10    4:1     0     NEW(UTYPPTR,TYPES);
   546  10    4:1     5     WITH UTYPPTR^ DO
   547  10    4:2     9       BEGIN NAME := '        '; IDTYPE := NIL; KLASS := TYPES END;
   548  10    4:1    33     NEW(UCSTPTR,KONST);
   549  10    4:1    38     WITH UCSTPTR^ DO
   550  10    4:2    42       BEGIN NAME := '        '; IDTYPE := NIL; NEXT := NIL;
   551  10    4:3    66 	VALUES.IVAL := 0; KLASS := KONST
   552  10    4:2    74       END;
   553  10    4:1    76     NEW(UVARPTR,ACTUALVARS,FALSE);
   554  10    4:1    81     WITH UVARPTR^ DO
   555  10    4:2    85       BEGIN NAME := '        '; IDTYPE := NIL;
   556  10    4:3   104 	NEXT := NIL; VLEV := 0; VADDR := 0; KLASS := ACTUALVARS
   557  10    4:2   122       END;
   558  10    4:1   124     NEW(UFLDPTR,FIELD);
   559  10    4:1   129     WITH UFLDPTR^ DO
   560  10    4:2   133       BEGIN NAME := '        '; IDTYPE := NIL; NEXT := NIL;
   561  10    4:3   157 	FLDADDR := 0; KLASS := FIELD
   562  10    4:2   165       END;
   563  10    4:1   167     NEW(UPRCPTR,PROC,DECLARED,ACTUAL,FALSE);
   564  10    4:1   172     WITH UPRCPTR^ DO
   565  10    4:2   176       BEGIN NAME := '        '; IDTYPE := NIL; FORWDECL := FALSE;
   566  10    4:3   200 	NEXT := NIL; INSCOPE := FALSE; LOCALLC := 0; EXTURNAL := FALSE;
   567  10    4:3   220 	PFLEV := 0; PFNAME := 0; PFSEG := 0;
   568  10    4:3   235 	KLASS := PROC; PFDECKIND := DECLARED; PFKIND := ACTUAL
   569  10    4:2   248       END;
   570  10    4:1   250     NEW(UFCTPTR,FUNC,DECLARED,ACTUAL,FALSE);
   571  10    4:1   255     WITH UFCTPTR^ DO
   572  10    4:2   259       BEGIN NAME := '        '; IDTYPE := NIL; NEXT := NIL;
   573  10    4:3   283 	FORWDECL := FALSE; EXTURNAL := FALSE; INSCOPE := FALSE; LOCALLC := 0;
   574  10    4:3   303 	PFLEV := 0; PFNAME := 0; PFSEG := 0;
   575  10    4:3   318 	KLASS := FUNC; PFDECKIND := DECLARED; PFKIND := ACTUAL
   576  10    4:2   331       END
   577  10    4:0   333   END (*ENTUNDECL*) ;
   578  10    4:0   346 
   579  10    5:D     1   PROCEDURE ENTSPCPROCS;
   580  10    5:D     1     LABEL 1;
   581  10    5:D     1     VAR LCP: CTP; I: INTEGER; ISFUNC: BOOLEAN;
   582  10    5:D     4 	NA: ARRAY [1..43] OF ALPHA;
   583  10    5:0     0   BEGIN
   584  10    5:1     0     NA[ 1] := 'READ    '; NA[ 2] := 'READLN  '; NA[ 3] := 'WRITE   ';
   585  10    5:1    60     NA[ 4] := 'WRITELN '; NA[ 5] := 'EOF     '; NA[ 6] := 'EOLN    ';
   586  10    5:1   120     NA[ 7] := 'PRED    '; NA[ 8] := 'SUCC    '; NA[ 9] := 'ORD     ';
   587  10    5:1   180     NA[10] := 'SQR     '; NA[11] := 'ABS     '; NA[12] := 'NEW     ';
   588  10    5:1   240     NA[13] := 'UNITREAD'; NA[14] := 'UNITWRIT'; NA[15] := 'CONCAT  ';
   589  10    5:1   300     NA[16] := 'LENGTH  '; NA[17] := 'INSERT  '; NA[18] := 'DELETE  ';
   590  10    5:1   360     NA[19] := 'COPY    '; NA[20] := 'POS     '; NA[21] := 'MOVELEFT';
   591  10    5:1   420     NA[22] := 'MOVERIGH'; NA[23] := 'EXIT    '; NA[24] := 'IDSEARCH';
   592  10    5:1   480     NA[25] := 'TREESEAR'; NA[26] := 'TIME    '; NA[27] := 'FILLCHAR';
   593  10    5:1   540     NA[28] := 'OPENNEW '; NA[29] := 'OPENOLD '; NA[30] := 'REWRITE ';
   594  10    5:1   600     NA[31] := 'CLOSE   '; NA[32] := 'SEEK    '; NA[33] := 'RESET   ';
   595  10    5:1   660     NA[34] := 'GET     '; NA[35] := 'PUT     '; NA[36] := 'SCAN    ';
   596  10    5:1   720     NA[37] := 'BLOCKREA'; NA[38] := 'BLOCKWRI'; NA[39] := 'TRUNC   ';
   597  10    5:1   780     NA[40] := 'PAGE    '; NA[41] := 'SIZEOF  '; NA[42] := 'STR     ';
   598  10    5:1   840     NA[43] := 'GOTOXY  ';
   599  10    5:1   860     FOR I := 1 TO 43 DO
   600  10    5:2   874       BEGIN
   601  10    5:3   874 	IF TINY THEN
   602  10    5:4   878 	    IF I IN [2,7,8,10,13,17,18,19,20,32,34,35,40,42,43] THEN
   603  10    5:5   892 	      GOTO 1;
   604  10    5:3   894 	ISFUNC := I IN [5,6,7,8,9,10,11,15,16,19,20,25,36,37,38,39,41];
   605  10    5:3   908 	IF ISFUNC THEN NEW(LCP,FUNC,SPECIAL)
   606  10    5:3   916 	ELSE NEW(LCP,PROC,SPECIAL);
   607  10    5:3   923 	WITH LCP^ DO
   608  10    5:4   927 	  BEGIN NAME := NA[I]; NEXT := NIL; IDTYPE := NIL;
   609  10    5:5   953 	    IF ISFUNC THEN KLASS := FUNC ELSE KLASS := PROC;
   610  10    5:5   972 	    PFDECKIND := SPECIAL; KEY := I
   611  10    5:4   984 	  END;
   612  10    5:3   986 	ENTERID(LCP);
   613  10    5:3   990 1:    END
   614  10    5:0   990     END (*ENTSPCPROCS*) ;
   615  10    5:0  1012 
   616  10    6:D     1   PROCEDURE ENTSTDPROCS;
   617  10    6:D     1     VAR LCP,PARAM: CTP; LSP,FTYPE: STP; I: INTEGER; ISPROC: BOOLEAN;
   618  10    6:D     7 	NA: ARRAY [1..19] OF ALPHA;
   619  10    6:0     0   BEGIN
   620  10    6:1     0     NA[ 1] := 'ODD     '; NA[ 2] := 'CHR     '; NA[ 3] := 'MEMAVAIL';
   621  10    6:1    60     NA[ 4] := 'ROUND   '; NA[ 5] := 'SIN     '; NA[ 6] := 'COS     ';
   622  10    6:1   120     NA[ 7] := 'LOG     '; NA[ 8] := 'ATAN    '; NA[ 9] := 'LN      ';
   623  10    6:1   180     NA[10] := 'EXP     '; NA[11] := 'SQRT    '; NA[12] := 'MARK    ';
   624  10    6:1   240     NA[13] := 'RELEASE '; NA[14] := 'IORESULT'; NA[15] := 'UNITBUSY';
   625  10    6:1   300     NA[16] := 'PWROFTEN'; NA[17] := 'UNITWAIT'; NA[18] := 'UNITCLEA';
   626  10    6:1   360     NA[19] := 'HALT    ';
   627  10    6:1   380     FOR I := 1 TO 19 DO
   628  10    6:2   392       BEGIN ISPROC := I IN [12,13,17,18,19];
   629  10    6:3   404 	CASE I OF
   630  10    6:3   407 	  1:  BEGIN FTYPE := BOOLPTR; NEW(PARAM,ACTUALVARS,FALSE);
   631  10    6:5   416 		WITH PARAM^ DO
   632  10    6:6   419 		  BEGIN IDTYPE := INTPTR; KLASS := ACTUALVARS END
   633  10    6:4   431 	      END;
   634  10    6:3   433 	  2:  FTYPE := CHARPTR;
   635  10    6:3   439 	  3:  BEGIN FTYPE := INTPTR; PARAM := NIL END;
   636  10    6:3   447 	  4:  BEGIN FTYPE := INTPTR; NEW(PARAM,ACTUALVARS,FALSE);
   637  10    6:5   455 		WITH PARAM^ DO BEGIN IDTYPE := REALPTR; KLASS := ACTUALVARS END
   638  10    6:4   471 	      END;
   639  10    6:3   473 	  5:  FTYPE := REALPTR;
   640  10    6:3   479 	 12:  BEGIN FTYPE := NIL; NEW(PARAM,FORMALVARS,FALSE); NEW(LSP,POINTER);
   641  10    6:5   492 		WITH LSP^ DO
   642  10    6:6   495 		  BEGIN SIZE := PTRSIZE; FORM := POINTER; ELTYPE := NIL END;
   643  10    6:5   511 		WITH PARAM^ DO BEGIN IDTYPE := LSP; KLASS := FORMALVARS END
   644  10    6:4   526 	      END;
   645  10    6:3   528 	 14:  BEGIN FTYPE := INTPTR; PARAM := NIL END;
   646  10    6:3   536 	 15:  BEGIN FTYPE := BOOLPTR; NEW(PARAM,ACTUALVARS,FALSE);
   647  10    6:5   545 	      WITH PARAM^ DO
   648  10    6:6   548 		BEGIN IDTYPE := INTPTR; KLASS := ACTUALVARS END;
   649  10    6:4   560 	      END;
   650  10    6:3   562 	 16:  FTYPE := REALPTR;
   651  10    6:3   568 	 17:  FTYPE := NIL;
   652  10    6:3   573 	 19:  BEGIN FTYPE := NIL; PARAM := NIL END
   653  10    6:3   579 	END (*PARAM AND TYPE CASES*) ;
   654  10    6:3   626 	IF ISPROC THEN NEW(LCP,PROC,STANDARD)
   655  10    6:3   634 	ELSE NEW(LCP,FUNC,STANDARD);
   656  10    6:3   641 	WITH LCP^ DO
   657  10    6:4   644 	  BEGIN NAME := NA[I]; PFDECKIND := STANDARD; CSPNUM := I + 20;
   658  10    6:5   669 	    IF ISPROC THEN KLASS := PROC ELSE KLASS := FUNC;
   659  10    6:5   686 	    IF PARAM <> NIL THEN PARAM^.NEXT := NIL;
   660  10    6:5   696 	    IDTYPE := FTYPE; NEXT := PARAM
   661  10    6:4   706 	  END;
   662  10    6:3   708 	ENTERID(LCP)
   663  10    6:2   709       END
   664  10    6:0   712     END (*ENTSTDPROCS*) ;
   665  10    6:0   740 
   666  10    7:D     1   PROCEDURE INITSCALARS;
   667  10    7:D     1    VAR I: NONRESIDENT;
   668  10    7:0     0   BEGIN
   669  10    7:1     0     IF MEMAVAIL > 9950 (* EMPIRICAL VALUE FOR A 50K BYTE MACHINE *) THEN
   670  10    7:2     8       NOSWAP := TRUE ELSE NOSWAP := FALSE;
   671  10    7:1    16     FWPTR := NIL; MODPTR := NIL; GLOBTESTP := NIL;
   672  10    7:1    25     LINESTART := 0; LINEINFO := LCAFTERMARKSTACK; LIST := FALSE;
   673  10    7:1    34     SYMBLK := 2; SCREENDOTS := 0; STARTDOTS := 0;
   674  10    7:1    43     FOR SEG := 0 TO MAXSEG DO
   675  10    7:2    54       WITH SEGTABLE[SEG] DO
   676  10    7:3    62 	BEGIN DISKADDR := 0; CODELENG := 0; SEGNAME := '        ';
   677  10    7:4    86 	  SEGKIND := 0; TEXTADDR := 0
   678  10    7:3    94 	END;
   679  10    7:1   103     USINGLIST := NIL;
   680  10    7:1   106     IF USERINFO.STUPID THEN SYSTEMLIB := '*SYSTEM.PASCAL'
   681  10    7:1   114     ELSE SYSTEMLIB := '*SYSTEM.LIBRARY';
   682  10    7:1   158     LC := LCAFTERMARKSTACK; IOCHECK := TRUE; DP := TRUE;
   683  10    7:1   167     SEGINX := 0; NEXTJTAB := 1; NEXTPROC := 2; CURPROC := 1;
   684  10    7:1   180     NEW(SCONST); NEW(SYMBUFP); NEW(CODEP);
   685  10    7:1   201     CLINKERINFO := FALSE; DLINKERINFO := FALSE;
   686  10    7:1   207     SEG := 1; NEXTSEG := 10; CURBLK := 1; CURBYTE := 0; LSEPPROC := FALSE;
   687  10    7:1   224     STARTINGUP := TRUE; NOISY := NOT USERINFO.SLOWTERM; SEPPROC := FALSE;
   688  10    7:1   236     DEBUGGING := FALSE; BPTONLINE := FALSE; INMODULE := FALSE;
   689  10    7:1   245     GOTOOK := FALSE; RANGECHECK := TRUE; SYSCOMP := FALSE; TINY := FALSE;
   690  10    7:1   257     CODEINSEG := FALSE; PRTERR := TRUE; INCLUDING := FALSE; USING := FALSE;
   691  10    7:1   269     FOR I := SEEK TO DECOPS DO PFNUMOF[I] := 0;
   692  10    7:1   295     COMMENT := NIL; LIBNOTOPEN := TRUE;
   693  10    7:1   302     GETSTMTLEV := TRUE; BEGSTMTLEV := 0;
   694  10    7:1   308     FLIPBYTES := FALSE
   695  10    7:0   308   END (*INITSCALARS*) ;
   696  10    7:0   328 
   697  10    8:D     1   PROCEDURE INITSETS;
   698  10    8:0     0   BEGIN
   699  10    8:1     0     CONSTBEGSYS := [ADDOP,INTCONST,REALCONST,STRINGCONST,IDENT];
   700  10    8:1    15     SIMPTYPEBEGSYS := [LPARENT] + CONSTBEGSYS;
   701  10    8:1    29     TYPEBEGSYS := [ARROW,PACKEDSY,ARRAYSY,RECORDSY,SETSY,FILESY]
   702  10    8:1    31 		  + SIMPTYPEBEGSYS;
   703  10    8:1    51     TYPEDELS := [ARRAYSY,RECORDSY,SETSY,FILESY];
   704  10    8:1    67     BLOCKBEGSYS := [USESSY,LABELSY,CONSTSY,TYPESY,VARSY,
   705  10    8:1    69 		    PROCSY,FUNCSY,PROGSY,BEGINSY];
   706  10    8:1    85     SELECTSYS := [ARROW,PERIOD,LBRACK];
   707  10    8:1    99     FACBEGSYS := [INTCONST,REALCONST,LONGCONST,STRINGCONST,IDENT,
   708  10    8:1   101 		  LPARENT,LBRACK,NOTSY];
   709  10    8:1   117     STATBEGSYS := [BEGINSY,GOTOSY,IFSY,WHILESY,REPEATSY,FORSY,WITHSY,CASESY];
   710  10    8:1   131     VARS := [FORMALVARS,ACTUALVARS]
   711  10    8:0   131   END (*INITSETS*) ;
   712  10    8:0   150 
   713  10    1:0     0 BEGIN (*COMPINIT*)
   714  10    1:1     0   INITSCALARS; INITSETS;
   715  10    1:1     4   LEVEL := 0; TOP := 0;
   716  10    1:1    10   IF NOISY THEN
   717  10    1:2    14     BEGIN
   718  10    1:3    14       FOR IC := 1 TO 7 DO WRITELN(OUTPUT);
   719  10    1:3    38 {.fs# WRITELN(OUTPUT,'PASCAL Compiler [II.0.A.1]'); }
   720  10    1:3    38 {.fs} WRITELN(OUTPUT,'PASCAL Compiler [II.0.A.1.fs]');
   721  10    1:3    83       WRITE(OUTPUT,'<   0>')
   722  10    1:2    99     END;
   723  10    1:1    99   WITH DISPLAY[0] DO
   724  10    1:2   106     BEGIN FNAME := NIL; FFILE := NIL; FLABEL := NIL; OCCUR := BLCK END;
   725  10    1:1   124   SMALLESTSPACE:=MEMAVAIL;
   726  10    1:1   128   GETNEXTPAGE;
   727  10    1:1   131   INSYMBOL;
   728  10    1:1   134   ENTSTDTYPES;   ENTSTDNAMES;   ENTUNDECL;
   729  10    1:1   140   ENTSPCPROCS;   ENTSTDPROCS;
   730  10    1:1   144   IF SYSCOMP THEN
   731  10    1:2   148     BEGIN OUTERBLOCK := NIL; SEG := 0; NEXTSEG := 1;
   732  10    1:3   157       GLEV :=1; BLOCKBEGSYS := BLOCKBEGSYS + [UNITSY,SEPARATSY]
   733  10    1:2   167     END
   734  10    1:1   184   ELSE
   735  10    1:2   186     BEGIN TOP := 1; LEVEL := 1;
   736  10    1:3   192       WITH DISPLAY[1] DO
   737  10    1:4   199 	BEGIN FNAME := NIL; FFILE := NIL;
   738  10    1:5   207 	  FLABEL := NIL; OCCUR := BLCK
   739  10    1:4   215 	END;
   740  10    1:3   217       LC := LC+2; GLEV := 3; (*KEEP STACK STRAIGHT FOR NOW*)
   741  10    1:3   225       NEW(OUTERBLOCK,PROC,DECLARED,ACTUAL,FALSE);
   742  10    1:3   230       WITH OUTERBLOCK^ DO
   743  10    1:4   234 	BEGIN NEXT := NIL; LOCALLC := LC;
   744  10    1:5   244 	  NAME := 'PROGRAM '; IDTYPE := NIL; KLASS := PROC;
   745  10    1:5   268 	  PFDECKIND := DECLARED; PFLEV := 0; PFNAME := 1; PFSEG := SEG;
   746  10    1:5   288 	  PFKIND := ACTUAL; FORWDECL := FALSE; EXTURNAL := FALSE;
   747  10    1:5   303 	  INSCOPE := TRUE
   748  10    1:4   306 	END
   749  10    1:2   308     END;
   750  10    1:1   308   IF SY = PROGSY THEN
   751  10    1:2   314     BEGIN INSYMBOL;
   752  10    1:3   317       IF SY = IDENT THEN
   753  10    1:4   323 	BEGIN SEGTABLE[SEG].SEGNAME := ID;
   754  10    1:5   335 	  IF OUTERBLOCK <> NIL THEN
   755  10    1:6   341 	    BEGIN
   756  10    1:7   341 	      OUTERBLOCK^.NAME := ID;
   757  10    1:7   347 	      ENTERID(OUTERBLOCK) (*ALLOWS EXIT ON PROGRAM NAME*)
   758  10    1:6   349 	    END
   759  10    1:4   352 	END
   760  10    1:3   352       ELSE ERROR(2); INSYMBOL;
   761  10    1:3   361       IF SY = LPARENT THEN
   762  10    1:4   367 	BEGIN
   763  10    1:5   367 	  REPEAT INSYMBOL
   764  10    1:5   367 	  UNTIL SY IN [RPARENT,SEMICOLON]+BLOCKBEGSYS;
   765  10    1:5   383 	  IF SY = RPARENT THEN INSYMBOL ELSE ERROR(4)
   766  10    1:4   395 	END;
   767  10    1:3   398       IF SY = SEMICOLON THEN INSYMBOL ELSE ERROR(14)
   768  10    1:2   410     END;
   769  10    1:1   413   MARK(MARKP);
   770  10    1:1   417   NEW(TOS);
   771  10    1:1   422   WITH TOS^ DO  (*MAKE LEXSTKREC FOR OUTERBLOCK*)
   772  10    1:2   426     BEGIN
   773  10    1:3   426       PREVLEXSTACKP:=NIL;
   774  10    1:3   431       BFSY:=PERIOD;
   775  10    1:3   436       DFPROCP:=OUTERBLOCK;
   776  10    1:3   442       DLLC:=LC;
   777  10    1:3   447       DOLDLEV:=LEVEL;
   778  10    1:3   453       DOLDTOP:=TOP;
   779  10    1:3   456       POLDPROC:=CURPROC;
   780  10    1:3   462       ISSEGMENT:=FALSE;
   781  10    1:3   467       DMARKP:=MARKP;
   782  10    1:2   473     END;
   783  10    1:0   473 END (*COMPINIT*) ;
   784  10    1:0   490 
   785  10    1:0   490 (* --- DECPART.A.TEXT --- *)
   786  10    1:0   490 
   787  10    1:0   490 (*    COPYRIGHT (C) 1979, REGENTS OF THE	*)
   788  10    1:0   490 (*    UNIVERSITY OF CALIFORNIA, SAN DIEGO	*)
   789  10    1:0   490 
   790  11    1:D     1 SEGMENT PROCEDURE DECLARATIONPART(FSYS: SETOFSYS);
   791  11    1:D     5 VAR LSY: SYMBOL;
   792  11    1:D     6     NOTDONE: BOOLEAN;
   793  11    1:D     7     DUMMYVAR: ARRAY[0..0] OF INTEGER; (*FOR PRETTY DISPLAY OF STACK AND HEAP *)
   794  11    1:D     8 
   795  11    2:D     1   PROCEDURE TYP(FSYS: SETOFSYS; VAR FSP: STP; VAR FSIZE: ADDRRANGE);
   796  11    2:D     7     VAR LSP,LSP1,LSP2: STP; OLDTOP: DISPRANGE; LCP: CTP;
   797  11    2:D    12 	LSIZE,DISPL: ADDRRANGE; LMIN,LMAX: INTEGER;
   798  11    2:D    16 	PACKING: BOOLEAN; NEXTBIT,NUMBITS: BITRANGE;
   799  11    2:D    19 
   800  11    3:D     1     PROCEDURE SIMPLETYPE(FSYS:SETOFSYS; VAR FSP:STP; VAR FSIZE:ADDRRANGE);
   801  11    3:D     7       VAR LSP,LSP1: STP; LCP,LCP1: CTP; TTOP: DISPRANGE;
   802  11    3:D    12 	  LCNT: INTEGER; LVALU: VALU;
   803  11    3:0     0     BEGIN FSIZE := 1;
   804  11    3:1     3       IF NOT (SY IN SIMPTYPEBEGSYS) THEN
   805  11    3:2    14 	BEGIN ERROR(1); SKIP(FSYS + SIMPTYPEBEGSYS) END;
   806  11    3:1    34       IF SY IN SIMPTYPEBEGSYS THEN
   807  11    3:2    44 	BEGIN
   808  11    3:3    44 	  IF SY = LPARENT THEN
   809  11    3:4    50 	    BEGIN TTOP := TOP;
   810  11    3:5    53 	      WHILE DISPLAY[TOP].OCCUR <> BLCK DO TOP := TOP - 1;
   811  11    3:5    70 	      NEW(LSP,SCALAR,DECLARED);
   812  11    3:5    75 	      WITH LSP^ DO
   813  11    3:6    78 		BEGIN SIZE := INTSIZE; FORM := SCALAR;
   814  11    3:7    86 		  SCALKIND := DECLARED
   815  11    3:6    89 		END;
   816  11    3:5    91 	      LCP1 := NIL; LCNT := 0;
   817  11    3:5    97 	      REPEAT INSYMBOL;
   818  11    3:6   100 		IF SY = IDENT THEN
   819  11    3:7   106 		  BEGIN NEW(LCP,KONST);
   820  11    3:8   111 		    WITH LCP^ DO
   821  11    3:9   114 		      BEGIN NAME := ID; IDTYPE := LSP; NEXT := LCP1;
   822  11    3:0   129 			VALUES.IVAL := LCNT; KLASS := KONST
   823  11    3:9   137 		      END;
   824  11    3:8   139 		    ENTERID(LCP);
   825  11    3:8   143 		    LCNT := LCNT + 1;
   826  11    3:8   148 		    LCP1 := LCP; INSYMBOL
   827  11    3:7   151 		  END
   828  11    3:6   154 		ELSE ERROR(2);
   829  11    3:6   160 		IF NOT (SY IN FSYS + [COMMA,RPARENT]) THEN
   830  11    3:7   174 		  BEGIN ERROR(6); SKIP(FSYS + [COMMA,RPARENT]) END
   831  11    3:5   191 	      UNTIL SY <> COMMA;
   832  11    3:5   197 	      LSP^.FCONST := LCP1; TOP := TTOP;
   833  11    3:5   205 	      IF SY = RPARENT THEN INSYMBOL ELSE ERROR(4)
   834  11    3:4   217 	    END
   835  11    3:3   220 	  ELSE
   836  11    3:4   222 	    BEGIN
   837  11    3:5   222 	      IF SY = IDENT THEN
   838  11    3:6   228 		BEGIN SEARCHID([TYPES,KONST],LCP);
   839  11    3:7   237 		  INSYMBOL;
   840  11    3:7   240 		  IF LCP^.KLASS = KONST THEN
   841  11    3:8   247 		    BEGIN NEW(LSP,SUBRANGE);
   842  11    3:9   252 		      WITH LSP^, LCP^ DO
   843  11    3:0   258 			BEGIN RANGETYPE := IDTYPE; FORM := SUBRANGE;
   844  11    3:1   269 			  IF STRGTYPE(RANGETYPE) THEN
   845  11    3:2   278 			    BEGIN ERROR(148); RANGETYPE := NIL END;
   846  11    3:1   289 			  MIN := VALUES; SIZE := INTSIZE
   847  11    3:0   298 			END;
   848  11    3:9   300 		      IF SY = COLON THEN INSYMBOL ELSE ERROR(5);
   849  11    3:9   315 		      CONSTANT(FSYS,LSP1,LVALU);
   850  11    3:9   329 		      LSP^.MAX := LVALU;
   851  11    3:9   336 		      IF LSP^.RANGETYPE <> LSP1 THEN ERROR(107)
   852  11    3:8   343 		    END
   853  11    3:7   346 		  ELSE
   854  11    3:8   348 		    BEGIN LSP := LCP^.IDTYPE;
   855  11    3:9   352 		      IF (LSP = STRGPTR) AND (SY = LBRACK) THEN
   856  11    3:0   363 			BEGIN INSYMBOL;
   857  11    3:1   366 			  CONSTANT(FSYS + [RBRACK],LSP1,LVALU);
   858  11    3:1   389 			  IF LSP1 = INTPTR THEN
   859  11    3:2   394 			    BEGIN
   860  11    3:3   394 			      IF (LVALU.IVAL <= 0) OR
   861  11    3:3   397 				 (LVALU.IVAL > STRGLGTH) THEN
   862  11    3:4   405 				BEGIN ERROR(203);
   863  11    3:5   411 				  LVALU.IVAL := DEFSTRGLGTH
   864  11    3:4   411 				END;
   865  11    3:3   414 			      IF LVALU.IVAL <> DEFSTRGLGTH THEN
   866  11    3:4   419 				BEGIN NEW(LSP,ARRAYS,TRUE,TRUE);
   867  11    3:5   424 				  LSP^ := STRGPTR^;
   868  11    3:5   429 				  WITH LSP^,LVALU DO
   869  11    3:6   432 				    BEGIN MAXLENG := IVAL;
   870  11    3:7   437 				      SIZE := (IVAL+CHRSPERWD) DIV CHRSPERWD
   871  11    3:6   441 				    END
   872  11    3:4   444 				END
   873  11    3:2   444 			    END
   874  11    3:1   444 			  ELSE ERROR(15);
   875  11    3:1   450 			  IF SY = RBRACK THEN INSYMBOL ELSE ERROR(12)
   876  11    3:0   462 			END
   877  11    3:9   465 		      ELSE
   878  11    3:0   467 			IF LSP = INTPTR THEN
   879  11    3:1   472 			  IF SY = LBRACK THEN
   880  11    3:2   478 			    BEGIN INSYMBOL;
   881  11    3:3   481 			      NEW(LSP,LONGINT);
   882  11    3:3   486 			      LSP^ := LONGINTPTR^;
   883  11    3:3   491 			      CONSTANT(FSYS + [RBRACK],LSP1,LVALU);
   884  11    3:3   513 			      IF LSP1 = INTPTR THEN
   885  11    3:4   518 				IF (LVALU.IVAL <= 0) OR
   886  11    3:4   521 				   (LVALU.IVAL > MAXDEC) THEN ERROR(203)
   887  11    3:4   530 				ELSE
   888  11    3:5   535 				  LSP^.SIZE := DECSIZE(LVALU.IVAL) 
   889  11    3:3   537 			      ELSE ERROR(15);
   890  11    3:3   549 			      IF SY = RBRACK THEN INSYMBOL ELSE ERROR(12);
   891  11    3:2   564 			    END
   892  11    3:1   564 			  ELSE
   893  11    3:2   566 			    IF LSP^.FORM = FILES THEN
   894  11    3:3   572 			      IF INMODULE THEN
   895  11    3:4   576 				IF NOT ININTERFACE THEN
   896  11    3:5   581 				  ERROR(191); (*NO PRIVATE FILES*)
   897  11    3:9   587 		      IF LSP <> NIL THEN FSIZE := LSP^.SIZE
   898  11    3:8   594 		    END
   899  11    3:6   596 		END (*SY = IDENT*)
   900  11    3:5   596 	      ELSE
   901  11    3:6   598 		BEGIN NEW(LSP,SUBRANGE); LSP^.FORM := SUBRANGE;
   902  11    3:7   608 		  CONSTANT(FSYS + [COLON],LSP1,LVALU);
   903  11    3:7   625 		  IF STRGTYPE(LSP1) THEN
   904  11    3:8   633 		    BEGIN ERROR(148); LSP1 := NIL END;
   905  11    3:7   642 		  WITH LSP^ DO
   906  11    3:8   645 		    BEGIN RANGETYPE:=LSP1; MIN:=LVALU; SIZE:=INTSIZE END;
   907  11    3:7   660 		  IF SY = COLON THEN INSYMBOL ELSE ERROR(5);
   908  11    3:7   675 		  CONSTANT(FSYS,LSP1,LVALU);
   909  11    3:7   689 		  LSP^.MAX := LVALU;
   910  11    3:7   696 		  IF LSP^.RANGETYPE <> LSP1 THEN ERROR(107)
   911  11    3:6   703 		END;
   912  11    3:5   706 	      IF LSP <> NIL THEN
   913  11    3:6   711 		WITH LSP^ DO
   914  11    3:7   714 		  IF FORM = SUBRANGE THEN
   915  11    3:8   720 		    IF RANGETYPE <> NIL THEN
   916  11    3:9   726 		      IF RANGETYPE = REALPTR THEN ERROR(399)
   917  11    3:9   736 		      ELSE
   918  11    3:0   741 			IF MIN.IVAL > MAX.IVAL THEN
   919  11    3:1   748 			  BEGIN ERROR(102); MAX.IVAL := MIN.IVAL END
   920  11    3:4   758 	    END;
   921  11    3:3   758 	  FSP := LSP;
   922  11    3:3   761 	  IF NOT (SY IN FSYS) THEN
   923  11    3:4   772 	    BEGIN ERROR(6); SKIP(FSYS) END
   924  11    3:2   786 	END
   925  11    3:1   786 	  ELSE FSP := NIL
   926  11    3:0   789     END (*SIMPLETYPE*) ;
   927  11    3:0   818 
   928  11    4:D     3     FUNCTION PACKABLE(FSP: STP): BOOLEAN;
   929  11    4:D     4       VAR LMIN,LMAX: INTEGER;
   930  11    4:0     0     BEGIN PACKABLE := FALSE;
   931  11    4:1     3       IF (FSP <> NIL) AND PACKING THEN
   932  11    4:2    12 	WITH FSP^ DO
   933  11    4:3    15 	  CASE FORM OF
   934  11    4:3    19 	    SUBRANGE,
   935  11    4:3    19 	    SCALAR:  IF (FSP <> INTPTR) AND (FSP <> REALPTR) THEN
   936  11    4:5    29 		       BEGIN GETBOUNDS(FSP,LMIN,LMAX);
   937  11    4:6    37 			 IF LMIN >= 0 THEN
   938  11    4:7    42 			   BEGIN PACKABLE := TRUE;
   939  11    4:8    45 			     NUMBITS := 1; LMIN := 1;
   940  11    4:8    52 			     WHILE LMIN < LMAX DO
   941  11    4:9    57 			       BEGIN LMIN := LMIN + 1;
   942  11    4:0    62 				 LMIN := LMIN + LMIN - 1;
   943  11    4:0    69 				 NUMBITS := NUMBITS + 1
   944  11    4:9    72 			       END
   945  11    4:7    77 			   END
   946  11    4:5    79 		       END;
   947  11    4:3    81 	    POWER:   IF PACKABLE(ELSET) THEN
   948  11    4:5    89 		       BEGIN GETBOUNDS(ELSET,LMIN,LMAX);
   949  11    4:6    98 			 LMAX := LMAX + 1;
   950  11    4:6   103 			 IF LMAX < BITSPERWD THEN
   951  11    4:7   108 			   BEGIN PACKABLE := TRUE;
   952  11    4:8   111 			     NUMBITS := LMAX
   953  11    4:7   111 			   END
   954  11    4:5   115 		       END
   955  11    4:3   115 	  END (* CASES *);
   956  11    4:0   134     END (*PACKABLE*) ;
   957  11    4:0   148 
   958  11    5:D     1     PROCEDURE FIELDLIST(FSYS: SETOFSYS; VAR FRECVAR: STP);
   959  11    5:D     6       VAR LCP,LCP1,NXT,NXT1,LAST: CTP; LSP,LSP1,LSP2,LSP3,LSP4: STP;
   960  11    5:D    16 	  MINSIZE,MAXSIZE,LSIZE: ADDRRANGE; LVALU: VALU;
   961  11    5:D    20 	  MAXBIT,MINBIT: BITRANGE;
   962  11    5:D    22 
   963  11    6:D     1       PROCEDURE ALLOCATE(FCP: CTP);
   964  11    6:D     2 	VAR ONBOUND: BOOLEAN;
   965  11    6:0     0       BEGIN ONBOUND := FALSE;
   966  11    6:1     3 	WITH FCP^ DO
   967  11    6:2     6 	  IF PACKABLE(IDTYPE) THEN
   968  11    6:3    14 	    BEGIN
   969  11    6:4    14 	      IF (NUMBITS + NEXTBIT) > BITSPERWD THEN
   970  11    6:5    25 		BEGIN DISPL := DISPL + 1; NEXTBIT := 0; ONBOUND := TRUE END;
   971  11    6:4    40 	      FLDADDR := DISPL; FISPACKD := TRUE;
   972  11    6:4    52 	      FLDWIDTH := NUMBITS; FLDRBIT := NEXTBIT;
   973  11    6:4    66 	      NEXTBIT := NEXTBIT + NUMBITS
   974  11    6:3    69 	    END
   975  11    6:2    76 	  ELSE
   976  11    6:3    78 	    BEGIN DISPL := DISPL + ORD(NEXTBIT > 0);
   977  11    6:4    90 	      NEXTBIT := 0; ONBOUND := TRUE;
   978  11    6:4    97 	      FISPACKD := FALSE; FLDADDR := DISPL;
   979  11    6:4   109 	      IF IDTYPE <> NIL THEN
   980  11    6:5   115 		DISPL := DISPL + IDTYPE^.SIZE
   981  11    6:3   120 	    END;
   982  11    6:1   125 	IF ONBOUND AND (LAST <> NIL) THEN
   983  11    6:2   134 	  WITH LAST^ DO
   984  11    6:3   139 	    IF FISPACKD THEN
   985  11    6:4   144 	      IF FLDRBIT = 0 THEN FISPACKD := FALSE
   986  11    6:4   154 	      ELSE
   987  11    6:5   158 		IF (FLDWIDTH <= 8) AND (FLDRBIT <= 8) THEN
   988  11    6:6   171 		  BEGIN FLDWIDTH := 8; FLDRBIT := 8 END
   989  11    6:0   181       END (*ALLOCATE*) ;
   990  11    6:0   194 
   991  11    7:D     1       PROCEDURE VARIANTLIST;
   992  11    7:D     1 	VAR GOTTAGNAME: BOOLEAN;
   993  11    7:0     0       BEGIN NEW(LSP,TAGFLD);
   994  11    7:1     6 	WITH LSP^ DO
   995  11    7:2    11 	  BEGIN TAGFIELDP := NIL; FSTVAR := NIL; FORM := TAGFLD END;
   996  11    7:1    26 	FRECVAR := LSP;
   997  11    7:1    33 	INSYMBOL;
   998  11    7:1    36 	IF SY = IDENT THEN
   999  11    7:2    42 	  BEGIN
  1000  11    7:3    42 	    IF PACKING THEN NEW(LCP,FIELD,TRUE)
  1001  11    7:3    53 	    ELSE NEW(LCP,FIELD,FALSE);
  1002  11    7:3    61 	    WITH LCP^ DO
  1003  11    7:4    66 	      BEGIN IDTYPE := NIL; KLASS:=FIELD;
  1004  11    7:5    76 		NEXT := NIL; FISPACKD := FALSE
  1005  11    7:4    84 	      END;
  1006  11    7:3    86 	    GOTTAGNAME := FALSE; PRTERR := FALSE;
  1007  11    7:3    92 	    SEARCHID([TYPES],LCP1); PRTERR := TRUE;
  1008  11    7:3   105 	    IF LCP1 = NIL THEN
  1009  11    7:4   112 	      BEGIN GOTTAGNAME := TRUE;
  1010  11    7:5   115 		LCP^.NAME := ID; ENTERID(LCP); INSYMBOL;
  1011  11    7:5   131 		IF SY = COLON THEN INSYMBOL ELSE ERROR(5)
  1012  11    7:4   143 	      END;
  1013  11    7:3   146 	    IF SY = IDENT THEN
  1014  11    7:4   152 	      BEGIN SEARCHID([TYPES],LCP1);
  1015  11    7:5   162 		LSP1 := LCP1^.IDTYPE;
  1016  11    7:5   169 		IF LSP1 <> NIL THEN
  1017  11    7:6   176 		  BEGIN
  1018  11    7:7   176 		    IF LSP1^.FORM <= SUBRANGE THEN
  1019  11    7:8   184 		      BEGIN
  1020  11    7:9   184 			IF COMPTYPES(REALPTR,LSP1) THEN ERROR(109);
  1021  11    7:9   200 			LCP^.IDTYPE := LSP1; LSP^.TAGFIELDP := LCP;
  1022  11    7:9   218 			IF GOTTAGNAME THEN ALLOCATE(LCP)
  1023  11    7:8   224 		      END
  1024  11    7:7   226 		    ELSE ERROR(110)
  1025  11    7:6   229 		  END;
  1026  11    7:5   232 		INSYMBOL
  1027  11    7:4   232 	      END
  1028  11    7:3   235 	    ELSE BEGIN ERROR(2); SKIP(FSYS + [OFSY,LPARENT]) END
  1029  11    7:2   257 	  END
  1030  11    7:1   257 	ELSE BEGIN ERROR(2); SKIP(FSYS + [OFSY,LPARENT]) END;
  1031  11    7:1   279 	LSP^.SIZE := DISPL + ORD(NEXTBIT > 0);
  1032  11    7:1   292 	IF SY = OFSY THEN INSYMBOL ELSE ERROR(8);
  1033  11    7:1   307 	LSP1 := NIL; MINSIZE := DISPL; MAXSIZE := DISPL;
  1034  11    7:1   323 	MINBIT := NEXTBIT; MAXBIT := NEXTBIT;
  1035  11    7:1   335 	REPEAT LSP2 := NIL;
  1036  11    7:2   339 	  REPEAT CONSTANT(FSYS + [COMMA,COLON,LPARENT],LSP3,LVALU);
  1037  11    7:3   359 	    IF LSP^.TAGFIELDP <> NIL THEN
  1038  11    7:4   367 	      IF NOT COMPTYPES(LSP^.TAGFIELDP^.IDTYPE,LSP3) THEN
  1039  11    7:5   383 		ERROR(111);
  1040  11    7:3   387 	    NEW(LSP3,VARIANT);
  1041  11    7:3   393 	    WITH LSP3^ DO
  1042  11    7:4   398 	      BEGIN NXTVAR := LSP1; SUBVAR := LSP2;
  1043  11    7:5   412 		VARVAL := LVALU; FORM := VARIANT
  1044  11    7:4   423 	      END;
  1045  11    7:3   425 	    LSP1 := LSP3; LSP2 := LSP3;
  1046  11    7:3   437 	    TEST := SY <> COMMA;
  1047  11    7:3   443 	    IF NOT TEST THEN INSYMBOL
  1048  11    7:2   447 	  UNTIL TEST;
  1049  11    7:2   453 	  IF SY = COLON THEN INSYMBOL ELSE ERROR(5);
  1050  11    7:2   468 	  IF SY = LPARENT THEN INSYMBOL ELSE ERROR(9);
  1051  11    7:2   483 	  IF SY = RPARENT THEN LSP2 := NIL
  1052  11    7:2   489 	  ELSE
  1053  11    7:3   495 	    FIELDLIST(FSYS + [RPARENT,SEMICOLON],LSP2);
  1054  11    7:2   511 	  IF DISPL > MAXSIZE THEN
  1055  11    7:3   520 	    BEGIN MAXSIZE := DISPL; MAXBIT := NEXTBIT END
  1056  11    7:2   532 	  ELSE
  1057  11    7:3   534 	    IF (DISPL = MAXSIZE) AND (NEXTBIT > MAXBIT) THEN
  1058  11    7:4   551 	      MAXBIT := NEXTBIT;
  1059  11    7:2   557 	  WHILE LSP3 <> NIL DO
  1060  11    7:3   564 	    BEGIN LSP4 := LSP3^.SUBVAR; LSP3^.SUBVAR := LSP2;
  1061  11    7:4   580 	      LSP3^.SIZE := DISPL + ORD(NEXTBIT > 0);
  1062  11    7:4   593 	      LSP3 := LSP4
  1063  11    7:3   593 	    END;
  1064  11    7:2   601 	  IF SY = RPARENT THEN
  1065  11    7:3   607 	    BEGIN INSYMBOL;
  1066  11    7:4   610 	      IF NOT (SY IN FSYS + [SEMICOLON]) THEN
  1067  11    7:5   625 		BEGIN ERROR(6); SKIP(FSYS + [SEMICOLON]) END
  1068  11    7:3   643 	    END
  1069  11    7:2   643 	  ELSE ERROR(4);
  1070  11    7:2   649 	  TEST := SY <> SEMICOLON;
  1071  11    7:2   655 	  IF NOT TEST THEN
  1072  11    7:3   659 	    BEGIN INSYMBOL;
  1073  11    7:4   662 	      DISPL := MINSIZE; NEXTBIT := MINBIT
  1074  11    7:3   668 	    END
  1075  11    7:1   674 	UNTIL (TEST) OR (SY = ENDSY); (* <<<< SMF 2-28-78 *)
  1076  11    7:1   682 	DISPL := MAXSIZE; NEXTBIT := MAXBIT;
  1077  11    7:1   694 	LSP^.FSTVAR := LSP1
  1078  11    7:0   699       END (*VARIANTLIST*) ;
  1079  11    7:0   724 
  1080  11    5:0     0     BEGIN (*FIELDLIST*)
  1081  11    5:1     0       NXT1 := NIL; LSP := NIL; LAST := NIL;
  1082  11    5:1     9       IF NOT (SY IN [IDENT,CASESY]) THEN
  1083  11    5:2    23 	BEGIN ERROR(19); SKIP(FSYS + [IDENT,CASESY]) END;
  1084  11    5:1    45       WHILE SY = IDENT DO
  1085  11    5:2    51 	BEGIN NXT := NXT1;
  1086  11    5:3    54 	  REPEAT
  1087  11    5:4    54 	    IF SY = IDENT THEN
  1088  11    5:5    60 	      BEGIN
  1089  11    5:6    60 		IF PACKING THEN NEW(LCP,FIELD,TRUE)
  1090  11    5:6    70 		ELSE NEW(LCP,FIELD,FALSE);
  1091  11    5:6    77 		WITH LCP^ DO
  1092  11    5:7    80 		  BEGIN NAME := ID; IDTYPE := NIL; NEXT := NXT;
  1093  11    5:8    98 		    KLASS := FIELD; FISPACKD := FALSE
  1094  11    5:7   108 		  END;
  1095  11    5:6   110 		NXT := LCP;
  1096  11    5:6   113 		ENTERID(LCP);
  1097  11    5:6   117 		INSYMBOL
  1098  11    5:5   117 	      END
  1099  11    5:4   120 	    ELSE ERROR(2);
  1100  11    5:4   126 	    IF NOT (SY IN [COMMA,COLON]) THEN
  1101  11    5:5   134 	      BEGIN ERROR(6); SKIP(FSYS + [COMMA,COLON,SEMICOLON,CASESY]) END;
  1102  11    5:4   157 	    TEST := SY <> COMMA;
  1103  11    5:4   163 	    IF NOT TEST  THEN INSYMBOL
  1104  11    5:3   167 	  UNTIL TEST;
  1105  11    5:3   173 	  IF SY = COLON THEN INSYMBOL ELSE ERROR(5);
  1106  11    5:3   188 	  TYP(FSYS + [CASESY,SEMICOLON],LSP,LSIZE);
  1107  11    5:3   210 	  IF LSP <> NIL THEN
  1108  11    5:4   215 	    IF LSP^.FORM = FILES THEN ERROR(108);
  1109  11    5:3   225 	  WHILE NXT <> NXT1 DO
  1110  11    5:4   230 	    WITH NXT^ DO
  1111  11    5:5   233 	      BEGIN IDTYPE := LSP; ALLOCATE(NXT);
  1112  11    5:6   242 		IF NEXT = NXT1 THEN LAST := NXT;
  1113  11    5:6   252 		NXT := NEXT
  1114  11    5:5   252 	      END;
  1115  11    5:3   259 	  NXT1 := LCP;
  1116  11    5:3   262 	  IF SY = SEMICOLON THEN
  1117  11    5:4   268 	    BEGIN INSYMBOL;
  1118  11    5:5   271 	      IF NOT (SY IN [IDENT,ENDSY,CASESY]) THEN (* <<<< SMF 2-28-78 *)
  1119  11    5:6   285 		BEGIN ERROR(19); SKIP(FSYS + [IDENT,CASESY]) END
  1120  11    5:4   307 	    END
  1121  11    5:2   307 	END (*WHILE*);
  1122  11    5:1   309       NXT := NIL;
  1123  11    5:1   312       WHILE NXT1 <> NIL DO
  1124  11    5:2   317 	WITH NXT1^ DO
  1125  11    5:3   320 	  BEGIN LCP := NEXT; NEXT := NXT; NXT := NXT1; NXT1 := LCP END;
  1126  11    5:1   339       IF SY = CASESY THEN VARIANTLIST
  1127  11    5:1   345       ELSE FRECVAR := NIL
  1128  11    5:0   350     END (*FIELDLIST*) ;
  1129  11    5:0   374 
  1130  11    8:D     1     PROCEDURE POINTERTYPE;
  1131  11    8:0     0     BEGIN NEW(LSP,POINTER); FSP := LSP;
  1132  11    8:1    13       WITH LSP^ DO
  1133  11    8:2    18 	BEGIN ELTYPE := NIL; SIZE := PTRSIZE; FORM := POINTER END;
  1134  11    8:1    31       INSYMBOL;
  1135  11    8:1    34       IF SY = IDENT THEN
  1136  11    8:2    40 	BEGIN PRTERR := FALSE;
  1137  11    8:3    43 	  SEARCHID([TYPES],LCP); PRTERR := TRUE;
  1138  11    8:3    56 	  IF LCP = NIL THEN   (*FORWARD REFERENCED TYPE ID*)
  1139  11    8:4    63 	    BEGIN NEW(LCP,TYPES);
  1140  11    8:5    69 	      WITH LCP^ DO
  1141  11    8:6    74 		BEGIN NAME := ID; IDTYPE := LSP;
  1142  11    8:7    86 		  NEXT := FWPTR; KLASS := TYPES
  1143  11    8:6    95 		END;
  1144  11    8:5    97 	      FWPTR := LCP
  1145  11    8:4    97 	    END
  1146  11    8:3   102 	  ELSE
  1147  11    8:4   104 	    BEGIN
  1148  11    8:5   104 	      IF LCP^.IDTYPE <> NIL THEN
  1149  11    8:6   112 		IF (LCP^.IDTYPE^.FORM <> FILES) OR SYSCOMP THEN
  1150  11    8:7   124 		  LSP^.ELTYPE := LCP^.IDTYPE
  1151  11    8:6   132 		ELSE ERROR(108)
  1152  11    8:4   137 	    END;
  1153  11    8:3   140 	  INSYMBOL;
  1154  11    8:2   143 	END
  1155  11    8:1   143       ELSE ERROR(2)
  1156  11    8:0   146     END (*POINTERTYPE*) ;
  1157  11    8:0   162 
  1158  11    2:0     0   BEGIN (*TYP*)
  1159  11    2:1     0     PACKING := FALSE;
  1160  11    2:1     3     IF NOT (SY IN TYPEBEGSYS) THEN
  1161  11    2:2    14        BEGIN ERROR(10); SKIP(FSYS + TYPEBEGSYS) END;
  1162  11    2:1    34     IF SY IN TYPEBEGSYS THEN
  1163  11    2:2    44       BEGIN
  1164  11    2:3    44 	IF SY IN SIMPTYPEBEGSYS THEN SIMPLETYPE(FSYS,FSP,FSIZE)
  1165  11    2:3    63 	ELSE
  1166  11    2:4    67   (*^*)   IF SY = ARROW THEN POINTERTYPE
  1167  11    2:4    73 	  ELSE
  1168  11    2:5    77 	    BEGIN
  1169  11    2:6    77 	      IF SY = PACKEDSY THEN
  1170  11    2:7    83 		BEGIN INSYMBOL; PACKING := TRUE;
  1171  11    2:8    89 		  IF NOT (SY IN TYPEDELS) THEN
  1172  11    2:9   100 		    BEGIN ERROR(10); SKIP(FSYS + TYPEDELS) END
  1173  11    2:7   120 		END;
  1174  11    2:6   120   (*ARRAY*)   IF SY = ARRAYSY THEN
  1175  11    2:7   126 		BEGIN INSYMBOL;
  1176  11    2:8   129 		  IF SY = LBRACK THEN INSYMBOL ELSE ERROR(11);
  1177  11    2:8   144 		  LSP1 := NIL;
  1178  11    2:8   147 		  REPEAT
  1179  11    2:9   147 		    IF PACKING THEN NEW(LSP,ARRAYS,TRUE,FALSE)
  1180  11    2:9   155 		    ELSE NEW(LSP,ARRAYS,FALSE);
  1181  11    2:9   162 		    WITH LSP^ DO
  1182  11    2:0   165 		      BEGIN AELTYPE := LSP1; INXTYPE := NIL;
  1183  11    2:1   177 			IF PACKING THEN AISSTRNG := FALSE;
  1184  11    2:1   186 			AISPACKD := FALSE;  FORM := ARRAYS
  1185  11    2:0   196 		      END;
  1186  11    2:9   198 		    LSP1 := LSP;
  1187  11    2:9   201 		    SIMPLETYPE(FSYS + [COMMA,RBRACK,OFSY],LSP2,LSIZE);
  1188  11    2:9   222 		    LSP1^.SIZE := LSIZE;
  1189  11    2:9   225 		    IF LSP2 <> NIL THEN
  1190  11    2:0   230 		      IF LSP2^.FORM <= SUBRANGE THEN
  1191  11    2:1   236 			BEGIN
  1192  11    2:2   236 			  IF LSP2 = REALPTR THEN
  1193  11    2:3   242 			    BEGIN ERROR(109); LSP2 := NIL END
  1194  11    2:2   249 			  ELSE
  1195  11    2:3   251 			    IF LSP2 = INTPTR THEN
  1196  11    2:4   256 			      BEGIN ERROR(149); LSP2 := NIL END;
  1197  11    2:2   265 			  LSP^.INXTYPE := LSP2
  1198  11    2:1   268 			END
  1199  11    2:0   270 		      ELSE BEGIN ERROR(113); LSP2 := NIL END;
  1200  11    2:9   279 		    TEST := SY <> COMMA;
  1201  11    2:9   285 		    IF NOT TEST THEN INSYMBOL
  1202  11    2:8   289 		  UNTIL TEST;
  1203  11    2:8   295 		  IF SY = RBRACK THEN INSYMBOL ELSE ERROR(12);
  1204  11    2:8   310 		  IF SY = OFSY THEN INSYMBOL ELSE ERROR(8);
  1205  11    2:8   325 		  TYP(FSYS,LSP,LSIZE);
  1206  11    2:8   338 		  IF LSP <> NIL THEN
  1207  11    2:9   343 		    IF LSP^.FORM = FILES THEN ERROR(108);
  1208  11    2:8   353 		  IF PACKABLE(LSP) THEN
  1209  11    2:9   360 		    IF NUMBITS + NUMBITS <= BITSPERWD THEN
  1210  11    2:0   369 		      WITH LSP1^ DO
  1211  11    2:1   372 			BEGIN AISPACKD := TRUE;
  1212  11    2:2   378 			  ELSPERWD := BITSPERWD DIV NUMBITS;
  1213  11    2:2   387 			  ELWIDTH := NUMBITS
  1214  11    2:1   391 			END;
  1215  11    2:8   394 		  REPEAT
  1216  11    2:9   394 		    WITH LSP1^ DO
  1217  11    2:0   397 		      BEGIN LSP2 := AELTYPE; AELTYPE := LSP;
  1218  11    2:1   408 			IF INXTYPE <> NIL THEN
  1219  11    2:2   415 			  BEGIN GETBOUNDS(INXTYPE,LMIN,LMAX);
  1220  11    2:3   425 			    IF AISPACKD THEN
  1221  11    2:4   430 			      LSIZE := (LMAX-LMIN+ELSPERWD)
  1222  11    2:4   437 						 DIV ELSPERWD
  1223  11    2:3   437 			    ELSE
  1224  11    2:4   445 			      LSIZE := LSIZE*(LMAX - LMIN + 1);
  1225  11    2:3   454 			    IF LSIZE <= 0 THEN
  1226  11    2:4   459 			      BEGIN ERROR(398); LSIZE := 1 END;
  1227  11    2:3   468 			    SIZE := LSIZE
  1228  11    2:2   470 			  END
  1229  11    2:0   472 		      END;
  1230  11    2:9   472 		    LSP := LSP1; LSP1 := LSP2
  1231  11    2:8   475 		  UNTIL LSP1 = NIL
  1232  11    2:7   479 		END
  1233  11    2:6   483 	      ELSE
  1234  11    2:7   485   (*RECORD*)    IF SY = RECORDSY THEN
  1235  11    2:8   491 		  BEGIN INSYMBOL;
  1236  11    2:9   494 		    OLDTOP := TOP;
  1237  11    2:9   497 		    IF TOP < DISPLIMIT THEN
  1238  11    2:0   502 		      BEGIN TOP := TOP + 1;
  1239  11    2:1   507 			WITH DISPLAY[TOP] DO
  1240  11    2:2   514 			  BEGIN FNAME := NIL; OCCUR := REC END
  1241  11    2:0   524 		      END
  1242  11    2:9   524 		    ELSE ERROR(250);
  1243  11    2:9   532 		    DISPL := 0; NEXTBIT := 0;
  1244  11    2:9   538 		    FIELDLIST(FSYS-[SEMICOLON]+[ENDSY],LSP1);
  1245  11    2:9   557 		    DISPL := DISPL + ORD(NEXTBIT > 0);
  1246  11    2:9   565 		    NEW(LSP,RECORDS);
  1247  11    2:9   570 		    WITH LSP^ DO
  1248  11    2:0   573 		      BEGIN FSTFLD := DISPLAY[TOP].FNAME;
  1249  11    2:1   584 			RECVAR := LSP1; SIZE := DISPL;
  1250  11    2:1   594 			FORM := RECORDS
  1251  11    2:0   598 		      END;
  1252  11    2:9   600 		    TOP := OLDTOP;
  1253  11    2:9   603 		    IF SY = ENDSY THEN INSYMBOL ELSE ERROR(13)
  1254  11    2:8   615 		  END
  1255  11    2:7   618 		ELSE
  1256  11    2:8   620   (*SET*)         IF SY = SETSY THEN
  1257  11    2:9   626 		    BEGIN INSYMBOL;
  1258  11    2:0   629 		      IF SY = OFSY THEN INSYMBOL ELSE ERROR(8);
  1259  11    2:0   644 		      SIMPLETYPE(FSYS,LSP1,LSIZE);
  1260  11    2:0   657 		      IF LSP1 <> NIL THEN
  1261  11    2:1   662 			IF (LSP1^.FORM > SUBRANGE) OR
  1262  11    2:1   666 				(LSP1 = INTPTR) OR (LSP1 = REALPTR) THEN
  1263  11    2:2   677 			  BEGIN ERROR(115); LSP1 := NIL END
  1264  11    2:1   684 			ELSE
  1265  11    2:2   686 			  IF LSP1 = REALPTR THEN
  1266  11    2:3   692 			    BEGIN ERROR(114); LSP1 := NIL END;
  1267  11    2:0   699 		      NEW(LSP,POWER);
  1268  11    2:0   704 		      WITH LSP^ DO
  1269  11    2:1   707 			BEGIN ELSET := LSP1; FORM := POWER;
  1270  11    2:2   719 			  IF LSP1 <> NIL THEN
  1271  11    2:3   724 			    BEGIN GETBOUNDS(LSP1,LMIN,LMAX);
  1272  11    2:4   732 			      SIZE := (LMAX + BITSPERWD) DIV BITSPERWD;
  1273  11    2:4   740 			      IF SIZE > 255 THEN
  1274  11    2:5   749 				BEGIN ERROR(169); SIZE := 1 END
  1275  11    2:3   759 			    END
  1276  11    2:2   759 			  ELSE SIZE := 0
  1277  11    2:1   763 			END
  1278  11    2:9   765 		    END
  1279  11    2:8   765 		  ELSE
  1280  11    2:9   767   (*FILE*)          IF SY = FILESY THEN
  1281  11    2:0   773 		      BEGIN
  1282  11    2:1   773 			IF INMODULE THEN
  1283  11    2:2   777 			  IF NOT ININTERFACE THEN
  1284  11    2:3   782 			    ERROR(191); (*NO PRIVATE FILES*)
  1285  11    2:1   788 			INSYMBOL; NEW(LSP,FILES);
  1286  11    2:1   796 			WITH LSP^ DO
  1287  11    2:2   799 			  BEGIN FORM := FILES; FILTYPE := NIL END;
  1288  11    2:1   811 			IF SY = OFSY THEN
  1289  11    2:2   817 			  BEGIN INSYMBOL; TYP(FSYS,LSP1,LSIZE) END
  1290  11    2:1   833 			ELSE LSP1 := NIL;
  1291  11    2:1   838 			LSP^.FILTYPE := LSP1;
  1292  11    2:1   843 			IF LSP1 <> NIL THEN
  1293  11    2:2   848 			  LSP^.SIZE := FILESIZE + LSP1^.SIZE
  1294  11    2:1   853 			ELSE LSP^.SIZE := NILFILESIZE
  1295  11    2:0   859 		      END;
  1296  11    2:6   861 	      FSP := LSP
  1297  11    2:5   862 	    END;
  1298  11    2:3   864 	IF NOT (SY IN FSYS) THEN
  1299  11    2:4   875 	  BEGIN ERROR(6); SKIP(FSYS) END
  1300  11    2:2   889       END
  1301  11    2:1   889     ELSE FSP := NIL;
  1302  11    2:1   894     IF FSP = NIL THEN FSIZE := 1 ELSE FSIZE := FSP^.SIZE
  1303  11    2:0   908   END (*TYP*) ;
  1304  11    2:0   942 
  1305  11    2:0   942 (* --- DECPART.B.TEXT --- *)
  1306  11    2:0   942 
  1307  11    2:0   942 (*    COPYRIGHT (C) 1979, REGENTS OF THE	*)
  1308  11    2:0   942 (*    UNIVERSITY OF CALIFORNIA, SAN DIEGO	*)
  1309  11    2:0   942 
  1310  11    9:D     1     PROCEDURE USESDECLARATION(MAGIC: BOOLEAN);
  1311  11    9:D     2       LABEL 1;
  1312  11    9:D     2       TYPE DCREC = RECORD
  1313  11    9:D     2 		     DISKADDR: INTEGER;
  1314  11    9:D     2 		     CODELENG: INTEGER
  1315  11    9:D     2 		   END;
  1316  11    9:D     2       VAR SEGDICT: RECORD
  1317  11    9:D     2 		       DANDC: ARRAY[SEGRANGE] OF DCREC;
  1318  11    9:D     2 		       SEGNAME: ARRAY[SEGRANGE] OF ALPHA;
  1319  11    9:D     2 	               SEGKIND: ARRAY[SEGRANGE] OF INTEGER;
  1320  11    9:D     2 		       TEXTADDR: ARRAY[SEGRANGE] OF INTEGER;
  1321  11    9:D     2 		       FILLER: ARRAY[0..127] OF INTEGER
  1322  11    9:D     2 		   END;
  1323  11    9:D   258 	  FOUND: BOOLEAN; BEGADDR: INTEGER;
  1324  11    9:D   260 	  LCP: CTP; LLEXSTK: LEXSTKREC; LNAME: ALPHA;
  1325  11    9:D   276           LSY: SYMBOL; LOP: OPERATOR; LID: ALPHA;
  1326  11    9:D   282 
  1327  11   10:D     1       PROCEDURE GETTEXT(VAR FOUND: BOOLEAN);
  1328  11   10:D     2 	VAR LCP: CTP; SEGINDEX: INTEGER;
  1329  11   10:D     4 
  1330  11   10:0     0       BEGIN FOUND := FALSE;
  1331  11   10:1     3 	LCP := MODPTR;
  1332  11   10:1     7 	WHILE (LCP <> NIL) AND NOT FOUND DO
  1333  11   10:2    16 	  IF LCP^.NAME = ID THEN FOUND := TRUE ELSE LCP := LCP^.NEXT;
  1334  11   10:1    35 	IF FOUND THEN
  1335  11   10:2    39 	  BEGIN
  1336  11   10:3    39 	    LSEPPROC := SEGTABLE[LCP^.SEGID].SEGKIND = 4;
  1337  11   10:3    52 	    IF NOT LSEPPROC THEN
  1338  11   10:4    57 	      BEGIN SEG := LCP^.SEGID; NEXTPROC := 1 END;
  1339  11   10:3    65 	    BEGADDR := SEGTABLE[LCP^.SEGID].TEXTADDR;
  1340  11   10:3    78 	    USEFILE := WORKCODE;
  1341  11   10:2    82 	  END
  1342  11   10:1    82 	ELSE
  1343  11   10:2    84 	  BEGIN FOUND := TRUE;
  1344  11   10:3    87 	    IF LIBNOTOPEN THEN
  1345  11   10:4    91 	      BEGIN RESET(LIBRARY,SYSTEMLIB);
  1346  11   10:5   102 		IF IORESULT <> 0 THEN BEGIN ERROR(187); FOUND := FALSE END
  1347  11   10:5   117 		ELSE
  1348  11   10:6   119 		  IF BLOCKREAD(LIBRARY,SEGDICT,1,0) <> 1 THEN
  1349  11   10:7   138 		    BEGIN ERROR(187); FOUND := FALSE END;
  1350  11   10:4   147 	      END;
  1351  11   10:3   147 	    IF FOUND THEN
  1352  11   10:4   151 	      BEGIN LIBNOTOPEN := FALSE;
  1353  11   10:5   154 		SEGINDEX := 0; FOUND := FALSE;
  1354  11   10:5   160 		WHILE (SEGINDEX <= MAXSEG) AND (NOT FOUND) DO
  1355  11   10:6   169 		  IF MAGIC THEN
  1356  11   10:7   174 		      IF SEGDICT.SEGNAME[SEGINDEX] = LNAME THEN FOUND := TRUE
  1357  11   10:7   190 		      ELSE SEGINDEX := SEGINDEX + 1
  1358  11   10:6   195 		  ELSE
  1359  11   10:7   201 		    IF SEGDICT.SEGNAME[SEGINDEX] = ID THEN FOUND := TRUE
  1360  11   10:7   215 		    ELSE SEGINDEX := SEGINDEX + 1;
  1361  11   10:5   226 		IF FOUND THEN
  1362  11   10:6   230 		  BEGIN USEFILE := SYSLIBRARY;
  1363  11   10:7   234 		    BEGADDR := SEGDICT.TEXTADDR[SEGINDEX];
  1364  11   10:7   245 		    LSEPPROC := SEGDICT.SEGKIND[SEGINDEX] = 4;
  1365  11   10:7   256 		    IF NOT LSEPPROC THEN
  1366  11   10:8   261 		      BEGIN
  1367  11   10:9   261 			IF MAGIC THEN SEG := 6
  1368  11   10:9   266 			ELSE
  1369  11   10:0   271 			  BEGIN SEG := NEXTSEG;
  1370  11   10:1   275 			    NEXTSEG := NEXTSEG + 1;
  1371  11   10:1   281 			    IF NEXTSEG > MAXSEG THEN ERROR(250)
  1372  11   10:0   290 			  END;
  1373  11   10:9   293 			WITH SEGTABLE[SEG] DO
  1374  11   10:0   301 			  BEGIN DISKADDR := 0; CODELENG := 0;
  1375  11   10:1   309 			    SEGNAME := SEGDICT.SEGNAME[SEGINDEX];
  1376  11   10:1   320 			    IF INMODULE OR MAGIC THEN SEGKIND := 0
  1377  11   10:1   331 			    ELSE SEGKIND := SEGDICT.SEGKIND[SEGINDEX];
  1378  11   10:1   346 			    TEXTADDR := 0
  1379  11   10:0   349 			  END;
  1380  11   10:9   351 			NEXTPROC := 1
  1381  11   10:8   351 		      END
  1382  11   10:6   354 		  END
  1383  11   10:5   354 		ELSE ERROR(190) (*NOT IN LIBRARY*)
  1384  11   10:4   359 	      END
  1385  11   10:2   362 	  END;
  1386  11   10:1   362 	IF BEGADDR = 0 THEN BEGIN ERROR(195); FOUND := FALSE END;
  1387  11   10:1   379 	IF FOUND THEN
  1388  11   10:2   383 	  BEGIN
  1389  11   10:3   383 	    USING := TRUE;
  1390  11   10:3   386 	    PREVSYMCURSOR := SYMCURSOR;
  1391  11   10:3   390 	    PREVLINESTART := LINESTART;
  1392  11   10:3   395 	    PREVSYMBLK := SYMBLK - 2;
  1393  11   10:3   402 	    SYMBLK := BEGADDR; GETNEXTPAGE;
  1394  11   10:3   411 	    INSYMBOL
  1395  11   10:2   411 	  END
  1396  11   10:0   414       END (*GETTEXT*) ;
  1397  11   10:0   434 
  1398  11    9:0     0     BEGIN (*USESDECLARATION*)
  1399  11    9:1     0       IF LEVEL <> 1 THEN ERROR(189);
  1400  11    9:1    12       IF INMODULE AND NOT ININTERFACE THEN ERROR(192);
  1401  11    9:1    26       IF NOT MAGIC THEN DLINKERINFO := TRUE;
  1402  11    9:1    33       IF NOT USING THEN USINGLIST := NIL; 
  1403  11    9:1    41       REPEAT
  1404  11    9:2    41 	IF (NOT MAGIC) AND (SY <> IDENT) THEN ERROR(2)
  1405  11    9:2    51 	ELSE
  1406  11    9:3    56 	  IF USING THEN
  1407  11    9:4    60 	    BEGIN LCP := USINGLIST;
  1408  11    9:5    65 	      WHILE LCP <> NIL DO
  1409  11    9:6    72 		IF LCP^.NAME = ID THEN GOTO 1
  1410  11    9:6    84 		ELSE LCP := LCP^.NEXT;
  1411  11    9:5    95 	      ERROR(188)(*UNIT MUST BE PREDECLARED IN MAIN PROG*);
  1412  11    9:5   101 	  1:
  1413  11    9:4   101 	    END
  1414  11    9:3   101 	  ELSE
  1415  11    9:4   103 	    BEGIN
  1416  11    9:5   103 	      IF MAGIC THEN
  1417  11    9:6   106 		BEGIN LNAME := 'TURTLE  ';
  1418  11    9:7   122 		  LSY := SY; LOP := OP; LID := ID
  1419  11    9:6   135 		END
  1420  11    9:5   139 	      ELSE
  1421  11    9:6   141 		BEGIN LNAME := ID;
  1422  11    9:7   148 		  WRITELN(OUTPUT); WRITELN(OUTPUT,ID,' [',MEMAVAIL:5,' words]');
  1423  11    9:7   208 		  WRITE(OUTPUT,'<',SCREENDOTS:4,'>')
  1424  11    9:6   233 		END;
  1425  11    9:5   233 	      WITH LLEXSTK DO
  1426  11    9:6   233 		BEGIN DOLDSEG := SEG; SOLDPROC := NEXTPROC END;
  1427  11    9:5   242 	      GETTEXT(FOUND);
  1428  11    9:5   247 	      IF FOUND THEN 
  1429  11    9:6   252 		BEGIN
  1430  11    9:7   252 		  NEW(LCP,MODULE);
  1431  11    9:7   258 		  WITH LCP^ DO
  1432  11    9:8   264 		    BEGIN NAME := LNAME; NEXT := USINGLIST;
  1433  11    9:9   280 		      IDTYPE := NIL; KLASS := MODULE;
  1434  11    9:9   294 		      IF LSEPPROC THEN SEGID := -1 (*NO SEG*) ELSE SEGID := SEG
  1435  11    9:8   313 		    END;
  1436  11    9:7   315 		  ENTERID(LCP);
  1437  11    9:7   321 		  USINGLIST := LCP;
  1438  11    9:7   326 		  DECLARATIONPART(FSYS + [ENDSY]);
  1439  11    9:7   341 		  IF NEXTPROC=1 (*NO PROCS DECLARED*) THEN
  1440  11    9:8   347 		    LCP^.SEGID := -1; (*NO SEG*)
  1441  11    9:7   355 		  SYMBLK := 9999; (*FORCE RETURN TO SOURCEFILE*)
  1442  11    9:7   360 		  GETNEXTPAGE
  1443  11    9:6   360 		END;
  1444  11    9:5   363 	      IF NOT LSEPPROC THEN
  1445  11    9:6   368 		WITH LLEXSTK DO
  1446  11    9:7   368 		  BEGIN SEG := DOLDSEG;
  1447  11    9:8   373 		    NEXTPROC := SOLDPROC
  1448  11    9:7   373 		  END;
  1449  11    9:5   378 	      LSEPPROC := FALSE;
  1450  11    9:4   381 	    END;
  1451  11    9:2   381 	IF NOT MAGIC THEN
  1452  11    9:3   385 	  BEGIN INSYMBOL;
  1453  11    9:4   388 	    TEST := SY <> COMMA;
  1454  11    9:4   394 	    IF TEST THEN 
  1455  11    9:5   397 	      IF SY <> SEMICOLON THEN ERROR(20)
  1456  11    9:5   404 	      ELSE
  1457  11    9:4   409 	    ELSE INSYMBOL
  1458  11    9:3   411 	  END
  1459  11    9:1   414       UNTIL TEST OR MAGIC;
  1460  11    9:1   419       IF NOT MAGIC THEN
  1461  11    9:2   423 	IF SY = SEMICOLON THEN INSYMBOL ELSE ERROR(14)
  1462  11    9:1   435       ELSE BEGIN SY := LSY; OP := LOP; ID := LID END;
  1463  11    9:1   457       IF NOT USING THEN
  1464  11    9:2   462         BEGIN
  1465  11    9:3   462 	  IF INMODULE THEN USINGLIST := NIL;
  1466  11    9:3   469 	  CLOSE(LIBRARY,LOCK);
  1467  11    9:3   476 	  LIBNOTOPEN := TRUE
  1468  11    9:2   476 	END
  1469  11    9:0   479     END (*USESDECLARATION*) ;
  1470  11    9:0   500 
  1471  11   11:D     1     PROCEDURE LABELDECLARATION;
  1472  11   11:D     1       VAR LLP: LABELP; REDEF: BOOLEAN;
  1473  11   11:0     0     BEGIN
  1474  11   11:1     0       REPEAT
  1475  11   11:2     0 	IF SY = INTCONST THEN
  1476  11   11:3     6 	  WITH DISPLAY[TOP] DO
  1477  11   11:4    13 	    BEGIN LLP := FLABEL; REDEF := FALSE;
  1478  11   11:5    20 	      WHILE (LLP <> NIL) AND NOT REDEF DO
  1479  11   11:6    28 		IF LLP^.LABVAL <> VAL.IVAL THEN
  1480  11   11:7    35 		  LLP := LLP^.NEXTLAB
  1481  11   11:6    36 		ELSE BEGIN REDEF := TRUE; ERROR(166) END;
  1482  11   11:5    52 	      IF NOT REDEF THEN
  1483  11   11:6    56 		BEGIN NEW(LLP);
  1484  11   11:7    61 		  WITH LLP^ DO
  1485  11   11:8    64 		    BEGIN LABVAL := VAL.IVAL;
  1486  11   11:9    68 		      CODELBP := NIL; NEXTLAB := FLABEL
  1487  11   11:8    76 		    END;
  1488  11   11:7    79 		  FLABEL := LLP
  1489  11   11:6    82 		END;
  1490  11   11:5    84 	      INSYMBOL
  1491  11   11:4    84 	    END
  1492  11   11:2    87 	ELSE ERROR(15);
  1493  11   11:2    93 	IF NOT ( SY IN FSYS + [COMMA, SEMICOLON] ) THEN
  1494  11   11:3   108 	  BEGIN ERROR(6); SKIP(FSYS+[COMMA,SEMICOLON]) END;
  1495  11   11:2   126 	TEST := SY <> COMMA;
  1496  11   11:2   132 	IF NOT TEST THEN INSYMBOL
  1497  11   11:1   136       UNTIL TEST;
  1498  11   11:1   142       IF SY = SEMICOLON THEN INSYMBOL ELSE ERROR(14)
  1499  11   11:0   154     END (* LABELDECLARATION *) ;
  1500  11   11:0   174   
  1501  11   12:D     1     PROCEDURE CONSTDECLARATION;
  1502  11   12:D     1       VAR LCP: CTP; LSP: STP; LVALU: VALU;
  1503  11   12:0     0     BEGIN
  1504  11   12:1     0       IF SY <> IDENT THEN
  1505  11   12:2     6 	BEGIN ERROR(2); SKIP(FSYS + [IDENT]) END;
  1506  11   12:1    24       WHILE SY = IDENT DO
  1507  11   12:2    30 	BEGIN NEW(LCP,KONST);
  1508  11   12:3    35 	  WITH LCP^ DO
  1509  11   12:4    38 	    BEGIN NAME := ID; IDTYPE := NIL;
  1510  11   12:5    48 	      NEXT := NIL; KLASS := KONST
  1511  11   12:4    56 	    END;
  1512  11   12:3    58 	  INSYMBOL;
  1513  11   12:3    61 	  IF (SY = RELOP) AND (OP = EQOP) THEN INSYMBOL ELSE ERROR(16);
  1514  11   12:3    81 	  CONSTANT(FSYS + [SEMICOLON],LSP,LVALU);
  1515  11   12:3    99 	  ENTERID(LCP);
  1516  11   12:3   103 	  LCP^.IDTYPE := LSP; LCP^.VALUES := LVALU;
  1517  11   12:3   115 	  IF SY = SEMICOLON THEN
  1518  11   12:4   121 	    BEGIN INSYMBOL;
  1519  11   12:5   124 	      IF NOT (SY IN FSYS + [IDENT]) THEN
  1520  11   12:6   139 		BEGIN ERROR(6); SKIP(FSYS + [IDENT]) END
  1521  11   12:4   157 	    END
  1522  11   12:3   157 	  ELSE
  1523  11   12:4   159 	    IF NOT ((SY = ENDSY) AND (INMODULE)) THEN ERROR(14)
  1524  11   12:2   170 	END
  1525  11   12:0   173     END (*CONSTDECLARATION*) ;
  1526  11   12:0   192   
  1527  11   13:D     1     PROCEDURE TYPEDECLARATION;
  1528  11   13:D     1       VAR LCP,LCP1,LCP2: CTP; LSP: STP; LSIZE: ADDRRANGE;
  1529  11   13:0     0     BEGIN
  1530  11   13:1     0       IF SY <> IDENT THEN
  1531  11   13:2     6 	BEGIN ERROR(2); SKIP(FSYS + [IDENT]) END;
  1532  11   13:1    24       WHILE SY = IDENT DO
  1533  11   13:2    30 	BEGIN NEW(LCP,TYPES);
  1534  11   13:3    35 	  WITH LCP^ DO
  1535  11   13:4    38 	    BEGIN NAME := ID; IDTYPE := NIL; KLASS := TYPES END;
  1536  11   13:3    53 	  INSYMBOL;
  1537  11   13:3    56 	  IF (SY = RELOP) AND (OP = EQOP) THEN INSYMBOL ELSE ERROR(16);
  1538  11   13:3    76 	  TYP(FSYS + [SEMICOLON],LSP,LSIZE);
  1539  11   13:3    93 	  ENTERID(LCP);
  1540  11   13:3    97 	  LCP^.IDTYPE := LSP;
  1541  11   13:3   102 	  LCP1 := FWPTR;
  1542  11   13:3   106 	  WHILE LCP1 <> NIL DO
  1543  11   13:4   111 	    BEGIN
  1544  11   13:5   111 	      IF LCP1^.NAME = LCP^.NAME THEN
  1545  11   13:6   118 		BEGIN
  1546  11   13:7   118 		  LCP1^.IDTYPE^.ELTYPE := LCP^.IDTYPE;
  1547  11   13:7   125 		  IF LCP1 <> FWPTR THEN
  1548  11   13:8   131 		    LCP2^.NEXT := LCP1^.NEXT
  1549  11   13:7   135 		  ELSE FWPTR := LCP1^.NEXT;
  1550  11   13:6   143 		END;
  1551  11   13:5   143 	      LCP2 := LCP1; LCP1 := LCP1^.NEXT
  1552  11   13:4   147 	    END;
  1553  11   13:3   152 	  IF SY = SEMICOLON THEN
  1554  11   13:4   158 	    BEGIN INSYMBOL;
  1555  11   13:5   161 	      IF NOT (SY IN FSYS + [IDENT]) THEN
  1556  11   13:6   176 		BEGIN ERROR(6); SKIP(FSYS + [IDENT]) END
  1557  11   13:4   194 	    END
  1558  11   13:3   194 	  ELSE
  1559  11   13:4   196 	    IF NOT ((SY = ENDSY) AND (INMODULE)) THEN ERROR(14)
  1560  11   13:2   207 	END;
  1561  11   13:1   212       IF FWPTR <> NIL THEN
  1562  11   13:2   218 	BEGIN ERROR(117); FWPTR := NIL END
  1563  11   13:0   225     END (*TYPEDECLARATION*) ;
  1564  11   13:0   244   
  1565  11   14:D     1     PROCEDURE VARDECLARATION;
  1566  11   14:D     1       VAR LCP,NXT,IDLIST: CTP; LSP: STP; LSIZE: ADDRRANGE;
  1567  11   14:0     0     BEGIN NXT := NIL;
  1568  11   14:1     3       REPEAT
  1569  11   14:2     3 	REPEAT
  1570  11   14:3     3 	  IF SY = IDENT THEN
  1571  11   14:4     9 	    BEGIN
  1572  11   14:5     9 	      IF INMODULE THEN NEW(LCP,ACTUALVARS,TRUE)
  1573  11   14:5    18 	      ELSE NEW(LCP,ACTUALVARS,FALSE);
  1574  11   14:5    25 	      WITH LCP^ DO
  1575  11   14:6    28 	       BEGIN NAME := ID; NEXT := NXT; KLASS := ACTUALVARS;
  1576  11   14:7    43 		 IDTYPE := NIL; VLEV := LEVEL;
  1577  11   14:7    54 	         IF INMODULE THEN
  1578  11   14:8    58 		   IF ININTERFACE THEN PUBLIC := TRUE
  1579  11   14:8    65 		   ELSE PUBLIC := FALSE
  1580  11   14:6    72 	       END;
  1581  11   14:5    74 	      ENTERID(LCP);
  1582  11   14:5    78 	      NXT := LCP;
  1583  11   14:5    81 	      INSYMBOL;
  1584  11   14:4    84 	    END
  1585  11   14:3    84 	  ELSE ERROR(2);
  1586  11   14:3    90 	  IF NOT (SY IN FSYS + [COMMA,COLON] + TYPEDELS) THEN
  1587  11   14:4   111 	    BEGIN ERROR(6); SKIP(FSYS+[COMMA,COLON,SEMICOLON]+TYPEDELS) END;
  1588  11   14:3   135 	  TEST := SY <> COMMA;
  1589  11   14:3   141 	  IF NOT TEST THEN INSYMBOL
  1590  11   14:2   145 	UNTIL TEST;
  1591  11   14:2   151 	IF SY = COLON THEN INSYMBOL ELSE ERROR(5);
  1592  11   14:2   166 	IDLIST := NXT;
  1593  11   14:2   169 	TYP(FSYS + [SEMICOLON] + TYPEDELS,LSP,LSIZE);
  1594  11   14:2   192 	WHILE NXT <> NIL DO
  1595  11   14:3   197 	  WITH  NXT^ DO
  1596  11   14:4   200 	    BEGIN IDTYPE := LSP; VADDR := LC;
  1597  11   14:5   210 	      LC := LC + LSIZE; NXT := NEXT;
  1598  11   14:5   219 	      IF NEXT = NIL THEN
  1599  11   14:6   225 		IF LSP <> NIL THEN
  1600  11   14:7   230 		  IF LSP^.FORM = FILES THEN
  1601  11   14:8   236 		      BEGIN (*PUT IDLIST INTO LOCAL FILE LIST*)
  1602  11   14:9   236 			NEXT := DISPLAY[TOP].FFILE;
  1603  11   14:9   246 			DISPLAY[TOP].FFILE := IDLIST
  1604  11   14:8   253 		      END
  1605  11   14:4   255 	    END;
  1606  11   14:2   257 	IF SY = SEMICOLON THEN
  1607  11   14:3   263 	  BEGIN INSYMBOL;
  1608  11   14:4   266 	    IF NOT (SY IN FSYS + [IDENT]) THEN
  1609  11   14:5   281 	      BEGIN ERROR(6); SKIP(FSYS + [IDENT]) END
  1610  11   14:3   299 	  END
  1611  11   14:2   299 	ELSE
  1612  11   14:3   301 	    IF NOT ((SY = ENDSY) AND (INMODULE)) THEN ERROR(14)
  1613  11   14:1   312       UNTIL (SY <> IDENT) AND NOT (SY IN TYPEDELS);
  1614  11   14:1   331     IF FWPTR <> NIL THEN
  1615  11   14:2   337 	BEGIN ERROR(117); FWPTR := NIL END
  1616  11   14:0   344     END (*VARDECLARATION*) ;
  1617  11   14:0   362 
  1618  11   14:0   362 (* --- DECPART.C.TEXT --- *)
  1619  11   14:0   362 
  1620  11   14:0   362 (*    COPYRIGHT (C) 1979, REGENTS OF THE	*)
  1621  11   14:0   362 (*    UNIVERSITY OF CALIFORNIA, SAN DIEGO	*)
  1622  11   14:0   362 
  1623  11   15:D     1     PROCEDURE PROCDECLARATION(FSY: SYMBOL; SEGDEC: BOOLEAN);
  1624  11   15:D     3       VAR LSY: SYMBOL; LCP,LCP1: CTP; LSP: STP;
  1625  11   15:D     7 	  EXTONLY,FORW: BOOLEAN; 
  1626  11   15:D     9 	  LCM: ADDRRANGE;  
  1627  11   15:D    10           LLEXSTK: LEXSTKREC;
  1628  11   15:D    21 
  1629  11   16:D     1       PROCEDURE PARAMETERLIST(FSY: SETOFSYS; VAR FPAR: CTP; FCP: CTP);
  1630  11   16:D     7 	VAR LCP,LCP1,LCP2,LCP3: CTP; LSP: STP; LKIND: IDKIND;
  1631  11   16:D    13 	  LLC,LEN : ADDRRANGE; COUNT : INTEGER;
  1632  11   16:0     0       BEGIN LCP1 := NIL; LLC := LC;
  1633  11   16:1     6 	IF NOT (SY IN FSY + [LPARENT]) THEN
  1634  11   16:2    20 	  BEGIN ERROR(7); SKIP(FSYS + FSY + [LPARENT]) END;
  1635  11   16:1    44 	IF SY = LPARENT THEN
  1636  11   16:2    50 	  BEGIN IF FORW THEN ERROR(119);
  1637  11   16:3    59 	    INSYMBOL;
  1638  11   16:3    62 	    IF NOT (SY IN [IDENT,VARSY]) THEN
  1639  11   16:4    75 	      BEGIN ERROR(7); SKIP(FSYS + [IDENT,RPARENT]) END;
  1640  11   16:3    93 	    WHILE SY IN [IDENT,VARSY] DO
  1641  11   16:4   106 	      BEGIN
  1642  11   16:5   106 		IF SY = VARSY THEN
  1643  11   16:6   112 		  BEGIN LKIND := FORMAL; INSYMBOL END
  1644  11   16:5   118 		ELSE LKIND := ACTUAL;
  1645  11   16:5   123 		LCP2 := NIL;
  1646  11   16:5   126 		COUNT := 0;
  1647  11   16:5   129 		REPEAT
  1648  11   16:6   129 		  IF SY <> IDENT THEN ERROR(2)
  1649  11   16:6   136 		  ELSE
  1650  11   16:7   141 		    BEGIN
  1651  11   16:8   141 		      NEW(LCP,FORMALVARS,FALSE); (*MAY BE ACTUAL(SAME SIZE)*)
  1652  11   16:8   146 		      WITH LCP^ DO
  1653  11   16:9   149 			BEGIN NAME := ID; IDTYPE := NIL; NEXT := LCP2;
  1654  11   16:0   164 			  IF LKIND = FORMAL THEN KLASS := FORMALVARS
  1655  11   16:0   172 			  ELSE KLASS := ACTUALVARS; VLEV := LEVEL
  1656  11   16:9   184 			END;
  1657  11   16:8   187 		      ENTERID(LCP);
  1658  11   16:8   191 		      LCP2 := LCP; COUNT := COUNT + 1;
  1659  11   16:8   199 		      INSYMBOL
  1660  11   16:7   199 		    END;
  1661  11   16:6   202 		  IF NOT (SY IN FSYS + [COMMA,SEMICOLON,COLON]) THEN
  1662  11   16:7   217 		    BEGIN ERROR(7);
  1663  11   16:8   221 		      SKIP(FSYS + [COMMA,SEMICOLON,RPARENT,COLON])
  1664  11   16:7   232 		    END;
  1665  11   16:6   235 		  TEST := SY <> COMMA;
  1666  11   16:6   241 		  IF NOT TEST THEN INSYMBOL
  1667  11   16:5   245 		UNTIL TEST;
  1668  11   16:5   251 		LSP := NIL;
  1669  11   16:5   254 		IF SY = COLON THEN
  1670  11   16:6   260 		  BEGIN INSYMBOL;
  1671  11   16:7   263 		    IF SY = IDENT THEN
  1672  11   16:8   269 		      BEGIN
  1673  11   16:9   269 			SEARCHID([TYPES],LCP);
  1674  11   16:9   278 			INSYMBOL;
  1675  11   16:9   281 			LSP := LCP^.IDTYPE;
  1676  11   16:9   285 			LEN := PTRSIZE;
  1677  11   16:9   288 			IF LSP <> NIL THEN
  1678  11   16:0   293 			  IF LKIND = ACTUAL THEN
  1679  11   16:1   298 			    IF LSP^.FORM = FILES THEN ERROR(121)
  1680  11   16:1   305 			    ELSE
  1681  11   16:2   310 			      IF LSP^.FORM <= POWER THEN LEN := LSP^.SIZE;
  1682  11   16:9   320 			LC := LC + COUNT * LEN
  1683  11   16:8   322 		      END
  1684  11   16:7   327 		    ELSE ERROR(2)
  1685  11   16:6   330 		  END
  1686  11   16:5   333 		ELSE
  1687  11   16:6   335 		  IF LKIND = FORMAL THEN
  1688  11   16:6   340 {.fs}               { we must be able to say PROCECURE(VAR X) for TURTLEGRAPHICS }
  1689  11   16:7   340 {.fs}               IF SYSCOMP THEN BEGIN
  1690  11   16:9   344 {.fs}		      LSP := INTPTR;    { treat it as VAR X: INTEGER }
  1691  11   16:9   347 {.fs}		      LEN := LSP^.SIZE;
  1692  11   16:9   351 {.fs}		      LC := LC + COUNT * LEN
  1693  11   16:8   353 {.fs}               END ELSE
  1694  11   16:8   360 		    EXTONLY := TRUE
  1695  11   16:6   360 		  ELSE ERROR(5);
  1696  11   16:5   370 		IF NOT (SY IN FSYS + [SEMICOLON,RPARENT]) THEN
  1697  11   16:6   385 		  BEGIN ERROR(7); SKIP(FSYS + [SEMICOLON,RPARENT]) END;
  1698  11   16:5   403 		LCP3 := LCP2; LCP := NIL;
  1699  11   16:5   409 		WHILE LCP2 <> NIL DO
  1700  11   16:6   414 		  BEGIN LCP := LCP2;
  1701  11   16:7   417 		    WITH LCP2^ DO
  1702  11   16:8   420 		      BEGIN IDTYPE := LSP;
  1703  11   16:9   425 			LCP2 := NEXT
  1704  11   16:8   425 		      END
  1705  11   16:6   429 		  END;
  1706  11   16:5   431 		IF LCP <> NIL THEN
  1707  11   16:6   436 		  BEGIN LCP^.NEXT := LCP1; LCP1 := LCP3 END;
  1708  11   16:5   444 		IF SY = SEMICOLON THEN
  1709  11   16:6   450 		  BEGIN INSYMBOL;
  1710  11   16:7   453 		    IF NOT (SY IN FSYS + [IDENT,VARSY]) THEN
  1711  11   16:8   474 		      BEGIN ERROR(7); SKIP(FSYS + [IDENT,RPARENT]) END
  1712  11   16:6   492 		  END
  1713  11   16:4   492 	      END (*WHILE*) ;
  1714  11   16:3   494 	    IF SY = RPARENT THEN
  1715  11   16:4   500 	      BEGIN INSYMBOL;
  1716  11   16:5   503 		IF NOT (SY IN FSY + FSYS) THEN
  1717  11   16:6   521 		  BEGIN ERROR(6); SKIP(FSY + FSYS) END
  1718  11   16:4   542 	      END
  1719  11   16:3   542 	    ELSE ERROR(4);
  1720  11   16:3   548 	    FCP^.LOCALLC := LC; LCP3 := NIL;
  1721  11   16:3   556 	    WHILE LCP1 <> NIL DO
  1722  11   16:4   561 	      WITH LCP1^ DO
  1723  11   16:5   564 		BEGIN LCP2 := NEXT; NEXT := LCP3;
  1724  11   16:6   573 		  IF (IDTYPE <> NIL) THEN
  1725  11   16:7   579 		    IF KLASS = FORMALVARS THEN
  1726  11   16:8   586 		      BEGIN VADDR := LLC; LLC := LLC + PTRSIZE END
  1727  11   16:7   596 		    ELSE
  1728  11   16:8   598 		      IF KLASS = ACTUALVARS THEN
  1729  11   16:9   605 			IF (IDTYPE^.FORM <= POWER) THEN
  1730  11   16:0   612 			  BEGIN VADDR := LLC; LLC := LLC + IDTYPE^.SIZE END
  1731  11   16:9   624 			ELSE
  1732  11   16:0   626 			  BEGIN VADDR := LC;
  1733  11   16:1   631 			    LC := LC + IDTYPE^.SIZE;
  1734  11   16:1   638 			    LLC := LLC + PTRSIZE
  1735  11   16:0   639 			  END;
  1736  11   16:6   643 		  LCP3 := LCP1; LCP1 := LCP2
  1737  11   16:5   646 		END;
  1738  11   16:3   651 	    FPAR := LCP3
  1739  11   16:2   652 	  END
  1740  11   16:1   654 	    ELSE FPAR := NIL
  1741  11   16:0   657     END (*PARAMETERLIST*) ;
  1742  11   16:0   684   
  1743  11   15:0     0     BEGIN (*PROCDECLARATION*)
  1744  11   15:1     0       IF SEGDEC THEN (* SEGMENT DECLARATION *)
  1745  11   15:2     3 	BEGIN
  1746  11   15:3     3 	  IF CODEINSEG THEN 
  1747  11   15:4     7 	    BEGIN ERROR(399); SEGINX:=0; CURBYTE:=0; END;
  1748  11   15:3    20 	  WITH LLEXSTK DO
  1749  11   15:4    20 	    BEGIN
  1750  11   15:5    20 	      DOLDSEG:=SEG;
  1751  11   15:5    23 	      SEG:=NEXTSEG;
  1752  11   15:5    27 	      SOLDPROC:=NEXTPROC;
  1753  11   15:4    31 	    END;
  1754  11   15:3    31 	  NEXTPROC:=1;
  1755  11   15:3    34 	  LSY:=SY;
  1756  11   15:3    38 	  IF SY IN [PROCSY,FUNCSY] THEN INSYMBOL
  1757  11   15:3    52 	  ELSE BEGIN ERROR(399); LSY:=PROCSY END;
  1758  11   15:3    66 	  FSY:=LSY;
  1759  11   15:2    69 	END;
  1760  11   15:1    69       LLEXSTK.DLLC := LC; LC := LCAFTERMARKSTACK;
  1761  11   15:1    75       IF FSY = FUNCSY THEN LC := LC + REALSIZE;
  1762  11   15:1    85       LINEINFO := LC; DP := TRUE; EXTONLY := FALSE;
  1763  11   15:1    94       IF SY = IDENT THEN
  1764  11   15:2   100 	BEGIN
  1765  11   15:3   100 	  IF USING OR INMODULE AND ININTERFACE THEN FORW := FALSE
  1766  11   15:3   110 	  ELSE
  1767  11   15:4   115 	    BEGIN SEARCHSECTION(DISPLAY[TOP].FNAME,LCP);
  1768  11   15:5   126 	      IF LCP <> NIL THEN
  1769  11   15:6   131 		BEGIN
  1770  11   15:7   131 		  IF LCP^.KLASS = PROC THEN
  1771  11   15:8   138 		    FORW := LCP^.FORWDECL AND (FSY = PROCSY)
  1772  11   15:8   144 			    AND (LCP^.PFKIND = ACTUAL)
  1773  11   15:7   150 		  ELSE
  1774  11   15:8   155 		    IF LCP^.KLASS = FUNC THEN
  1775  11   15:9   162 		      FORW := LCP^.FORWDECL AND (FSY = FUNCSY)
  1776  11   15:9   168 			      AND (LCP^.PFKIND = ACTUAL)
  1777  11   15:8   174 		    ELSE FORW := FALSE;
  1778  11   15:7   182 		  IF NOT FORW THEN ERROR(160)
  1779  11   15:6   189 		END
  1780  11   15:5   192 	      ELSE FORW := FALSE
  1781  11   15:4   194 	    END;
  1782  11   15:3   197 	  IF NOT FORW THEN
  1783  11   15:4   201 	    BEGIN
  1784  11   15:5   201 	      IF FSY = PROCSY THEN
  1785  11   15:6   206 		IF INMODULE THEN NEW(LCP,PROC,DECLARED,ACTUAL,TRUE)
  1786  11   15:6   215 	        ELSE NEW(LCP,PROC,DECLARED,ACTUAL,FALSE)
  1787  11   15:5   222 	      ELSE
  1788  11   15:6   224 		IF INMODULE THEN NEW(LCP,FUNC,DECLARED,ACTUAL,TRUE)
  1789  11   15:6   233 	        ELSE NEW(LCP,FUNC,DECLARED,ACTUAL,FALSE);
  1790  11   15:5   240 	      WITH LCP^ DO
  1791  11   15:6   243 		BEGIN NAME := ID; IDTYPE := NIL; LOCALLC := LC;
  1792  11   15:7   261 		  PFDECKIND := DECLARED; PFKIND := ACTUAL;
  1793  11   15:7   273 		  INSCOPE := FALSE; PFLEV := LEVEL;
  1794  11   15:7   286 		  PFNAME := NEXTPROC; PFSEG := SEG;
  1795  11   15:7   299 		  IF USING THEN PROCTABLE[NEXTPROC] := 0;
  1796  11   15:7   312 		  IF INMODULE THEN
  1797  11   15:8   316 		    IF USING THEN IMPORTED := TRUE
  1798  11   15:8   324 		    ELSE IMPORTED := FALSE;
  1799  11   15:7   334 		  IF SEGDEC THEN
  1800  11   15:8   337 		    BEGIN
  1801  11   15:9   337 		      IF NEXTSEG > MAXSEG THEN ERROR(250);
  1802  11   15:9   349 		      NEXTSEG := NEXTSEG+1;
  1803  11   15:9   355 		      SEGTABLE[SEG].SEGNAME := ID
  1804  11   15:8   363 		    END;
  1805  11   15:7   367 		  IF NEXTPROC = MAXPROCNUM THEN ERROR(251)
  1806  11   15:7   378 		  ELSE NEXTPROC := NEXTPROC + 1;
  1807  11   15:7   389 		  IF FSY = PROCSY THEN KLASS := PROC
  1808  11   15:7   398 		  ELSE KLASS := FUNC
  1809  11   15:6   406 		END;
  1810  11   15:5   408 	      ENTERID(LCP)
  1811  11   15:4   409 	    END
  1812  11   15:3   412 	  ELSE
  1813  11   15:4   414 	    BEGIN LCP1 := LCP^.NEXT;
  1814  11   15:5   418 	      WHILE LCP1 <> NIL DO
  1815  11   15:6   423 		BEGIN
  1816  11   15:7   423 		  WITH LCP1^ DO
  1817  11   15:8   426 		    IF IDTYPE = NIL THEN
  1818  11   15:9   433 		      EXTONLY := TRUE
  1819  11   15:8   433 		    ELSE
  1820  11   15:9   438 		      IF KLASS = FORMALVARS THEN
  1821  11   15:0   446 			BEGIN
  1822  11   15:1   446 			  LCM := VADDR + PTRSIZE;
  1823  11   15:1   454 			  IF LCM > LC THEN LC := LCM
  1824  11   15:0   459 			END
  1825  11   15:9   462 		      ELSE
  1826  11   15:0   464 			IF KLASS = ACTUALVARS THEN
  1827  11   15:1   472 			  BEGIN
  1828  11   15:2   472 			    LCM := VADDR + IDTYPE^.SIZE;
  1829  11   15:2   483 			    IF LCM > LC THEN LC := LCM
  1830  11   15:1   488 			  END;
  1831  11   15:7   491 		  LCP1 := LCP1^.NEXT
  1832  11   15:6   492 		END;
  1833  11   15:5   497 	      IF SEG <> LCP^.PFSEG THEN
  1834  11   15:6   504 		BEGIN
  1835  11   15:7   504 		  SEG := LCP^.PFSEG; NEXTPROC := 2;
  1836  11   15:7   512 		  IF NOT SEGDEC THEN ERROR(399)
  1837  11   15:6   519 		END
  1838  11   15:4   522 	    END;
  1839  11   15:3   522 	  INSYMBOL
  1840  11   15:2   522 	END
  1841  11   15:1   525       ELSE
  1842  11   15:2   527 	BEGIN ERROR(2); LCP := UPRCPTR END;
  1843  11   15:1   535       WITH LLEXSTK DO
  1844  11   15:2   535 	BEGIN DOLDLEV:=LEVEL; 
  1845  11   15:3   539 	  DOLDTOP:=TOP; 
  1846  11   15:3   542 	  POLDPROC:=CURPROC; 
  1847  11   15:3   546           DFPROCP:=LCP;
  1848  11   15:2   549 	END;
  1849  11   15:1   549       CURPROC := LCP^.PFNAME;
  1850  11   15:1   554       IF LEVEL < MAXLEVEL THEN LEVEL := LEVEL + 1 ELSE ERROR(251);
  1851  11   15:1   574       IF TOP < DISPLIMIT THEN
  1852  11   15:2   579 	BEGIN TOP := TOP + 1;
  1853  11   15:3   584 	  WITH DISPLAY[TOP] DO
  1854  11   15:4   591 	    BEGIN
  1855  11   15:5   591 	      IF FORW THEN FNAME := LCP^.NEXT
  1856  11   15:5   597 	      ELSE FNAME := NIL;
  1857  11   15:5   605 	      FLABEL := NIL; FFILE := NIL; OCCUR := BLCK
  1858  11   15:4   621 	    END
  1859  11   15:2   623 	END
  1860  11   15:1   623       ELSE ERROR(250);
  1861  11   15:1   631       IF FSY = PROCSY THEN
  1862  11   15:2   636 	BEGIN PARAMETERLIST([SEMICOLON],LCP1,LCP);
  1863  11   15:3   645 	  IF NOT FORW THEN LCP^.NEXT := LCP1
  1864  11   15:2   652 	END
  1865  11   15:1   654       ELSE
  1866  11   15:2   656 	BEGIN PARAMETERLIST([SEMICOLON,COLON],LCP1,LCP);
  1867  11   15:3   665 	  IF NOT FORW THEN LCP^.NEXT := LCP1;
  1868  11   15:3   674 	  IF SY = COLON THEN
  1869  11   15:4   680 	    BEGIN INSYMBOL;
  1870  11   15:5   683 	      IF SY = IDENT THEN
  1871  11   15:6   689 		BEGIN IF FORW THEN ERROR(122);
  1872  11   15:7   696 		  SEARCHID([TYPES],LCP1);
  1873  11   15:7   705 		  LSP := LCP1^.IDTYPE;
  1874  11   15:7   709 		  LCP^.IDTYPE := LSP;
  1875  11   15:7   714 		  IF LSP <> NIL THEN
  1876  11   15:8   719 		    IF NOT (LSP^.FORM IN [SCALAR,SUBRANGE,POINTER]) THEN
  1877  11   15:9   727 		      BEGIN ERROR(120); LCP^.IDTYPE := NIL END;
  1878  11   15:7   736 		  INSYMBOL
  1879  11   15:6   736 		END
  1880  11   15:5   739 	      ELSE BEGIN ERROR(2); SKIP(FSYS + [SEMICOLON]) END
  1881  11   15:4   759 	    END
  1882  11   15:3   759 	  ELSE
  1883  11   15:4   761 	    IF NOT FORW THEN ERROR(123)
  1884  11   15:2   766 	END;
  1885  11   15:1   769       IF SY = SEMICOLON THEN INSYMBOL ELSE ERROR(14);
  1886  11   15:1   784       LCP^.EXTURNAL := FALSE;
  1887  11   15:1   789       IF (SY = EXTERNLSY)
  1888  11   15:1   793 	 OR ((USING) AND (LSEPPROC)) THEN
  1889  11   15:2   801 	BEGIN
  1890  11   15:3   801 	  IF LEVEL <> 2 THEN
  1891  11   15:4   807 	    ERROR(183) (*EXTERNAL PROCS MUST BE IN OUTERMOST BLOCK*);
  1892  11   15:3   813 	  IF INMODULE THEN
  1893  11   15:4   817 	    IF ININTERFACE AND NOT USING THEN
  1894  11   15:5   825 	      ERROR(184); (*NO EXTERNAL DECL IN INTERFACE*)
  1895  11   15:3   831 	  IF SEGDEC THEN ERROR(399);
  1896  11   15:3   840 	  WITH LCP^ DO
  1897  11   15:4   843 	    BEGIN EXTURNAL := TRUE; FORWDECL := FALSE;
  1898  11   15:5   855 	      WRITELN(OUTPUT); WRITELN(OUTPUT,NAME,' [',MEMAVAIL:5,' words]');
  1899  11   15:5   915 	      WRITE(OUTPUT,'<',SCREENDOTS:4,'>')
  1900  11   15:4   940 	    END;
  1901  11   15:3   940 	  PROCTABLE[CURPROC] := 0;
  1902  11   15:3   949 	  DLINKERINFO := TRUE;
  1903  11   15:3   952 	  IF SY = EXTERNLSY THEN
  1904  11   15:4   958 	    BEGIN INSYMBOL;
  1905  11   15:5   961 	      IF SY = SEMICOLON THEN INSYMBOL ELSE ERROR(14);
  1906  11   15:5   976 	      IF NOT (SY IN FSYS) THEN
  1907  11   15:6   988 		BEGIN ERROR(6); SKIP(FSYS) END
  1908  11   15:4  1003 	    END
  1909  11   15:2  1003 	END
  1910  11   15:1  1003       ELSE
  1911  11   15:2  1005 	IF USING THEN
  1912  11   15:3  1009 	  BEGIN LCP^.FORWDECL := FALSE;
  1913  11   15:3  1014 	  END
  1914  11   15:2  1014 	ELSE
  1915  11   15:3  1016 	  IF (SY = FORWARDSY) OR INMODULE AND ININTERFACE THEN
  1916  11   15:4  1028 	    BEGIN
  1917  11   15:5  1028 	      IF FORW THEN ERROR(161)
  1918  11   15:5  1034 	      ELSE LCP^.FORWDECL := TRUE;
  1919  11   15:5  1044 	      IF SY = FORWARDSY THEN 
  1920  11   15:6  1050 		BEGIN INSYMBOL;
  1921  11   15:7  1053 		  IF SY = SEMICOLON THEN INSYMBOL ELSE ERROR(14)
  1922  11   15:6  1065 		END;
  1923  11   15:5  1068 	      IF NOT (SY IN FSYS) THEN
  1924  11   15:6  1080 		BEGIN ERROR(6); SKIP(FSYS) END
  1925  11   15:4  1095 	    END
  1926  11   15:3  1095 	  ELSE
  1927  11   15:4  1097 	    BEGIN 
  1928  11   15:5  1097 	      IF EXTONLY THEN
  1929  11   15:6  1100 		ERROR(7);
  1930  11   15:5  1104 	      NEWBLOCK:=TRUE;
  1931  11   15:5  1107 	      NOTDONE:=TRUE;
  1932  11   15:5  1111 	      WITH LLEXSTK DO
  1933  11   15:6  1111 		BEGIN 
  1934  11   15:7  1111 		  MARK(DMARKP);
  1935  11   15:7  1115 		  WITH LCP^ DO
  1936  11   15:8  1118 		    BEGIN FORWDECL := FALSE; INSCOPE := TRUE;
  1937  11   15:9  1130 		      EXTURNAL := FALSE END;
  1938  11   15:7  1136 		  BFSY:=SEMICOLON;
  1939  11   15:7  1139 		  ISSEGMENT:=SEGDEC;
  1940  11   15:7  1142 		  PREVLEXSTACKP:=TOS;
  1941  11   15:6  1146 		 END;
  1942  11   15:5  1146 	      NEW(TOS);
  1943  11   15:5  1151 	      TOS^:=LLEXSTK;
  1944  11   15:5  1157 	      EXIT(PROCDECLARATION);
  1945  11   15:4  1161 	    END;
  1946  11   15:1  1161       WITH LLEXSTK DO  (* FORWARD OR EXTERNAL DECLARATION, SO RESTORE STATE *)
  1947  11   15:2  1161 	BEGIN 
  1948  11   15:3  1161 	  LEVEL:=DOLDLEV; 
  1949  11   15:3  1164 	  TOP:=DOLDTOP;
  1950  11   15:3  1167 	  LC:=DLLC; 
  1951  11   15:3  1170 	  CURPROC:=POLDPROC; 
  1952  11   15:3  1173 	  IF SEGDEC THEN
  1953  11   15:4  1176 	    BEGIN
  1954  11   15:5  1176 	      NEXTPROC:=SOLDPROC;
  1955  11   15:5  1179 	      SEG:=DOLDSEG;
  1956  11   15:4  1182 	    END;
  1957  11   15:2  1182 	END;
  1958  11   15:0  1182      END; (* PROCDECLARATION *)
  1959  11   15:0  1206 
  1960  11   15:0  1206 
  1961  11    1:0     0   BEGIN (*DECLARATIONPART*)
  1962  11    1:1     0     IF (NOSWAP) AND (STARTINGUP) THEN
  1963  11    1:2     7       BEGIN
  1964  11    1:3     7 	STARTINGUP:=FALSE; (* ALL SEGMENTS ARE IN BY THIS TIME *)
  1965  11    1:3    10 	BLOCK(FSYS);
  1966  11    1:3    20 	EXIT(DECLARATIONPART);
  1967  11    1:2    24       END;
  1968  11    1:1    24     IF NOISY THEN
  1969  11    1:2    28       UNITWRITE(3,DUMMYVAR[-1600],35); (*ADJUST DISPLAY OF STACK AND HEAP*)
  1970  11    1:1    43     REPEAT
  1971  11    1:2    43       NOTDONE:=FALSE;
  1972  11    1:2    46       IF USERINFO.STUPID THEN
  1973  11    1:3    51 	IF NOT CODEINSEG THEN
  1974  11    1:4    56 	  IF (LEVEL = 1) AND (NEXTSEG = 10) THEN
  1975  11    1:5    67 	    IF NOT(INMODULE OR USING) THEN USESDECLARATION(TRUE);
  1976  11    1:5    78 	    (*To get turtle graphics*)
  1977  11    1:2    78       IF SY = USESSY THEN
  1978  11    1:3    84 	BEGIN INSYMBOL; USESDECLARATION(FALSE) END;
  1979  11    1:2    90       IF SY = LABELSY THEN
  1980  11    1:3    96 	BEGIN
  1981  11    1:4    96 	  IF INMODULE AND ININTERFACE THEN
  1982  11    1:5   103 	    BEGIN ERROR(186); SKIP(FSYS - [LABELSY]) END
  1983  11    1:4   127 	  ELSE INSYMBOL; LABELDECLARATION END;
  1984  11    1:2   134       IF SY = CONSTSY THEN
  1985  11    1:3   140 	BEGIN INSYMBOL; CONSTDECLARATION END;
  1986  11    1:2   145       IF SY = TYPESY THEN
  1987  11    1:3   151 	BEGIN INSYMBOL; TYPEDECLARATION END;
  1988  11    1:2   156       IF SY = VARSY THEN
  1989  11    1:3   162 	BEGIN INSYMBOL; VARDECLARATION END;
  1990  11    1:2   167       IF LEVEL = 1 THEN GLEV := TOP;
  1991  11    1:2   176       IF SY IN [PROCSY,FUNCSY,PROGSY] THEN
  1992  11    1:3   190 	BEGIN
  1993  11    1:4   190 	  IF INMODULE THEN
  1994  11    1:5   194 	    IF ININTERFACE AND NOT USING THEN PUBLICPROCS := TRUE;
  1995  11    1:4   205 	  REPEAT
  1996  11    1:5   205 	    LSY := SY; INSYMBOL;
  1997  11    1:5   212 	    IF LSY = PROGSY THEN
  1998  11    1:6   217 	      IF INMODULE THEN
  1999  11    1:7   221 		BEGIN ERROR(185 (*SEG DEC NOT ALLOWED IN UNIT*));
  2000  11    1:8   227 		  PROCDECLARATION(PROCSY,FALSE)
  2001  11    1:7   229 		END
  2002  11    1:6   231 	      ELSE PROCDECLARATION(LSY,TRUE)
  2003  11    1:5   235 	    ELSE PROCDECLARATION(LSY,FALSE);
  2004  11    1:4   243 	  UNTIL NOT (SY IN [PROCSY,FUNCSY,PROGSY])
  2005  11    1:3   256 	END;
  2006  11    1:2   259       IF (SY <> BEGINSY) THEN
  2007  11    1:3   265        IF NOT ((USING OR INMODULE) AND (SY IN [IMPLESY,ENDSY]))
  2008  11    1:3   285 	  AND NOT( SY IN [SEPARATSY,UNITSY]) THEN
  2009  11    1:4   304 	 IF (NOT (INCLUDING OR NOTDONE))
  2010  11    1:4   309 	    OR
  2011  11    1:4   309 	    NOT(SY IN BLOCKBEGSYS) THEN
  2012  11    1:5   321 	   BEGIN ERROR(18); SKIP(FSYS - [UNITSY,INTERSY]); END;
  2013  11    1:1   347     UNTIL (SY IN (STATBEGSYS + [SEPARATSY,UNITSY,IMPLESY,ENDSY]));
  2014  11    1:1   369     NEWBLOCK:=FALSE; 
  2015  11    1:0   372   END (*DECLARATIONPART*) ;
  2016  11    1:0   388 
  2017  11    1:0   388 (* --- BODYPART.A.TEXT --- *)
  2018  11    1:0   388 
  2019  11    1:0   388 (*    COPYRIGHT (C) 1979, REGENTS OF THE	*)
  2020  11    1:0   388 (*    UNIVERSITY OF CALIFORNIA, SAN DIEGO	*)
  2021  11    1:0   388 
  2022  12    1:D     1 SEGMENT PROCEDURE BODYPART(FSYS: SETOFSYS; FPROCP: CTP);
  2023  12    1:D     6   
  2024  12    2:D     1   PROCEDURE LINKERREF(KLASS: IDCLASS; ID,ADDR: INTEGER);
  2025  12    2:0     0   BEGIN
  2026  12    2:1     0     IF NREFS > REFSPERBLK THEN (*WRITE BUFFER*)
  2027  12    2:2     9       BEGIN
  2028  12    2:3     9 	IF BLOCKWRITE(REFFILE,REFLIST^,1,REFBLK) <> 1 THEN ERROR(402);
  2029  12    2:3    36 	REFBLK := REFBLK + 1;
  2030  12    2:3    44 	NREFS := 1
  2031  12    2:2    44       END;
  2032  12    2:1    48     WITH REFLIST^[NREFS] DO
  2033  12    2:2    60       BEGIN
  2034  12    2:3    60 	IF KLASS IN VARS THEN KEY := ID + 32
  2035  12    2:3    71 	ELSE (*PROC*) KEY := ID;
  2036  12    2:3    81         OFFSET := SEGINX + ADDR
  2037  12    2:2    84       END;
  2038  12    2:1    87     NREFS := NREFS + 1
  2039  12    2:0    90   END (*LINKERREF*) ;
  2040  12    2:0   108 
  2041  12    3:D     1   PROCEDURE GEN0(FOP: OPRANGE);
  2042  12    3:D     2     VAR I: INTEGER; ODDIC: BOOLEAN;
  2043  12    3:0     0   BEGIN
  2044  12    3:1     0     IF FOP <> 38(*LCA*) THEN GENBYTE(FOP+128)
  2045  12    3:1    10     ELSE
  2046  12    3:2    15       BEGIN 
  2047  12    3:3    15 	ODDIC := ODD(IC); STRGCSTIC := IC;
  2048  12    3:3    21 	IF NOT ODDIC THEN GENBYTE(215(*NOP*));
  2049  12    3:3    31 	GENBYTE(166(*LCA*));
  2050  12    3:3    37 	WITH GATTR.CVAL.VALP^ DO
  2051  12    3:4    40 	  BEGIN GENBYTE(SLGTH);
  2052  12    3:5    45 	    FOR I := 1 TO SLGTH DO GENBYTE(ORD(SVAL[I]));
  2053  12    3:5    74 	    IF ODDIC THEN GENBYTE(215(*NOP*))
  2054  12    3:4    80 	  END
  2055  12    3:2    83 	END
  2056  12    3:0    83   END (*GEN0*) ;
  2057  12    3:0    98 
  2058  12    4:D     1   PROCEDURE GENLDC(IVAL: INTEGER);
  2059  12    4:0     0   BEGIN
  2060  12    4:1     0     IF (IVAL >= 0) AND (IVAL <= 127) THEN GENBYTE(IVAL)
  2061  12    4:1    10     ELSE
  2062  12    4:2    15       BEGIN GENBYTE(51(*LDC*)+148);
  2063  12    4:3    23         GENBYTE( ABS(IVAL) MOD 256 );
  2064  12    4:3    32 	GENBYTE( ABS(IVAL) DIV 256 );
  2065  12    4:3    41 	IF IVAL<0 THEN GEN0(17(*NGI*))
  2066  12    4:2    47       END
  2067  12    4:0    49   END (*GENLDC*) ;
  2068  12    4:0    62 
  2069  12    5:D     1   PROCEDURE GENBIG(IVAL: INTEGER);
  2070  12    5:0     0   BEGIN
  2071  12    5:1     0     IF IVAL <= 127 THEN GENBYTE(IVAL)
  2072  12    5:1     6     ELSE
  2073  12    5:2    11       BEGIN
  2074  12    5:3    11 	GENBYTE( 128+(IVAL DIV 256) );
  2075  12    5:3    23 	GENBYTE( IVAL MOD 256 )
  2076  12    5:2    28       END
  2077  12    5:0    31   END (*GENBIG*) ;
  2078  12    5:0    44 
  2079  12    6:D     1   PROCEDURE GEN1(FOP: OPRANGE; FP2: INTEGER);
  2080  12    6:D     3     LABEL 1;
  2081  12    6:D     3     VAR I,J: INTEGER;
  2082  12    6:0     0   BEGIN
  2083  12    6:1     0     GENBYTE(FOP+128);
  2084  12    6:1     8     IF FOP = 51(*LDC*) THEN
  2085  12    6:2    13       BEGIN
  2086  12    6:3    13 	IF FP2 = 2 THEN I := REALSIZE
  2087  12    6:3    18 	ELSE
  2088  12    6:4    23 	  BEGIN I := 8;
  2089  12    6:5    26 	    WHILE I > 0 DO
  2090  12    6:6    31 	      IF GATTR.CVAL.VALP^.CSTVAL[I] <> 0 THEN GOTO 1
  2091  12    6:6    46 	      ELSE I := I - 1;
  2092  12    6:5    55       1:  END;
  2093  12    6:3    55 	GATTR.TYPTR^.SIZE := I;
  2094  12    6:3    58 	IF I > 1 THEN
  2095  12    6:4    63 	  BEGIN GENBYTE(I);
  2096  12    6:5    67 	    FOR J := I DOWNTO 1 DO GENWORD(GATTR.CVAL.VALP^.CSTVAL[J])
  2097  12    6:4    87 	  END
  2098  12    6:3    97 	ELSE
  2099  12    6:4    99 	  BEGIN IC := IC - 1;
  2100  12    6:5   104 	    IF I = 1 THEN GENLDC(GATTR.CVAL.VALP^.CSTVAL[1])
  2101  12    6:4   118 	  END
  2102  12    6:2   120       END
  2103  12    6:1   120     ELSE
  2104  12    6:2   122       IF FOP IN [30(*CSP*),32(*ADJ*),45(*RNP*),
  2105  12    6:2   123 		 46(*CIP*),60(*LDM*),61(*STM*),
  2106  12    6:2   123 		 65(*RBP*),66(*CBP*),78(*CLP*),
  2107  12    6:2   123 		 42(*SAS*),79(*CGP*)] THEN GENBYTE(FP2)
  2108  12    6:2   141       ELSE
  2109  12    6:3   146 	IF INMODULE AND (FOP IN [37(*LAO*),41(*LDO*),43(*SRO*)]) THEN
  2110  12    6:4   163 	  BEGIN LINKERREF(ACTUALVARS,FP2,IC); GENBYTE(128); GENBYTE(0) END
  2111  12    6:3   178 	ELSE
  2112  12    6:4   180 	  IF ((FOP = 74(*LDL*)) OR (FOP = 41(*LDO*)))
  2113  12    6:4   187 	      AND (FP2 <= 16) THEN
  2114  12    6:5   193 	    BEGIN IC := IC-1;
  2115  12    6:6   198 	      IF FOP = 41(*LDO*) THEN GENBYTE(231+FP2)
  2116  12    6:6   208 	      ELSE GENBYTE(215+FP2)
  2117  12    6:5   218 	    END
  2118  12    6:4   221 	  ELSE
  2119  12    6:5   223 	    IF (FOP = 35(*IND*)) AND (FP2 <= 7) THEN
  2120  12    6:6   232 	      BEGIN IC := IC-1; GENBYTE(248+FP2) END
  2121  12    6:5   245 	    ELSE
  2122  12    6:6   247 	      GENBIG(FP2)
  2123  12    6:0   248   END (*GEN1*) ;
  2124  12    6:0   268 
  2125  12    7:D     1   PROCEDURE GEN2(FOP: OPRANGE; FP1,FP2: INTEGER);
  2126  12    7:0     0   BEGIN
  2127  12    7:1     0     IF (FOP = 64(*IXP*)) OR (FOP = 77(*CXP*)) THEN
  2128  12    7:2     9       BEGIN GENBYTE(FOP+128); GENBYTE(FP1); GENBYTE(FP2);
  2129  12    7:2    25       END
  2130  12    7:1    25     ELSE
  2131  12    7:2    27       IF FOP IN [47(*EQU*),48(*GEQ*),49(*GRT*),
  2132  12    7:2    28 		 52(*LEQ*),53(*LES*),55(*NEQ*)] THEN
  2133  12    7:3    42 	IF FP1 = 0 THEN GEN0(FOP+20)
  2134  12    7:3    50 	ELSE
  2135  12    7:4    54 	  BEGIN GEN1(FOP,FP1+FP1);
  2136  12    7:5    60 	    IF FP1 > 4 THEN GENBIG(FP2)
  2137  12    7:4    66 	  END
  2138  12    7:2    68       ELSE
  2139  12    7:3    70 	BEGIN (*LDA,LOD,STR*)
  2140  12    7:4    70 	  IF FP1 = 0 THEN GEN1(FOP+20,FP2)
  2141  12    7:4    79 	  ELSE
  2142  12    7:5    83 	    BEGIN
  2143  12    7:6    83 	      GENBYTE(FOP+128); GENBYTE(FP1); GENBIG(FP2)
  2144  12    7:5    96 	    END
  2145  12    7:3    98 	END;
  2146  12    7:0    98   END (*GEN2*) ;
  2147  12    7:0   110 
  2148  12    8:D     1   PROCEDURE GENNR(EXTPROC: NONRESIDENT);
  2149  12    8:D     2 
  2150  12    9:D     1    PROCEDURE ASSIGN(EXTPROC: NONRESIDENT);
  2151  12    9:0     0    BEGIN
  2152  12    9:1     0      PROCTABLE[NEXTPROC] := 0;
  2153  12    9:1     9      PFNUMOF[EXTPROC] := NEXTPROC; NEXTPROC := NEXTPROC + 1;
  2154  12    9:1    24      IF NEXTPROC > MAXPROCNUM THEN ERROR(193);(*NOT ENOUGH ROOM FOR THIS*)
  2155  12    9:1    38      CLINKERINFO := TRUE                                  (*OPERATION*)
  2156  12    9:0    38    END (*ASSIGN*) ;
  2157  12    9:0    54 
  2158  12    8:0     0   BEGIN (*GENNR*)
  2159  12    8:1     0     IF PFNUMOF[EXTPROC] = 0 THEN ASSIGN(EXTPROC);
  2160  12    8:1    14     IF SEPPROC THEN
  2161  12    8:2    18       BEGIN
  2162  12    8:3    18 	GEN1(79(*CGP*),0); LINKERREF(PROC,-PFNUMOF[EXTPROC],IC-1)
  2163  12    8:2    34       END
  2164  12    8:1    36     ELSE
  2165  12    8:2    38       GEN1(79(*CGP*),PFNUMOF[EXTPROC]);
  2166  12    8:0    48   END (*GENNR*) ;
  2167  12    8:0    60 
  2168  12   10:D     1   PROCEDURE GENJMP(FOP: OPRANGE; FLBP: LBP);
  2169  12   10:D     3     VAR DISP: INTEGER;
  2170  12   10:0     0   BEGIN
  2171  12   10:1     0     WITH FLBP^ DO
  2172  12   10:2     3       IF DEFINED THEN
  2173  12   10:3     7 	BEGIN
  2174  12   10:4     7 	  GENBYTE(FOP+128);
  2175  12   10:4    15 	  DISP := OCCURIC-IC-1;
  2176  12   10:4    23 	  IF (DISP >= 0) AND (DISP <= 127) THEN GENBYTE(DISP)
  2177  12   10:4    33 	  ELSE
  2178  12   10:5    38 	    BEGIN
  2179  12   10:6    38 	      IF JTABINX = 0 THEN
  2180  12   10:7    44 		BEGIN JTABINX := NEXTJTAB;
  2181  12   10:8    51 		  IF NEXTJTAB = MAXJTAB THEN ERROR(253)
  2182  12   10:8    61 		  ELSE NEXTJTAB := NEXTJTAB + 1;
  2183  12   10:8    74 		  JTAB[JTABINX] := OCCURIC
  2184  12   10:7    81 		END;
  2185  12   10:6    84 	      DISP := -JTABINX;
  2186  12   10:6    89 	      GENBYTE(248-JTABINX-JTABINX)
  2187  12   10:5    98 	    END;
  2188  12   10:3   101 	END
  2189  12   10:2   101       ELSE
  2190  12   10:3   103 	BEGIN MOVELEFT(REFLIST,CODEP^[IC],2);
  2191  12   10:4   112 	  IF FOP = 57(*UJP*) THEN DISP := IC + 4096
  2192  12   10:4   118 	  ELSE DISP := IC;
  2193  12   10:4   129 	  REFLIST := DISP; IC := IC+2
  2194  12   10:3   135 	END;
  2195  12   10:0   139   END (*GENJMP*) ;
  2196  12   10:0   152 
  2197  12   11:D     1   PROCEDURE LOAD; FORWARD;
  2198  12   11:D     1 
  2199  12   12:D     1   PROCEDURE GENFJP(FLBP: LBP);
  2200  12   12:0     0   BEGIN LOAD;
  2201  12   12:1     2     IF GATTR.TYPTR <> BOOLPTR THEN ERROR(135);
  2202  12   12:1    14     GENJMP(33(*FJP*),FLBP)
  2203  12   12:0    16   END (*GENFJP*) ;
  2204  12   12:0    30 
  2205  12   13:D     1   PROCEDURE GENLABEL(VAR FLBP: LBP);
  2206  12   13:0     0   BEGIN NEW(FLBP);
  2207  12   13:1     4     WITH FLBP^ DO
  2208  12   13:2     8       BEGIN DEFINED := FALSE; REFLIST := MAXADDR END
  2209  12   13:0    18   END (*GENLABEL*) ;
  2210  12   13:0    30 
  2211  12   14:D     1   PROCEDURE PUTLABEL(FLBP: LBP);
  2212  12   14:D     2     VAR LREF: INTEGER; LOP: OPRANGE;
  2213  12   14:0     0   BEGIN
  2214  12   14:1     0     WITH FLBP^ DO
  2215  12   14:2     3       BEGIN LREF := REFLIST;
  2216  12   14:3     7 	DEFINED := TRUE; OCCURIC := IC; JTABINX := 0;
  2217  12   14:3    20 	WHILE LREF < MAXADDR DO
  2218  12   14:4    27 	  BEGIN
  2219  12   14:5    27 	    IF LREF >= 4096 THEN
  2220  12   14:6    34 	      BEGIN LREF := LREF - 4096; LOP := 57(*UJP*) END
  2221  12   14:5    44 	    ELSE LOP := 33(*FJP*);
  2222  12   14:5    49 	    IC := LREF;
  2223  12   14:5    52 	    MOVELEFT(CODEP^[IC],LREF,2);
  2224  12   14:5    60 	    GENJMP(LOP,FLBP)
  2225  12   14:4    62 	  END;
  2226  12   14:3    66 	IC := OCCURIC
  2227  12   14:2    66       END
  2228  12   14:0    70   END (*PUTLABEL*) ;
  2229  12   14:0    84 
  2230  12   11:D     1   PROCEDURE LOAD;
  2231  12   11:D     1   VAR J,M: INTEGER;
  2232  12   11:0     0   BEGIN
  2233  12   11:1     0     WITH GATTR DO
  2234  12   11:2     0       IF TYPTR <> NIL THEN
  2235  12   11:3     5 	BEGIN
  2236  12   11:4     5 	  CASE KIND OF
  2237  12   11:4     8 	    CST:   IF TYPTR^.FORM = LONGINT THEN
  2238  12   11:6    14 		     WITH GATTR.CVAL.VALP^ DO
  2239  12   11:7    17 		       BEGIN
  2240  12   11:8    17 			 M := 10000;
  2241  12   11:8    22 			 GENLDC(LONGVAL[1]); GENLDC(18(*DCVT*)); GENNR(DECOPS);
  2242  12   11:8    39 			 FOR J := 2 TO LLENG DO
  2243  12   11:9    51 			   BEGIN 
  2244  12   11:0    51 			     IF J = LLENG THEN M := TRUNC(PWROFTEN(LLAST));
  2245  12   11:0    65 			     GENLDC(M); GENLDC(18(*DCVT*)); GENNR(DECOPS);
  2246  12   11:0    74 			     GENLDC(8(*DMP*)); GENNR(DECOPS);
  2247  12   11:0    80 			     GENLDC(LONGVAL[J]);
  2248  12   11:0    91 			     GENLDC(18(*DCVT*)); GENNR(DECOPS);
  2249  12   11:0    97 			     GENLDC(2(*DAD*)); GENNR(DECOPS)
  2250  12   11:9   101 			   END
  2251  12   11:7   103 		       END
  2252  12   11:5   110 		   ELSE
  2253  12   11:6   112 		     IF (TYPTR^.FORM = SCALAR) AND (TYPTR <> REALPTR) THEN
  2254  12   11:7   123 		       GENLDC(CVAL.IVAL)
  2255  12   11:6   124 		     ELSE
  2256  12   11:7   128 		       IF TYPTR = NILPTR THEN GEN0(31(*LDCN*))
  2257  12   11:7   135 		       ELSE
  2258  12   11:8   139 			 IF TYPTR = REALPTR THEN GEN1(51(*LDC*),2)
  2259  12   11:8   147 			 ELSE GEN1(51(*LDC*),5);
  2260  12   11:4   157 	    VARBL: CASE ACCESS OF
  2261  12   11:5   160 		     DRCT:   IF VLEVEL = 1 THEN GEN1(41(*LDO*),DPLMT)
  2262  12   11:6   167 			     ELSE GEN2(54(*LOD*),LEVEL-VLEVEL,DPLMT);
  2263  12   11:5   181 		     INDRCT: GEN1(35(*IND*),IDPLMT);
  2264  12   11:5   187 		     PACKD:  GEN0(58(*LDP*));
  2265  12   11:5   192 		     MULTI:  GEN1(60(*LDM*),TYPTR^.SIZE);
  2266  12   11:5   199 		     BYTE:   GEN0(62(*LDB*))
  2267  12   11:5   200 		   END;
  2268  12   11:4   224 	    EXPR:
  2269  12   11:4   224 	  END;
  2270  12   11:4   240 	  WITH TYPTR^ DO
  2271  12   11:5   243 	    IF ((FORM = POWER) OR
  2272  12   11:5   247 	       (FORM = LONGINT) AND (KIND <> CST))
  2273  12   11:5   256 	       AND (KIND <> EXPR) THEN GENLDC(TYPTR^.SIZE);
  2274  12   11:4   266 	  KIND := EXPR
  2275  12   11:3   266 	END
  2276  12   11:0   269   END (*LOAD*) ;
  2277  12   11:0   288 
  2278  12   15:D     1   PROCEDURE STORE(VAR FATTR: ATTR);
  2279  12   15:0     0   BEGIN
  2280  12   15:1     0     WITH FATTR DO
  2281  12   15:2     3       IF TYPTR <> NIL THEN
  2282  12   15:3     9 	CASE ACCESS OF
  2283  12   15:3    13 	  DRCT:   IF VLEVEL = 1 THEN GEN1(43(*SRO*),DPLMT)
  2284  12   15:4    22 		  ELSE GEN2(56(*STR*),LEVEL-VLEVEL,DPLMT);
  2285  12   15:3    38 	  INDRCT: IF IDPLMT <> 0 THEN ERROR(400)
  2286  12   15:4    47 		  ELSE GEN0(26(*STO*));
  2287  12   15:3    57 	  PACKD:  GEN0(59(*STP*));
  2288  12   15:3    62 	  MULTI:  GEN1(61(*STM*),TYPTR^.SIZE);
  2289  12   15:3    70 	  BYTE:   GEN0(63(*STB*))
  2290  12   15:3    71 	END
  2291  12   15:0    92   END (*STORE*) ;
  2292  12   15:0   104 
  2293  12   16:D     1   PROCEDURE LOADADDRESS;
  2294  12   16:0     0   BEGIN
  2295  12   16:1     0     WITH GATTR DO
  2296  12   16:2     0       IF TYPTR <> NIL THEN
  2297  12   16:3     5 	BEGIN
  2298  12   16:4     5 	  CASE KIND OF
  2299  12   16:4     8 	    CST:   IF STRGTYPE(TYPTR) THEN GEN0(38(*LCA*))
  2300  12   16:5    17 		   ELSE ERROR(400);
  2301  12   16:4    29 	    VARBL: CASE ACCESS OF
  2302  12   16:5    32 		     DRCT:   IF VLEVEL = 1 THEN GEN1(37(*LAO*),DPLMT)
  2303  12   16:6    39 			     ELSE GEN2(50(*LDA*),LEVEL-VLEVEL,DPLMT);
  2304  12   16:5    53 		     INDRCT: IF IDPLMT <> 0 THEN GEN1(34(*INC*),IDPLMT);
  2305  12   16:5    64 		     PACKD:  ERROR(103)
  2306  12   16:5    65 		   END
  2307  12   16:4    84 	  END;
  2308  12   16:4    98 	  KIND := VARBL; ACCESS := INDRCT; IDPLMT := 0
  2309  12   16:3   104 	END
  2310  12   16:0   107   END (*LOADADDRESS*) ;
  2311  12   16:0   120 
  2312  12   17:D     1   PROCEDURE BYTEADDRESS;
  2313  12   17:0     0   BEGIN
  2314  12   17:1     0     WITH GATTR DO
  2315  12   17:2     0       IF TYPTR <> NIL THEN
  2316  12   17:3     5 	BEGIN
  2317  12   17:4     5 	  CASE KIND OF
  2318  12   17:4     8 	    CST:   IF STRGTYPE(TYPTR) THEN GEN0(38(*LCA*))
  2319  12   17:5    17 		   ELSE ERROR(400);
  2320  12   17:4    29 	    VARBL: CASE ACCESS OF
  2321  12   17:5    32 		     DRCT:   IF VLEVEL = 1 THEN GEN1(37(*LAO*),DPLMT)
  2322  12   17:6    39 			     ELSE GEN2(50(*LDA*),LEVEL-VLEVEL,DPLMT);
  2323  12   17:5    53 		     INDRCT: IF IDPLMT <> 0 THEN GEN1(34(*INC*),IDPLMT);
  2324  12   17:5    64 		     PACKD:  ERROR(103)
  2325  12   17:5    65 		   END
  2326  12   17:4    84 	  END;
  2327  12   17:4    98 	  IF KIND <> VARBL THEN BEGIN KIND := VARBL; GENLDC(0) END
  2328  12   17:4   109 	  ELSE
  2329  12   17:5   111 	    IF ACCESS <> BYTE THEN GENLDC(0);
  2330  12   17:4   119 	  ACCESS := BYTE;
  2331  12   17:3   122 	END
  2332  12   17:0   122   END (*BYTEADDRESS*) ;
  2333  12   17:0   134 
  2334  12   18:D     1   PROCEDURE STRGTOPA(FIC: ADDRRANGE);
  2335  12   18:0     0     BEGIN
  2336  12   18:1     0       IF ODD(FIC) THEN
  2337  12   18:2     3 	BEGIN
  2338  12   18:3     3 	  MOVERIGHT( CODEP^[FIC+1], CODEP^[FIC+2], ORD(CODEP^[FIC+1])+1 );
  2339  12   18:3    20 	  CODEP^[FIC] := CHR(215(*NOP*)); CODEP^[FIC+1] := CHR(208(*LPA*))
  2340  12   18:2    33 	END
  2341  12   18:1    34       ELSE
  2342  12   18:2    36 	BEGIN
  2343  12   18:3    36 	  MOVELEFT( CODEP^[FIC+2], CODEP^[FIC+1], ORD(CODEP^[FIC+2])+1 );
  2344  12   18:3    53 	  CODEP^[FIC] := CHR(208); CODEP^[FIC+ORD(CODEP^[FIC+1])+2] := CHR(215)
  2345  12   18:2    72 	END
  2346  12   18:0    73     END (*STRGTOPA*) ;
  2347  12   18:0    86 
  2348  12   19:D     1   PROCEDURE EXPRESSION(FSYS: SETOFSYS); FORWARD;
  2349  12   19:D     5 
  2350  12   20:D     1   PROCEDURE SELECTOR(FSYS: SETOFSYS; FCP: CTP);
  2351  12   20:D     6     VAR LATTR: ATTR; LCP: CTP; LMIN,LMAX: INTEGER;
  2352  12   20:0     0   BEGIN
  2353  12   20:1     0     WITH FCP^, GATTR DO
  2354  12   20:2     3       BEGIN TYPTR := IDTYPE; KIND := VARBL;
  2355  12   20:3    10 	CASE KLASS OF
  2356  12   20:3    15 	  ACTUALVARS:
  2357  12   20:4    15 	    BEGIN VLEVEL := VLEV; DPLMT := VADDR; ACCESS := DRCT;
  2358  12   20:5    28 	      IF INMODULE THEN
  2359  12   20:6    32 		IF TYPTR <> NIL THEN
  2360  12   20:7    37 		  IF (VLEV = 1) AND (TYPTR^.FORM = RECORDS) THEN LOADADDRESS
  2361  12   20:4    49 	    END;
  2362  12   20:3    53 	  FORMALVARS:
  2363  12   20:4    53 	    BEGIN
  2364  12   20:5    53 	      IF VLEV = 1 THEN GEN1(41(*LDO*),VADDR)
  2365  12   20:5    64 	      ELSE GEN2(54(*LOD*),LEVEL-VLEV,VADDR);
  2366  12   20:5    80 	      ACCESS := INDRCT; IDPLMT := 0
  2367  12   20:4    83 	    END;
  2368  12   20:3    88 	  FIELD:
  2369  12   20:4    88 	    WITH DISPLAY[DISX] DO
  2370  12   20:5    96 	     BEGIN
  2371  12   20:6    96 	      IF OCCUR = CREC THEN
  2372  12   20:7   102 		BEGIN ACCESS := DRCT; VLEVEL := CLEV;
  2373  12   20:8   109 		  DPLMT := CDSPL + FLDADDR
  2374  12   20:7   111 		END
  2375  12   20:6   117 	      ELSE
  2376  12   20:7   119 		BEGIN
  2377  12   20:8   119 		  IF LEVEL = 1 THEN GEN1(41(*LDO*),VDSPL)
  2378  12   20:8   128 		  ELSE GEN2(54(*LOD*),0,VDSPL);
  2379  12   20:8   138 		  ACCESS := INDRCT; IDPLMT := FLDADDR
  2380  12   20:7   141 		END;
  2381  12   20:6   146 	      IF FISPACKD THEN
  2382  12   20:7   151 		BEGIN LOADADDRESS;
  2383  12   20:8   153 		  ACCESS := PACKD;
  2384  12   20:8   156 		  GENLDC(FLDWIDTH); GENLDC(FLDRBIT)
  2385  12   20:7   164 		END
  2386  12   20:5   166 	     END;
  2387  12   20:3   168 	  FUNC:
  2388  12   20:4   168 	    IF PFDECKIND <> DECLARED THEN ERROR(150)
  2389  12   20:4   178 	    ELSE
  2390  12   20:5   183 	      IF NOT INSCOPE THEN ERROR(103)
  2391  12   20:5   190 	      ELSE
  2392  12   20:6   195 		  BEGIN ACCESS := DRCT; VLEVEL := PFLEV + 1;
  2393  12   20:7   205 		    DPLMT := LCAFTERMARKSTACK
  2394  12   20:6   205 		  END
  2395  12   20:3   208 	END (*CASE*);
  2396  12   20:3   228 	IF TYPTR <> NIL THEN
  2397  12   20:4   233 	  IF (TYPTR^.FORM <= POWER) AND
  2398  12   20:4   237 	     (TYPTR^.SIZE > PTRSIZE) THEN
  2399  12   20:5   244 	    BEGIN LOADADDRESS; ACCESS := MULTI END
  2400  12   20:2   249       END (*WITH*);
  2401  12   20:1   249     IF NOT (SY IN SELECTSYS + FSYS) THEN
  2402  12   20:2   266       BEGIN ERROR(59); SKIP(SELECTSYS + FSYS) END;
  2403  12   20:1   286     WHILE SY IN SELECTSYS DO
  2404  12   20:2   296       BEGIN
  2405  12   20:3   296   (*[*) IF SY = LBRACK THEN
  2406  12   20:4   302 	  BEGIN
  2407  12   20:5   302 	    REPEAT LATTR := GATTR;
  2408  12   20:6   308 	      WITH LATTR DO
  2409  12   20:7   308 		IF TYPTR <> NIL THEN
  2410  12   20:8   313 		  IF TYPTR^.FORM <> ARRAYS THEN
  2411  12   20:9   319 		    BEGIN ERROR(138); TYPTR := NIL END;
  2412  12   20:6   328 	      LOADADDRESS;
  2413  12   20:6   330 	      INSYMBOL; EXPRESSION(FSYS + [COMMA,RBRACK]);
  2414  12   20:6   350 	      LOAD;
  2415  12   20:6   352 	      IF GATTR.TYPTR <> NIL THEN
  2416  12   20:7   357 		IF GATTR.TYPTR^.FORM <> SCALAR THEN ERROR(113);
  2417  12   20:6   367 	      IF LATTR.TYPTR <> NIL THEN
  2418  12   20:7   372 		WITH LATTR.TYPTR^ DO
  2419  12   20:8   375 		  BEGIN
  2420  12   20:9   375 		    IF COMPTYPES(INXTYPE,GATTR.TYPTR) THEN
  2421  12   20:0   385 		      BEGIN
  2422  12   20:1   385 			IF (INXTYPE <> NIL) AND
  2423  12   20:1   389 			    NOT STRGTYPE(LATTR.TYPTR) THEN
  2424  12   20:2   399 			  BEGIN GETBOUNDS(INXTYPE,LMIN,LMAX);
  2425  12   20:3   408 			    IF RANGECHECK THEN
  2426  12   20:4   412 			      BEGIN GENLDC(LMIN); GENLDC(LMAX);
  2427  12   20:5   418 				GEN0(8(*CHK*))
  2428  12   20:4   419 			      END;
  2429  12   20:3   421 			    IF LMIN <> 0 THEN
  2430  12   20:4   426 			      BEGIN GENLDC(ABS(LMIN));
  2431  12   20:5   430 				IF LMIN > 0 THEN GEN0(21(*SBI*))
  2432  12   20:5   436 				ELSE GEN0(2(*ADI*))
  2433  12   20:4   441 			      END
  2434  12   20:2   443 			  END
  2435  12   20:0   443 		      END
  2436  12   20:9   443 		    ELSE ERROR(139);
  2437  12   20:9   451 		    WITH GATTR DO
  2438  12   20:0   451 		      BEGIN TYPTR := AELTYPE; KIND := VARBL;
  2439  12   20:1   458 			ACCESS := INDRCT; IDPLMT := 0;
  2440  12   20:1   464 			IF TYPTR <> NIL THEN
  2441  12   20:2   469 			  IF AISPACKD THEN
  2442  12   20:3   473 			    IF ELWIDTH = 8 THEN
  2443  12   20:4   479 			      BEGIN ACCESS := BYTE;
  2444  12   20:5   482 				IF STRGTYPE(LATTR.TYPTR) AND RANGECHECK THEN
  2445  12   20:6   493 				  GEN0(27(*IXS*))
  2446  12   20:5   494 				ELSE (*LEAVE BASE-INDEX PAIR*)
  2447  12   20:4   498 			      END
  2448  12   20:3   498 			    ELSE
  2449  12   20:4   500 			      BEGIN ACCESS := PACKD;
  2450  12   20:5   503 				GEN2(64(*IXP*),ELSPERWD,ELWIDTH)
  2451  12   20:4   508 			      END
  2452  12   20:2   510 			  ELSE
  2453  12   20:3   512 			    BEGIN GEN1(36(*IXA*),TYPTR^.SIZE);
  2454  12   20:4   517 			      IF (TYPTR^.FORM <= POWER) AND
  2455  12   20:4   521 				 (TYPTR^.SIZE > PTRSIZE) THEN
  2456  12   20:5   528 				ACCESS := MULTI
  2457  12   20:3   528 			    END
  2458  12   20:0   531 		      END
  2459  12   20:8   531 		  END
  2460  12   20:5   531 	    UNTIL SY <> COMMA;
  2461  12   20:5   537 	    IF SY = RBRACK THEN INSYMBOL ELSE ERROR(12)
  2462  12   20:4   549 	  END (*IF SY = LBRACK*)
  2463  12   20:3   552 	ELSE
  2464  12   20:4   554   (*.*)   IF SY = PERIOD THEN
  2465  12   20:5   560 	    BEGIN
  2466  12   20:6   560 	      WITH GATTR DO
  2467  12   20:7   560 		BEGIN
  2468  12   20:8   560 		  IF TYPTR <> NIL THEN
  2469  12   20:9   565 		    IF TYPTR^.FORM <> RECORDS THEN
  2470  12   20:0   571 		      BEGIN ERROR(140); TYPTR := NIL END;
  2471  12   20:8   580 		  INSYMBOL;
  2472  12   20:8   583 		  IF SY = IDENT THEN
  2473  12   20:9   589 		    BEGIN
  2474  12   20:0   589 		      IF TYPTR <> NIL THEN
  2475  12   20:1   594 			BEGIN SEARCHSECTION(TYPTR^.FSTFLD,LCP);
  2476  12   20:2   601 			  IF LCP = NIL THEN
  2477  12   20:3   606 			    BEGIN ERROR(152); TYPTR := NIL END
  2478  12   20:2   615 			  ELSE
  2479  12   20:3   617 			    WITH LCP^ DO
  2480  12   20:4   620 			      BEGIN TYPTR := IDTYPE;
  2481  12   20:5   624 				CASE ACCESS OF
  2482  12   20:5   627 				  DRCT:   DPLMT := DPLMT + FLDADDR;
  2483  12   20:5   636 				  INDRCT: IDPLMT := IDPLMT + FLDADDR;
  2484  12   20:5   645 				  MULTI,BYTE,
  2485  12   20:5   645 				  PACKD:  ERROR(400)
  2486  12   20:5   648 				END (*CASE ACCESS*);
  2487  12   20:5   670 				IF FISPACKD THEN
  2488  12   20:6   675 				  BEGIN LOADADDRESS;
  2489  12   20:7   677 				    ACCESS := PACKD;
  2490  12   20:7   680 				    GENLDC(FLDWIDTH); GENLDC(FLDRBIT)
  2491  12   20:6   688 				  END;
  2492  12   20:5   690 				IF TYPTR <> NIL THEN
  2493  12   20:6   695 				  IF (TYPTR^.FORM <= POWER) AND
  2494  12   20:6   699 				     (TYPTR^.SIZE > PTRSIZE) THEN
  2495  12   20:7   706 				    BEGIN LOADADDRESS; ACCESS := MULTI END
  2496  12   20:4   711 			      END
  2497  12   20:1   711 			END;
  2498  12   20:0   711 		      INSYMBOL
  2499  12   20:9   711 		    END (*SY = IDENT*)
  2500  12   20:8   714 		  ELSE ERROR(2)
  2501  12   20:7   717 		END (*WITH GATTR*)
  2502  12   20:5   720 	    END (*IF SY = PERIOD*)
  2503  12   20:4   720 	  ELSE
  2504  12   20:5   722   (*^*)     BEGIN
  2505  12   20:6   722 	      IF GATTR.TYPTR <> NIL THEN
  2506  12   20:7   727 		WITH GATTR,TYPTR^ DO
  2507  12   20:8   730 		  IF (FORM = POINTER) OR (FORM = FILES) THEN
  2508  12   20:9   741 		    BEGIN LOAD; KIND := VARBL;
  2509  12   20:0   746 		      ACCESS := INDRCT; IDPLMT := 0;
  2510  12   20:0   752 		      IF FORM = POINTER THEN TYPTR := ELTYPE
  2511  12   20:0   758 		      ELSE
  2512  12   20:1   764 			BEGIN TYPTR := FILTYPE;
  2513  12   20:2   768 			  IF TYPTR = NIL THEN ERROR(399)
  2514  12   20:1   776 			END;
  2515  12   20:0   779 		      IF TYPTR <> NIL THEN
  2516  12   20:1   784 			IF (TYPTR^.FORM <= POWER) AND
  2517  12   20:1   788 			   (TYPTR^.SIZE > PTRSIZE) THEN
  2518  12   20:2   795 				ACCESS := MULTI
  2519  12   20:9   795 		    END
  2520  12   20:8   798 		  ELSE ERROR(141);
  2521  12   20:6   806 	      INSYMBOL
  2522  12   20:5   806 	    END;
  2523  12   20:3   809         IF NOT (SY IN FSYS + SELECTSYS) THEN
  2524  12   20:4   826           BEGIN ERROR(6); SKIP(FSYS + SELECTSYS) END
  2525  12   20:2   846       END (*WHILE*)
  2526  12   20:2   846 
  2527  12   20:0   846   END (*SELECTOR*) ;
  2528  12   20:0   878 
  2529  12   20:0   878 (* --- BODYPART.B.TEXT --- *)
  2530  12   20:0   878 
  2531  12   20:0   878 (*    COPYRIGHT (C) 1979, REGENTS OF THE	*)
  2532  12   20:0   878 (*    UNIVERSITY OF CALIFORNIA, SAN DIEGO	*)
  2533  12   20:0   878 
  2534  12   21:D     1   PROCEDURE CALL(FSYS: SETOFSYS; FCP: CTP);
  2535  12   21:D     6     VAR LKEY: 1..43; WASLPARENT: BOOLEAN;
  2536  12   21:D     8 
  2537  12   22:D     1     PROCEDURE VARIABLE(FSYS: SETOFSYS);
  2538  12   22:D     5       VAR LCP: CTP;
  2539  12   22:0     0     BEGIN
  2540  12   22:1     0       IF SY = IDENT THEN
  2541  12   22:2     6 	BEGIN SEARCHID(VARS+[FIELD],LCP); INSYMBOL END
  2542  12   22:1    22       ELSE BEGIN ERROR(2); LCP := UVARPTR END;
  2543  12   22:1    32       SELECTOR(FSYS,LCP)
  2544  12   22:0    40     END (*VARIABLE*) ;
  2545  12   22:0    54 
  2546  12   23:D     1     PROCEDURE STRGVAR(FSYS: SETOFSYS; MUSTBEVAR: BOOLEAN);
  2547  12   23:0     0     BEGIN EXPRESSION(FSYS);
  2548  12   23:1     9       WITH GATTR DO
  2549  12   23:2     9 	IF ((KIND = CST) AND (TYPTR = CHARPTR))
  2550  12   23:2    17 	    OR STRGTYPE(TYPTR) THEN
  2551  12   23:3    26 	  IF KIND = VARBL THEN LOADADDRESS
  2552  12   23:3    31 	  ELSE
  2553  12   23:4    35 	    BEGIN
  2554  12   23:5    35 	      IF MUSTBEVAR THEN ERROR(154);
  2555  12   23:5    44 	      IF KIND = CST THEN
  2556  12   23:6    49 		BEGIN
  2557  12   23:7    49 		  IF TYPTR = CHARPTR THEN
  2558  12   23:8    55 		    BEGIN
  2559  12   23:9    55 		      WITH SCONST^ DO
  2560  12   23:0    59 			BEGIN CCLASS := STRG; SLGTH := 1;
  2561  12   23:1    67 			  SVAL[1] := CHR(CVAL.IVAL)
  2562  12   23:0    74 			END;
  2563  12   23:9    75 		      CVAL.VALP := SCONST;
  2564  12   23:9    79 		      NEW(TYPTR,ARRAYS,TRUE,TRUE);
  2565  12   23:9    84 		      TYPTR^ := STRGPTR^;
  2566  12   23:9    89 		      TYPTR^.MAXLENG := 1
  2567  12   23:8    92 		    END;
  2568  12   23:7    94 		  LOADADDRESS
  2569  12   23:6    94 		END
  2570  12   23:4    96 	    END
  2571  12   23:2    96 	ELSE
  2572  12   23:3    98 	  BEGIN
  2573  12   23:4    98 	    IF GATTR.TYPTR <> NIL THEN ERROR(125);
  2574  12   23:4   107 	    GATTR.TYPTR := STRGPTR
  2575  12   23:3   107 	  END
  2576  12   23:0   111     END (*STRGVAR*) ;
  2577  12   23:0   124 
  2578  12   24:D     1     PROCEDURE ROUTINE(LKEY: INTEGER);
  2579  12   24:D     2 
  2580  12   25:D     1       PROCEDURE NEWSTMT;
  2581  12   25:D     1 	LABEL 1;
  2582  12   25:D     1 	VAR LSP,LSP1: STP; VARTS,LMIN,LMAX: INTEGER;
  2583  12   25:D     6 	    LSIZE,LSZ: ADDRRANGE; LVAL: VALU;
  2584  12   25:0     0       BEGIN VARIABLE(FSYS + [COMMA,RPARENT]); LOADADDRESS;
  2585  12   25:1    15 	LSP := NIL; VARTS := 0; LSIZE := 0;
  2586  12   25:1    24 	IF GATTR.TYPTR <> NIL THEN
  2587  12   25:2    29 	  WITH GATTR.TYPTR^ DO
  2588  12   25:3    32 	    IF FORM = POINTER THEN
  2589  12   25:4    38 	      BEGIN
  2590  12   25:5    38 		IF ELTYPE <> NIL THEN
  2591  12   25:6    44 		  WITH ELTYPE^ DO
  2592  12   25:7    48 		    BEGIN LSIZE := SIZE;
  2593  12   25:8    52 		      IF FORM = RECORDS THEN LSP := RECVAR
  2594  12   25:7    58 		    END
  2595  12   25:4    62 	      END
  2596  12   25:3    62 	    ELSE ERROR(116);
  2597  12   25:1    68 	WHILE SY = COMMA DO
  2598  12   25:2    74 	  BEGIN INSYMBOL;
  2599  12   25:3    77 	    CONSTANT(FSYS + [COMMA,RPARENT],LSP1,LVAL);
  2600  12   25:3    95 	    VARTS := VARTS + 1;
  2601  12   25:3   100 	    IF LSP = NIL THEN ERROR(158)
  2602  12   25:3   108 	    ELSE
  2603  12   25:4   113 	      IF LSP^.FORM <> TAGFLD THEN ERROR(162)
  2604  12   25:4   122 	      ELSE
  2605  12   25:5   127 		IF LSP^.TAGFIELDP <> NIL THEN
  2606  12   25:6   133 		  IF STRGTYPE(LSP1) OR (LSP1 = REALPTR) THEN ERROR(159)
  2607  12   25:6   149 		  ELSE
  2608  12   25:7   154 		    IF COMPTYPES(LSP^.TAGFIELDP^.IDTYPE,LSP1) THEN
  2609  12   25:8   165 		      BEGIN
  2610  12   25:9   165 			LSP1 := LSP^.FSTVAR;
  2611  12   25:9   169 			WHILE LSP1 <> NIL DO
  2612  12   25:0   174 			  WITH LSP1^ DO
  2613  12   25:1   177 			    IF VARVAL.IVAL = LVAL.IVAL THEN
  2614  12   25:2   183 			      BEGIN LSIZE := SIZE; LSP := SUBVAR;
  2615  12   25:3   191 				GOTO 1
  2616  12   25:2   193 			      END
  2617  12   25:1   193 			    ELSE LSP1 := NXTVAR;
  2618  12   25:9   201 			LSIZE := LSP^.SIZE; LSP := NIL;
  2619  12   25:8   208 		      END
  2620  12   25:7   208 		    ELSE ERROR(116);
  2621  12   25:3   214       1:  END (*WHILE*) ;
  2622  12   25:1   216 	GENLDC(LSIZE);
  2623  12   25:1   219 	GEN1(30(*CSP*),1(*NEW*))
  2624  12   25:0   221       END (*NEWSTMT*) ;
  2625  12   25:0   242 
  2626  12   26:D     1       PROCEDURE MOVE;
  2627  12   26:0     0       BEGIN VARIABLE(FSYS + [COMMA]); BYTEADDRESS;
  2628  12   26:1    15 	IF SY = COMMA THEN INSYMBOL ELSE ERROR(20);
  2629  12   26:1    30 	IF LKEY = 27 THEN
  2630  12   26:2    37 	  BEGIN EXPRESSION(FSYS + [COMMA]); LOAD END
  2631  12   26:1    52 	ELSE
  2632  12   26:2    54 	  BEGIN VARIABLE(FSYS + [COMMA]); BYTEADDRESS END;
  2633  12   26:1    69 	IF SY = COMMA THEN INSYMBOL ELSE ERROR(20);
  2634  12   26:1    84 	EXPRESSION(FSYS + [RPARENT]); LOAD;
  2635  12   26:1    99 	IF LKEY = 27 THEN GEN1(30(*CSP*),10(*FLC*))
  2636  12   26:1   108 	ELSE
  2637  12   26:2   112 	  IF LKEY = 21 THEN GEN1(30(*CSP*),2(*MVL*))
  2638  12   26:2   121 	  ELSE GEN1(30(*CSP*),3(*MVR*))
  2639  12   26:0   127       END (*MOVE*) ;
  2640  12   26:0   142 
  2641  12   27:D     1       PROCEDURE EXIT;
  2642  12   27:D     1 	VAR LCP: CTP;
  2643  12   27:0     0       BEGIN
  2644  12   27:1     0 	IF SY = IDENT THEN
  2645  12   27:2     6 	  BEGIN SEARCHID([PROC,FUNC],LCP); INSYMBOL END
  2646  12   27:1    18 	ELSE
  2647  12   27:2    20 	  IF (SY = PROGSY) THEN
  2648  12   27:3    26 	    BEGIN LCP := OUTERBLOCK; INSYMBOL END
  2649  12   27:2    33 	  ELSE LCP := NIL;
  2650  12   27:1    38 	IF LCP <> NIL THEN
  2651  12   27:2    43 	  IF LCP^.PFDECKIND = DECLARED THEN
  2652  12   27:3    50 	    BEGIN GENLDC(LCP^.PFSEG); GENLDC(LCP^.PFNAME);
  2653  12   27:4    60 	      IF INMODULE THEN
  2654  12   27:5    64 		BEGIN LINKERREF(PROC,LCP^.PFSEG,IC-2);
  2655  12   27:6    73 		  IF SEPPROC THEN LINKERREF(PROC,-LCP^.PFNAME,IC-1);
  2656  12   27:5    87 		END
  2657  12   27:3    87 	    END
  2658  12   27:2    87 	  ELSE ERROR(125)
  2659  12   27:1    90 	ELSE ERROR(125);
  2660  12   27:1    99 	GEN1(30(*CSP*),4(*XIT*))
  2661  12   27:0   101       END (*EXIT*) ;
  2662  12   27:0   116 
  2663  12   28:D     1       PROCEDURE UNITIO;
  2664  12   28:0     0       BEGIN
  2665  12   28:1     0 	IF GATTR.TYPTR <> INTPTR THEN ERROR(125);
  2666  12   28:1     9 	IF SY = COMMA THEN INSYMBOL ELSE ERROR(20);
  2667  12   28:1    24 	VARIABLE(FSYS + [COMMA]); BYTEADDRESS;
  2668  12   28:1    39 	IF SY = COMMA THEN INSYMBOL ELSE ERROR(20);
  2669  12   28:1    54 	EXPRESSION(FSYS + [COMMA,RPARENT]); LOAD;
  2670  12   28:1    69 	IF GATTR.TYPTR <> INTPTR THEN ERROR(125);
  2671  12   28:1    78 	IF SY = COMMA THEN
  2672  12   28:2    84 	  BEGIN INSYMBOL;
  2673  12   28:3    87 	    IF SY = COMMA THEN GENLDC(0)
  2674  12   28:3    94 	    ELSE
  2675  12   28:4    98 	      BEGIN
  2676  12   28:5    98 		EXPRESSION(FSYS + [COMMA,RPARENT]); LOAD;
  2677  12   28:5   113 		IF GATTR.TYPTR <> INTPTR THEN ERROR(125)
  2678  12   28:4   119 	      END
  2679  12   28:2   122 	  END
  2680  12   28:1   122 	ELSE GENLDC(0);
  2681  12   28:1   127 	IF SY = COMMA THEN
  2682  12   28:2   133 	  BEGIN INSYMBOL;
  2683  12   28:3   136 	    EXPRESSION(FSYS + [RPARENT]); LOAD;
  2684  12   28:3   151 	    IF GATTR.TYPTR <> INTPTR THEN ERROR(125)
  2685  12   28:2   157 	  END
  2686  12   28:1   160 	ELSE GENLDC(0);
  2687  12   28:1   165 	IF LKEY = 13 THEN GEN1(30(*CSP*),5(*URD*))
  2688  12   28:1   174 	ELSE GEN1(30(*CSP*),6(*UWT*))
  2689  12   28:0   180       END (*UNITIO*);
  2690  12   28:0   194 
  2691  12   29:D     1       PROCEDURE CONCAT;
  2692  12   29:D     1 	VAR LLC: ADDRRANGE; TEMPLGTH: INTEGER;
  2693  12   29:0     0       BEGIN TEMPLGTH := 0;
  2694  12   29:1     3 	LLC := LC; LC := LC + (STRGLGTH DIV CHRSPERWD) + 1;
  2695  12   29:1    17 	GENLDC(0); GEN2(56(*STR*),0,LLC);
  2696  12   29:1    25 	GEN2(50(*LDA*),0,LLC);
  2697  12   29:1    30 	REPEAT
  2698  12   29:2    30 	  STRGVAR(FSYS + [COMMA,RPARENT],FALSE);
  2699  12   29:2    44 	  TEMPLGTH := TEMPLGTH + GATTR.TYPTR^.MAXLENG;
  2700  12   29:2    51 	  IF TEMPLGTH < STRGLGTH THEN GENLDC(TEMPLGTH)
  2701  12   29:2    59 	  ELSE GENLDC(STRGLGTH);
  2702  12   29:2    68 	  GEN2(77(*CXP*),0(*SYS*),23(*SCONCAT*));
  2703  12   29:2    73 	  GEN2(50(*LDA*),0,LLC);
  2704  12   29:2    78 	  TEST := SY <> COMMA;
  2705  12   29:2    84 	  IF NOT TEST THEN INSYMBOL
  2706  12   29:1    88 	UNTIL TEST;
  2707  12   29:1    94 	IF TEMPLGTH < STRGLGTH THEN
  2708  12   29:2   101 	  LC := LLC + (TEMPLGTH DIV CHRSPERWD) + 1
  2709  12   29:1   106 	ELSE TEMPLGTH := STRGLGTH;
  2710  12   29:1   117 	IF LC > LCMAX THEN LCMAX := LC;
  2711  12   29:1   126 	LC := LLC;
  2712  12   29:1   129 	WITH GATTR DO
  2713  12   29:2   129 	  BEGIN NEW(TYPTR,ARRAYS,TRUE,TRUE);
  2714  12   29:3   134 	    TYPTR^ := STRGPTR^;
  2715  12   29:3   139 	    TYPTR^.MAXLENG := TEMPLGTH
  2716  12   29:2   142 	  END
  2717  12   29:0   144       END (*CONCAT*) ;
  2718  12   29:0   158 
  2719  12   30:D     1       PROCEDURE COPYDELETE;
  2720  12   30:D     1 	VAR LLC: ADDRRANGE; LSP: STP;
  2721  12   30:0     0       BEGIN
  2722  12   30:1     0 	IF LKEY = 19 THEN
  2723  12   30:2     7 	  BEGIN LLC := LC;
  2724  12   30:3    10 	    LC := LC + (STRGLGTH DIV CHRSPERWD) + 1;
  2725  12   30:2    21 	  END;
  2726  12   30:1    21 	IF LKEY <> 43 THEN
  2727  12   30:2    28 	  BEGIN
  2728  12   30:3    28 	    STRGVAR(FSYS + [COMMA], LKEY = 18);
  2729  12   30:3    46 	    IF LKEY = 19 THEN
  2730  12   30:4    53 	      BEGIN LSP := GATTR.TYPTR;
  2731  12   30:5    56 		GEN2(50(*LDA*),0,LLC)
  2732  12   30:4    59 	      END;
  2733  12   30:3    61 	    IF SY = COMMA THEN INSYMBOL ELSE ERROR(20);
  2734  12   30:2    76 	  END;
  2735  12   30:1    76 	EXPRESSION(FSYS + [COMMA]); LOAD;
  2736  12   30:1    91 	IF GATTR.TYPTR <> NIL THEN
  2737  12   30:2    96 	  IF GATTR.TYPTR <> INTPTR THEN ERROR(125);
  2738  12   30:1   105 	IF SY = COMMA THEN INSYMBOL ELSE ERROR(20);
  2739  12   30:1   120 	EXPRESSION(FSYS + [RPARENT]); LOAD;
  2740  12   30:1   135 	IF GATTR.TYPTR <> NIL THEN
  2741  12   30:2   140 	  IF GATTR.TYPTR <> INTPTR THEN ERROR(125);
  2742  12   30:1   149 	IF LKEY = 19 THEN
  2743  12   30:2   156 	  BEGIN
  2744  12   30:3   156 	    GEN2(77(*CXP*),0(*SYS*),25(*SCOPY*));
  2745  12   30:3   161 	    GEN2(50(*LDA*),0,LLC);
  2746  12   30:3   166 	    IF LSP^.MAXLENG < STRGLGTH THEN
  2747  12   30:4   175 	      LC := LLC + (LSP^.MAXLENG DIV CHRSPERWD) + 1;
  2748  12   30:3   186 	    IF LC > LCMAX THEN LCMAX := LC;
  2749  12   30:3   195 	    LC := LLC; GATTR.TYPTR := LSP
  2750  12   30:2   198 	  END
  2751  12   30:1   201 	ELSE
  2752  12   30:2   203 	  IF LKEY = 43 THEN
  2753  12   30:3   210 	    GEN2(77(*CXP*),0(*SYS*),29(*GOTOXY*))
  2754  12   30:2   213 	  ELSE GEN2(77(*CXP*),0(*SYS*),26(*SDELETE*))
  2755  12   30:0   220       END (*COPYDELETE*) ;
  2756  12   30:0   234 
  2757  12   31:D     1       PROCEDURE STR;
  2758  12   31:0     0       BEGIN 
  2759  12   31:1     0 	WITH GATTR DO
  2760  12   31:2     0 	  BEGIN
  2761  12   31:3     0 	    IF COMPTYPES(LONGINTPTR,TYPTR) THEN
  2762  12   31:3    10 	    ELSE IF TYPTR = INTPTR THEN
  2763  12   31:5    17 		   BEGIN
  2764  12   31:6    17 		     GENLDC(18(*DCVT*)); GENNR(DECOPS);
  2765  12   31:6    23 		     TYPTR := LONGINTPTR
  2766  12   31:5    23 		   END
  2767  12   31:4    27 		 ELSE ERROR(125);
  2768  12   31:3    33 	    IF SY = COMMA THEN INSYMBOL ELSE ERROR(20);
  2769  12   31:3    48 	    STRGVAR(FSYS + [RPARENT], TRUE);
  2770  12   31:3    62 	    IF STRGTYPE(TYPTR) THEN
  2771  12   31:4    70 	      BEGIN GENLDC(TYPTR^.MAXLENG); GENLDC(12(*DSTR*));
  2772  12   31:5    78 		GENNR(DECOPS)
  2773  12   31:4    79 	      END
  2774  12   31:3    81 	    ELSE ERROR(116);
  2775  12   31:2    87 	  END
  2776  12   31:0    87       END (*STR*);
  2777  12   31:0   100 
  2778  12   32:D     1       PROCEDURE CLOSE;
  2779  12   32:0     0       BEGIN
  2780  12   32:1     0 	VARIABLE(FSYS + [COMMA,RPARENT]); LOADADDRESS;
  2781  12   32:1    15 	IF GATTR.TYPTR <> NIL THEN
  2782  12   32:2    20 	  IF GATTR.TYPTR^.FORM <> FILES THEN ERROR(125);
  2783  12   32:1    30 	IF SY = COMMA THEN
  2784  12   32:2    36 	  BEGIN INSYMBOL;
  2785  12   32:3    39 	    IF SY = IDENT THEN
  2786  12   32:4    45 	     BEGIN
  2787  12   32:5    45 	      IF ID = 'NORMAL  ' THEN GENLDC(0)
  2788  12   32:5    64 	      ELSE
  2789  12   32:6    68 		IF ID = 'LOCK    ' THEN GENLDC(1)
  2790  12   32:6    87 		ELSE
  2791  12   32:7    91 		  IF ID = 'PURGE   ' THEN GENLDC(2)
  2792  12   32:7   110 		  ELSE
  2793  12   32:8   114 		    IF ID = 'CRUNCH  ' THEN GENLDC(3)
  2794  12   32:8   133 		    ELSE ERROR(2);
  2795  12   32:5   141 	      INSYMBOL
  2796  12   32:4   141 	     END
  2797  12   32:3   144 	    ELSE ERROR(2)
  2798  12   32:2   147 	  END
  2799  12   32:1   150 	ELSE GENLDC(0);
  2800  12   32:1   155 	GEN2(77(*CXP*),0(*SYS*),6(*FCLOSE*));
  2801  12   32:1   160 	IF IOCHECK THEN GEN1(30(*CSP*),0(*IOC*))
  2802  12   32:0   166       END (*CLOSE*) ;
  2803  12   32:0   180 
  2804  12   33:D     1       PROCEDURE GETPUTETC;
  2805  12   33:0     0       BEGIN
  2806  12   33:1     0 	VARIABLE(FSYS + [COMMA,RPARENT]); LOADADDRESS;
  2807  12   33:1    15 	IF GATTR.TYPTR <> NIL THEN
  2808  12   33:2    20 	  IF GATTR.TYPTR^.FORM <> FILES THEN ERROR(125)
  2809  12   33:2    27 	  ELSE
  2810  12   33:3    32 	    IF GATTR.TYPTR^.FILTYPE = NIL THEN ERROR(399);
  2811  12   33:1    44 	CASE LKEY OF
  2812  12   33:1    49 	  32:  BEGIN
  2813  12   33:3    49 		  IF SY = COMMA THEN
  2814  12   33:4    55 		    BEGIN
  2815  12   33:5    55 		      INSYMBOL; EXPRESSION(FSYS + [RPARENT]); LOAD;
  2816  12   33:5    73 		      IF GATTR.TYPTR <> INTPTR THEN ERROR(125)
  2817  12   33:4    79 		    END
  2818  12   33:3    82 		  ELSE ERROR(125);
  2819  12   33:3    88 		  GENNR(SEEK)
  2820  12   33:2    89 	       END;
  2821  12   33:1    93 	  34:  GEN2(77(*CXP*),0(*SYS*),7(*FGET*));
  2822  12   33:1   100 	  35:  GEN2(77(*CXP*),0(*SYS*),8(*FPUT*));
  2823  12   33:1   107 	  40:  BEGIN
  2824  12   33:3   107 		  IF GATTR.TYPTR <> NIL THEN
  2825  12   33:4   112 		    IF GATTR.TYPTR^.FILTYPE <> CHARPTR THEN ERROR(399);
  2826  12   33:3   125 		  GENLDC(12); GENLDC(0);
  2827  12   33:3   131 		  GEN2(77(*CXP*),0(*SYS*),17(*WRC*))
  2828  12   33:2   134 	       END
  2829  12   33:1   136 	END (*CASE*) ;
  2830  12   33:1   164 	IF IOCHECK THEN GEN1(30(*CSP*),0(*IOC*))
  2831  12   33:0   170       END (*GETPUTETC*) ;
  2832  12   33:0   184 
  2833  12   34:D     1       PROCEDURE SCAN;
  2834  12   34:0     0       BEGIN
  2835  12   34:1     0 	IF GATTR.TYPTR <> NIL THEN
  2836  12   34:2     5 	  IF GATTR.TYPTR <> INTPTR THEN ERROR(125);
  2837  12   34:1    14 	IF SY = COMMA THEN INSYMBOL ELSE ERROR(20);
  2838  12   34:1    29 	IF SY = RELOP THEN
  2839  12   34:2    35 	  BEGIN
  2840  12   34:3    35 	    IF OP = EQOP THEN GENLDC(0)
  2841  12   34:3    42 	    ELSE
  2842  12   34:4    46 	      IF OP = NEOP THEN GENLDC(1)
  2843  12   34:4    53 	      ELSE ERROR(125);
  2844  12   34:3    61 	    INSYMBOL
  2845  12   34:2    61 	  END
  2846  12   34:1    64 	ELSE ERROR(125);
  2847  12   34:1    70 	EXPRESSION(FSYS + [COMMA]); LOAD;
  2848  12   34:1    85 	IF GATTR.TYPTR <> NIL THEN
  2849  12   34:2    90 	  IF GATTR.TYPTR <> CHARPTR THEN ERROR(125);
  2850  12   34:1   100 	IF SY = COMMA THEN INSYMBOL ELSE ERROR(20);
  2851  12   34:1   115 	VARIABLE(FSYS + [COMMA,RPARENT]); BYTEADDRESS;
  2852  12   34:1   130 	IF SY = COMMA THEN
  2853  12   34:2   136 	  BEGIN INSYMBOL;
  2854  12   34:3   139 	    EXPRESSION(FSYS + [RPARENT]); LOAD
  2855  12   34:2   152 	  END
  2856  12   34:1   154 	ELSE GENLDC(0);
  2857  12   34:1   159 	GEN1(30(*CSP*),11(*SCN*));
  2858  12   34:1   163 	GATTR.TYPTR := INTPTR
  2859  12   34:0   163       END (*SCAN*) ;
  2860  12   34:0   178 
  2861  12   35:D     1       PROCEDURE BLOCKIO;
  2862  12   35:0     0       BEGIN
  2863  12   35:1     0 	VARIABLE(FSYS + [COMMA]); LOADADDRESS;
  2864  12   35:1    15 	IF GATTR.TYPTR <> NIL THEN
  2865  12   35:2    20 	  IF GATTR.TYPTR^.FORM <> FILES THEN ERROR(125)
  2866  12   35:2    27 	  ELSE
  2867  12   35:3    32 	    IF GATTR.TYPTR^.FILTYPE <> NIL THEN ERROR(399);
  2868  12   35:1    44 	IF SY = COMMA THEN INSYMBOL ELSE ERROR(20);
  2869  12   35:1    59 	VARIABLE(FSYS + [COMMA]); BYTEADDRESS;
  2870  12   35:1    74 	IF SY = COMMA THEN INSYMBOL ELSE ERROR(20);
  2871  12   35:1    89 	EXPRESSION(FSYS + [COMMA,RPARENT]); LOAD;
  2872  12   35:1   104 	IF GATTR.TYPTR <> INTPTR THEN ERROR(125);
  2873  12   35:1   113 	IF SY = COMMA THEN
  2874  12   35:2   119 	  BEGIN INSYMBOL;
  2875  12   35:3   122 	    EXPRESSION(FSYS + [RPARENT]); LOAD;
  2876  12   35:3   137 	    IF GATTR.TYPTR <> INTPTR THEN ERROR(125)
  2877  12   35:2   143 	  END
  2878  12   35:1   146 	ELSE GENLDC(-1);
  2879  12   35:1   152 	IF LKEY = 37 THEN GENLDC(1) ELSE GENLDC(0);
  2880  12   35:1   167 	GENLDC(0); GENLDC(0);
  2881  12   35:1   173 	GEN2(77(*CXP*),0(*SYS*),28(*BLOCKIO*));
  2882  12   35:1   178 	IF IOCHECK THEN GEN1(30(*CSP*),0(*IOC*));
  2883  12   35:1   186 	GATTR.TYPTR := INTPTR
  2884  12   35:0   186       END (*BLOCKIO*) ;
  2885  12   35:0   202 
  2886  12   36:D     1       PROCEDURE SIZEOF;
  2887  12   36:D     1 	VAR LCP: CTP;
  2888  12   36:0     0       BEGIN
  2889  12   36:1     0 	IF SY = IDENT THEN
  2890  12   36:2     6 	  BEGIN SEARCHID(VARS + [TYPES,FIELD],LCP); INSYMBOL;
  2891  12   36:3    22 	    IF LCP^.IDTYPE <> NIL THEN
  2892  12   36:4    28 	      GENLDC(LCP^.IDTYPE^.SIZE*CHRSPERWD)
  2893  12   36:2    33 	  END;
  2894  12   36:1    35 	GATTR.TYPTR := INTPTR
  2895  12   36:0    35       END (*SIZEOF*) ;
  2896  12   36:0    50 
  2897  12   24:0     0   BEGIN (*ROUTINE*)
  2898  12   24:1     0     CASE LKEY OF
  2899  12   24:1     3       12:      NEWSTMT;
  2900  12   24:1     7       13,14:   UNITIO;
  2901  12   24:1    11       15:      CONCAT;
  2902  12   24:1    15       18,19,43:COPYDELETE;
  2903  12   24:1    19       21,22,27:MOVE;
  2904  12   24:1    23       23:      EXIT;
  2905  12   24:1    27       31:      CLOSE;
  2906  12   24:1    31       32,34,
  2907  12   24:1    31       35,40:   GETPUTETC;
  2908  12   24:1    35       36:      SCAN;
  2909  12   24:1    39       37,38:   BLOCKIO;
  2910  12   24:1    43       41:      SIZEOF;
  2911  12   24:1    47       42:      STR
  2912  12   24:1    47     END (*CASES*)
  2913  12   24:0   122   END (*ROUTINE*) ;
  2914  12   24:0   134 
  2915  12   24:0   134 (* --- BODYPART.C.TEXT --- *)
  2916  12   24:0   134 
  2917  12   24:0   134 (*    COPYRIGHT (C) 1979, REGENTS OF THE	*)
  2918  12   24:0   134 (*    UNIVERSITY OF CALIFORNIA, SAN DIEGO	*)
  2919  12   24:0   134 
  2920  12   37:D     1     PROCEDURE LOADIDADDR(FCP: CTP);
  2921  12   37:0     0     BEGIN
  2922  12   37:1     0 	WITH FCP^ DO
  2923  12   37:2     3 	  IF KLASS = ACTUALVARS THEN
  2924  12   37:3    10 	    IF VLEV = 1 THEN GEN1(37(*LAO*),VADDR)
  2925  12   37:3    21 	    ELSE GEN2(50(*LDA*),LEVEL-VLEV,VADDR)
  2926  12   37:2    35 	  ELSE  (*FORMALVARS*)
  2927  12   37:3    39 	    IF VLEV = 1 THEN GEN1(41(*LDO*),VADDR)
  2928  12   37:3    50 	    ELSE GEN2(54(*LOD*),LEVEL-VLEV,VADDR)
  2929  12   37:0    64     END (*LOADIDADDR*) ;
  2930  12   37:0    78 
  2931  12   38:D     1     PROCEDURE READ;
  2932  12   38:D     1       VAR FILEPTR,LCP: CTP;
  2933  12   38:0     0     BEGIN FILEPTR := INPUTPTR;
  2934  12   38:1     4       IF (SY = IDENT) AND WASLPARENT THEN
  2935  12   38:2    14 	BEGIN SEARCHID(VARS+[FIELD],LCP);
  2936  12   38:3    27 	  IF LCP^.IDTYPE <> NIL THEN
  2937  12   38:4    33 	    IF LCP^.IDTYPE^.FORM = FILES THEN
  2938  12   38:5    40 	      IF LCP^.IDTYPE^.FILTYPE = CHARPTR THEN
  2939  12   38:6    48 		BEGIN INSYMBOL; FILEPTR := LCP;
  2940  12   38:7    54 		  IF NOT (SY IN [COMMA,RPARENT]) THEN ERROR(20);
  2941  12   38:7    66 		  IF SY = COMMA THEN INSYMBOL
  2942  12   38:6    72 		END
  2943  12   38:2    75 	END
  2944  12   38:1    75       ELSE
  2945  12   38:2    77 	IF WASLPARENT THEN ERROR(2);
  2946  12   38:1    86       IF WASLPARENT AND (SY <> RPARENT) THEN
  2947  12   38:2    96 	BEGIN
  2948  12   38:3    96 	  REPEAT LOADIDADDR(FILEPTR);
  2949  12   38:4    99 	    VARIABLE(FSYS + [COMMA,RPARENT]);
  2950  12   38:4   112 	    IF GATTR.ACCESS = BYTE THEN ERROR(103);
  2951  12   38:4   121 	    LOADADDRESS;
  2952  12   38:4   123 	    IF GATTR.TYPTR <> NIL THEN
  2953  12   38:5   128 	      IF COMPTYPES(INTPTR,GATTR.TYPTR) THEN
  2954  12   38:6   137 		GEN2(77(*CXP*),0(*SYS*),12(*FRDI*))
  2955  12   38:5   140 	      ELSE
  2956  12   38:6   144 		IF COMPTYPES(REALPTR,GATTR.TYPTR) THEN
  2957  12   38:7   154 		  GENNR(FREADREAL)
  2958  12   38:6   155 		ELSE
  2959  12   38:7   159 		  IF COMPTYPES(LONGINTPTR,GATTR.TYPTR) THEN
  2960  12   38:8   169 		    BEGIN GENLDC(GATTR.TYPTR^.SIZE);
  2961  12   38:9   173 		      GENNR(FREADDEC)
  2962  12   38:8   174 		    END
  2963  12   38:7   176 		  ELSE
  2964  12   38:8   178 		    IF COMPTYPES(CHARPTR,GATTR.TYPTR) THEN
  2965  12   38:9   188 		      GEN2(77(*CXP*),0(*SYS*),16(*FRDC*))
  2966  12   38:8   191 		    ELSE
  2967  12   38:9   195 		      IF STRGTYPE(GATTR.TYPTR) THEN
  2968  12   38:0   203 			BEGIN GENLDC(GATTR.TYPTR^.MAXLENG);
  2969  12   38:1   208 			  GEN2(77(*CXP*),0(*SYS*),18(*FRDS*))
  2970  12   38:0   211 			END
  2971  12   38:9   213 		      ELSE ERROR(125);
  2972  12   38:4   219 	    IF IOCHECK THEN GEN1(30(*CSP*),0(*IOC*));
  2973  12   38:4   227 	    TEST := SY <> COMMA;
  2974  12   38:4   233 	    IF NOT TEST THEN INSYMBOL
  2975  12   38:3   237 	  UNTIL TEST
  2976  12   38:2   240 	END;
  2977  12   38:1   243       IF LKEY = 2 THEN
  2978  12   38:2   250 	BEGIN LOADIDADDR(FILEPTR);
  2979  12   38:3   253 	  GEN2(77(*CXP*),0(*SYS*),21(*FRLN*));
  2980  12   38:3   258 	  IF IOCHECK THEN GEN1(30(*CSP*),0(*IOC*))
  2981  12   38:2   264 	END
  2982  12   38:0   266     END (*READ*) ;
  2983  12   38:0   282 
  2984  12   39:D     1     PROCEDURE WRITE;
  2985  12   39:D     1       VAR LSP: STP; DEFAULT: BOOLEAN;
  2986  12   39:D     3 	  FILEPTR,LCP: CTP; LEN,LMIN,LMAX: INTEGER;
  2987  12   39:0     0     BEGIN FILEPTR := OUTPUTPTR;
  2988  12   39:1     4       IF (SY = IDENT) AND WASLPARENT THEN
  2989  12   39:2    14 	BEGIN SEARCHID(VARS + [FIELD,KONST,FUNC],LCP);
  2990  12   39:3    27 	  IF LCP^.IDTYPE <> NIL THEN
  2991  12   39:4    33 	    IF LCP^.IDTYPE^.FORM = FILES THEN
  2992  12   39:5    40 	      IF LCP^.IDTYPE^.FILTYPE = CHARPTR THEN
  2993  12   39:6    48 		BEGIN INSYMBOL; FILEPTR := LCP;
  2994  12   39:7    54 		  IF NOT (SY IN [COMMA,RPARENT]) THEN ERROR(20);
  2995  12   39:7    66 		  IF SY = COMMA THEN INSYMBOL
  2996  12   39:6    72 		END
  2997  12   39:2    75 	END;
  2998  12   39:1    75       IF WASLPARENT AND (SY <> RPARENT) THEN
  2999  12   39:2    85 	BEGIN
  3000  12   39:3    85 	  REPEAT LOADIDADDR(FILEPTR);
  3001  12   39:4    88 	    EXPRESSION(FSYS + [COMMA,COLON,RPARENT]);
  3002  12   39:4   101 	    LSP := GATTR.TYPTR;
  3003  12   39:4   104 	    IF LSP <> NIL THEN
  3004  12   39:5   109 	      WITH LSP^ DO
  3005  12   39:6   112 		BEGIN
  3006  12   39:7   112 		  IF FORM > LONGINT THEN LOADADDRESS
  3007  12   39:7   118 		  ELSE
  3008  12   39:8   122 		    BEGIN LOAD;
  3009  12   39:9   124 		      IF FORM = LONGINT THEN
  3010  12   39:0   130 			BEGIN GENLDC(DECSIZE(MAXDEC)); GENLDC(0(*DAJ*));
  3011  12   39:1   141 			  GENNR(DECOPS)
  3012  12   39:0   142 			END
  3013  12   39:8   144 		    END
  3014  12   39:6   144 		END;
  3015  12   39:4   144 	    IF SY = COLON THEN
  3016  12   39:5   150 	      BEGIN INSYMBOL;
  3017  12   39:6   153 		EXPRESSION(FSYS + [COMMA,COLON,RPARENT]);
  3018  12   39:6   166 		IF GATTR.TYPTR <> NIL THEN
  3019  12   39:7   171 		  IF GATTR.TYPTR <> INTPTR THEN ERROR(20);
  3020  12   39:6   180 		LOAD; DEFAULT := FALSE
  3021  12   39:5   182 	      END
  3022  12   39:4   185 	    ELSE DEFAULT := TRUE;
  3023  12   39:4   190 	    IF LSP = INTPTR THEN
  3024  12   39:5   195 	      BEGIN IF DEFAULT THEN GENLDC(0);
  3025  12   39:6   201 		GEN2(77(*CXP*),0(*SYS*),13(*FWRI*))
  3026  12   39:5   204 	      END
  3027  12   39:4   206 	    ELSE
  3028  12   39:5   208 	      IF LSP = REALPTR THEN
  3029  12   39:6   214 		BEGIN IF DEFAULT THEN GENLDC(0);
  3030  12   39:7   220 		  IF SY = COLON THEN
  3031  12   39:8   226 		    BEGIN INSYMBOL;
  3032  12   39:9   229 		      EXPRESSION(FSYS + [COMMA,RPARENT]); LOAD;
  3033  12   39:9   244 		      IF GATTR.TYPTR <> NIL THEN
  3034  12   39:0   249 			IF GATTR.TYPTR <> INTPTR THEN ERROR(125)
  3035  12   39:8   255 		    END
  3036  12   39:7   258 		  ELSE GENLDC(0);
  3037  12   39:7   263 		  GENNR(FWRITEREAL)
  3038  12   39:6   264 		END
  3039  12   39:5   266 	      ELSE
  3040  12   39:6   268 		IF COMPTYPES(LSP,LONGINTPTR) THEN
  3041  12   39:7   278 		  BEGIN IF DEFAULT THEN GENLDC(0); GENNR(FWRITEDEC) END
  3042  12   39:6   287 		ELSE
  3043  12   39:7   289 		  IF LSP = CHARPTR THEN
  3044  12   39:8   295 		    BEGIN IF DEFAULT THEN GENLDC(0);
  3045  12   39:9   301 		      GEN2(77(*CXP*),0(*SYS*),17(*FWRC*))
  3046  12   39:8   304 		    END
  3047  12   39:7   306 		  ELSE
  3048  12   39:8   308 		    IF STRGTYPE(LSP) THEN
  3049  12   39:9   316 		      BEGIN IF DEFAULT THEN GENLDC(0);
  3050  12   39:0   322 			GEN2(77(*CXP*),0(*SYS*),19(*FWRS*))
  3051  12   39:9   325 		      END
  3052  12   39:8   327 		    ELSE
  3053  12   39:9   329 		      IF PAOFCHAR(LSP) THEN
  3054  12   39:0   337 			BEGIN LMAX := 0;
  3055  12   39:1   340 			  IF LSP^.INXTYPE <> NIL THEN
  3056  12   39:2   346 			    BEGIN GETBOUNDS(LSP^.INXTYPE,LMIN,LMAX);
  3057  12   39:3   355 			       LMAX := LMAX - LMIN + 1
  3058  12   39:2   358 			    END;
  3059  12   39:1   362 			  IF DEFAULT THEN GENLDC(LMAX);
  3060  12   39:1   368 			  GENLDC(LMAX);
  3061  12   39:1   371 			  GEN2(77(*CXP*),0(*SYS*),20(*FWRB*))
  3062  12   39:0   374 			END
  3063  12   39:9   376 		      ELSE ERROR(125);
  3064  12   39:4   382 	    IF IOCHECK THEN GEN1(30(*CSP*),0(*IOC*));
  3065  12   39:4   390 	    TEST := SY <> COMMA;
  3066  12   39:4   396 	    IF NOT TEST THEN INSYMBOL
  3067  12   39:3   400 	  UNTIL TEST;
  3068  12   39:2   406 	END;
  3069  12   39:1   406       IF LKEY = 4 THEN (*WRITELN*)
  3070  12   39:2   413 	BEGIN LOADIDADDR(FILEPTR);
  3071  12   39:3   416 	  GEN2(77(*CXP*),0(*SYS*),22(*FWLN*));
  3072  12   39:3   421 	  IF IOCHECK THEN GEN1(30(*CSP*),0(*IOC*))
  3073  12   39:2   427 	END
  3074  12   39:0   429     END (*WRITE*) ;
  3075  12   39:0   448 
  3076  12   40:D     1     PROCEDURE CALLNONSPECIAL;
  3077  12   40:D     1       LABEL 1;
  3078  12   40:D     1       VAR NXT,LCP: CTP; LSP: STP; LB: BOOLEAN;
  3079  12   40:D     5 	  LMIN,LMAX: INTEGER;
  3080  12   40:0     0     BEGIN
  3081  12   40:1     0       WITH FCP^ DO
  3082  12   40:2     5 	BEGIN NXT := NEXT;
  3083  12   40:3     9 	  IF PFDECKIND = DECLARED THEN
  3084  12   40:4    16 	    IF PFKIND <> ACTUAL THEN ERROR(400)
  3085  12   40:2    26 	END;
  3086  12   40:1    29       IF SY = LPARENT THEN
  3087  12   40:2    35 	BEGIN
  3088  12   40:3    35 	  REPEAT
  3089  12   40:4    35 	    IF NXT = NIL THEN ERROR(126);
  3090  12   40:4    44 	    INSYMBOL;
  3091  12   40:4    47 	    EXPRESSION(FSYS + [COMMA,RPARENT]);
  3092  12   40:4    60 	    IF (GATTR.TYPTR <> NIL) AND (NXT <> NIL) THEN
  3093  12   40:5    69 	      BEGIN LSP := NXT^.IDTYPE;
  3094  12   40:6    73 		IF (NXT^.KLASS = FORMALVARS) OR (LSP <> NIL) THEN
  3095  12   40:7    84 		  BEGIN
  3096  12   40:8    84 		    IF NXT^.KLASS = ACTUALVARS THEN
  3097  12   40:9    91 		      IF GATTR.TYPTR^.FORM <= POWER THEN
  3098  12   40:0    97 			BEGIN LB := (GATTR.TYPTR = CHARPTR)
  3099  12   40:1   101 				    AND (GATTR.KIND = CST);
  3100  12   40:1   107 			  LOAD;
  3101  12   40:1   109 			  IF LSP^.FORM = POWER THEN
  3102  12   40:2   115 			    GEN1(32(*ADJ*),LSP^.SIZE)
  3103  12   40:1   118 			  ELSE
  3104  12   40:2   122 			  IF LSP^.FORM = LONGINT THEN
  3105  12   40:3   128 			    BEGIN
  3106  12   40:4   128 			      IF GATTR.TYPTR = INTPTR THEN
  3107  12   40:5   133 				BEGIN GENLDC(18(*DCVT*)); GENNR(DECOPS);
  3108  12   40:6   139 				  GATTR.TYPTR := LONGINTPTR
  3109  12   40:5   139 				END;
  3110  12   40:4   143 			      GENLDC(LSP^.SIZE);
  3111  12   40:4   147 			      GENLDC(0(*DAJ*));
  3112  12   40:4   150 			      GENNR(DECOPS)
  3113  12   40:3   151 			    END
  3114  12   40:2   153 			  ELSE
  3115  12   40:3   155 			  IF (LSP^.FORM = SUBRANGE)
  3116  12   40:3   159 				AND RANGECHECK THEN
  3117  12   40:4   164 			    BEGIN GENLDC(LSP^.MIN.IVAL);
  3118  12   40:5   168 			      GENLDC(LSP^.MAX.IVAL);
  3119  12   40:5   172 			      GEN0(8(*CHK*))
  3120  12   40:4   173 			    END
  3121  12   40:3   175 			  ELSE
  3122  12   40:4   177 			  IF (GATTR.TYPTR = INTPTR) AND
  3123  12   40:4   180 				COMPTYPES(LSP,REALPTR) THEN
  3124  12   40:5   191 			    BEGIN GEN0(10(*FLT*));
  3125  12   40:6   194 			      GATTR.TYPTR := REALPTR
  3126  12   40:5   194 			    END
  3127  12   40:4   198 			  ELSE
  3128  12   40:5   200 			  IF LB AND STRGTYPE(LSP) THEN
  3129  12   40:6   210 			    GATTR.TYPTR := STRGPTR
  3130  12   40:0   210 			END
  3131  12   40:9   214 		      ELSE (*FORM > POWER*)
  3132  12   40:0   216 			BEGIN LB := STRGTYPE(GATTR.TYPTR)
  3133  12   40:1   217 				    AND (GATTR.KIND = CST);
  3134  12   40:1   228 			  LOADADDRESS;
  3135  12   40:1   230 			  IF LB AND PAOFCHAR(LSP) THEN
  3136  12   40:2   240 			    IF NOT LSP^.AISSTRNG THEN
  3137  12   40:3   245 			      BEGIN STRGTOPA(STRGCSTIC);
  3138  12   40:4   249 				IF LSP^.INXTYPE <> NIL THEN
  3139  12   40:5   255 				  BEGIN
  3140  12   40:6   255 				    GETBOUNDS(LSP^.INXTYPE,LMIN,LMAX);
  3141  12   40:6   264 				    IF LMAX-LMIN+1 <> 
  3142  12   40:6   269 					GATTR.TYPTR^.MAXLENG THEN ERROR(142);
  3143  12   40:5   281 				  END;
  3144  12   40:4   281 				GATTR.TYPTR := LSP
  3145  12   40:3   281 			      END
  3146  12   40:0   284 			END
  3147  12   40:8   284 		    ELSE (*KLASS = FORMALVARS*)
  3148  12   40:9   286 		      IF GATTR.KIND = VARBL THEN
  3149  12   40:0   291 			BEGIN
  3150  12   40:1   291 			  IF GATTR.ACCESS = BYTE THEN ERROR(103);
  3151  12   40:1   300 			  LOADADDRESS;
  3152  12   40:1   302 			  IF LSP <> NIL THEN
  3153  12   40:2   307 			    IF LSP^.FORM IN [POWER,LONGINT] THEN
  3154  12   40:3   314 			      IF GATTR.TYPTR^.SIZE <>
  3155  12   40:3   316 				  LSP^.SIZE THEN ERROR(142)
  3156  12   40:0   324 			END
  3157  12   40:9   327 		      ELSE ERROR(154);
  3158  12   40:8   335 		    IF NOT COMPTYPES(LSP,GATTR.TYPTR) THEN ERROR(142)
  3159  12   40:7   348 		  END
  3160  12   40:5   351 	      END;
  3161  12   40:4   351 	    IF NXT <> NIL THEN NXT := NXT^.NEXT
  3162  12   40:3   357 	  UNTIL SY <> COMMA;
  3163  12   40:3   366 	  IF SY = RPARENT THEN INSYMBOL ELSE ERROR(4)
  3164  12   40:2   378 	END (*LPARENT*) ;
  3165  12   40:1   381       IF NXT <> NIL THEN ERROR(126);
  3166  12   40:1   390       WITH FCP^ DO
  3167  12   40:2   395 	IF PFDECKIND = DECLARED THEN
  3168  12   40:3   402 	  BEGIN
  3169  12   40:4   402 	    IF KLASS = FUNC THEN
  3170  12   40:5   409 	      BEGIN GENLDC(0); GENLDC(0) END;
  3171  12   40:4   415 	    IF INMODULE THEN
  3172  12   40:5   419 	      IF SEPPROC THEN
  3173  12   40:6   423 		IF (PFSEG = SEG) AND (PFLEV = 1) THEN
  3174  12   40:7   436 		  BEGIN GEN1(79(*CGP*),0); LINKERREF(PROC,-PFNAME,IC-1) END
  3175  12   40:6   450 		ELSE
  3176  12   40:7   452 		  IF PFLEV = 0 THEN GEN2(77(*CXP*),PFSEG,PFNAME)
  3177  12   40:7   466 		  ELSE ERROR(405) (*CALL NOT ALLOWED IN SEP PROC*)
  3178  12   40:5   473 	      ELSE
  3179  12   40:6   478 		IF IMPORTED THEN
  3180  12   40:7   483 		  BEGIN GEN2(77(*CXP*),0,PFNAME); LINKERREF(PROC,PFSEG,IC-2) END
  3181  12   40:6   499 	        ELSE GOTO 1
  3182  12   40:4   503 	    ELSE
  3183  12   40:5   505        1:     IF PFSEG <> SEG THEN
  3184  12   40:6   512 		GEN2(77(*CXP*),PFSEG,PFNAME)
  3185  12   40:5   519 	      ELSE
  3186  12   40:6   523 		IF PFLEV = 0 THEN GEN1(66(*CBP*),PFNAME)
  3187  12   40:6   534 		ELSE
  3188  12   40:7   538 		  IF PFLEV = LEVEL THEN GEN1(78(*CLP*),PFNAME)
  3189  12   40:7   550 		  ELSE
  3190  12   40:8   554 		    IF PFLEV = 1 THEN GEN1(79(*CGP*),PFNAME)
  3191  12   40:8   565 		    ELSE GEN1(46(*CIP*),PFNAME)
  3192  12   40:3   573 	  END
  3193  12   40:2   575 	ELSE
  3194  12   40:3   577 	  IF CSPNUM = 23 THEN GEN1(30,40)  (* TEMP I.5 TRANSLATION --
  3195  12   40:3   586 					      MEM WILL BE CSP 23 IN II.0  *)
  3196  12   40:3   586 	  ELSE
  3197  12   40:4   590 	    IF (CSPNUM <> 21) AND (CSPNUM <> 22) THEN
  3198  12   40:5   603 	      GEN1(30(*CSP*),CSPNUM);
  3199  12   40:1   609       GATTR.TYPTR := FCP^.IDTYPE
  3200  12   40:0   612     END (*CALLNONSPECIAL*) ;
  3201  12   40:0   640 
  3202  12   21:0     0   BEGIN (*CALL*)
  3203  12   21:1     0     IF FCP^.PFDECKIND = SPECIAL THEN
  3204  12   21:2     7       BEGIN WASLPARENT := TRUE; LKEY := FCP^.KEY;
  3205  12   21:3    15 	IF SY = LPARENT THEN INSYMBOL
  3206  12   21:3    21 	ELSE
  3207  12   21:4    26 	  IF LKEY IN [2,4,5,6] THEN WASLPARENT := FALSE
  3208  12   21:4    32 	  ELSE ERROR(9);
  3209  12   21:3    41 	IF LKEY IN [7,8,9,10,11,13,14,25,36,39,42] THEN
  3210  12   21:4    54 	  BEGIN EXPRESSION(FSYS + [COMMA,RPARENT]); LOAD END;
  3211  12   21:3    68 	IF LKEY IN [12,13,14,15,18,19,21,22,23,27,31,32,34,35,36,37,38,
  3212  12   21:3    69 		    40,41,42,43] THEN ROUTINE(LKEY)
  3213  12   21:3    83 	ELSE
  3214  12   21:4    87 	  CASE LKEY OF
  3215  12   21:4    90 	     1,2: READ;
  3216  12   21:4    94 	     3,4: WRITE;
  3217  12   21:4    98 	     5,6: BEGIN (*EOF & EOLN*)
  3218  12   21:6    98 		    IF WASLPARENT THEN
  3219  12   21:7   101 		      BEGIN VARIABLE(FSYS + [RPARENT]); LOADADDRESS;
  3220  12   21:8   115 			IF GATTR.TYPTR <> NIL THEN
  3221  12   21:9   120 			  IF GATTR.TYPTR^.FORM <> FILES THEN ERROR(125)
  3222  12   21:9   127 			  ELSE
  3223  12   21:0   132 			    IF (GATTR.TYPTR^.FILTYPE <> CHARPTR) AND
  3224  12   21:0   137 				(LKEY = 6) THEN ERROR(399)
  3225  12   21:7   146 		      END
  3226  12   21:6   149 		    ELSE
  3227  12   21:7   151 		      LOADIDADDR(INPUTPTR);
  3228  12   21:6   155 		    GENLDC(0); GENLDC(0);
  3229  12   21:6   161 		    IF LKEY = 5 THEN GEN2(77(*CXP*),0(*SYS*),10(*FEOF*))
  3230  12   21:6   169 		    ELSE GEN2(77(*CXP*),0(*SYS*),11(*FEOLN*));
  3231  12   21:6   178 		    GATTR.TYPTR := BOOLPTR
  3232  12   21:5   178 		  END (*EOF*) ;
  3233  12   21:4   184 	     7,8: BEGIN GENLDC(1); (*PREDSUCC*)
  3234  12   21:6   187 		    IF GATTR.TYPTR <> NIL THEN
  3235  12   21:7   192 		      IF GATTR.TYPTR^.FORM = SCALAR THEN
  3236  12   21:8   198 			IF LKEY = 8 THEN GEN0(2(*ADI*))
  3237  12   21:8   204 			ELSE GEN0(21(*SBI*))
  3238  12   21:7   209 		      ELSE ERROR(115)
  3239  12   21:5   214 		  END (*PREDSUCC*) ;
  3240  12   21:4   219 	       9: BEGIN (*ORD*)
  3241  12   21:6   219 		    IF GATTR.TYPTR <> NIL THEN
  3242  12   21:7   224 		      IF GATTR.TYPTR^.FORM >= POWER THEN ERROR(125);
  3243  12   21:6   234 		    GATTR.TYPTR := INTPTR
  3244  12   21:5   234 		  END (*ORD*) ;
  3245  12   21:4   239 	      10: BEGIN (*SQR*)
  3246  12   21:6   239 		    IF GATTR.TYPTR <> NIL THEN
  3247  12   21:7   244 		    IF GATTR.TYPTR = INTPTR THEN GEN0(24(*SQI*))
  3248  12   21:7   250 		    ELSE
  3249  12   21:8   254 		      IF GATTR.TYPTR = REALPTR THEN GEN0(25(*SQR*))
  3250  12   21:8   261 		      ELSE BEGIN ERROR(125); GATTR.TYPTR := INTPTR END
  3251  12   21:5   272 		  END (*SQR*) ;
  3252  12   21:4   274 	      11: BEGIN (*ABS*)
  3253  12   21:6   274 		    IF GATTR.TYPTR <> NIL THEN
  3254  12   21:7   279 		      IF GATTR.TYPTR = INTPTR THEN GEN0(0(*ABI*))
  3255  12   21:7   285 		      ELSE
  3256  12   21:8   289 			IF GATTR.TYPTR = REALPTR THEN GEN0(1(*ABR*))
  3257  12   21:8   296 			ELSE BEGIN ERROR(125); GATTR.TYPTR := INTPTR END
  3258  12   21:5   307 		  END (*ABS*) ;
  3259  12   21:4   309 	      16: BEGIN (*LENGTH*)
  3260  12   21:6   309 		    STRGVAR(FSYS + [RPARENT],FALSE);
  3261  12   21:6   322 		    GENLDC(0(*INDEX*)); GEN0(62(*LDB*)); GATTR.TYPTR := INTPTR
  3262  12   21:5   328 		  END (*LENGTH*) ;
  3263  12   21:4   333 	      17: BEGIN (*INSERT*)
  3264  12   21:6   333 		    STRGVAR(FSYS + [COMMA],FALSE);
  3265  12   21:6   346 		    IF SY = COMMA THEN INSYMBOL ELSE ERROR(20);
  3266  12   21:6   361 		    STRGVAR(FSYS + [COMMA],TRUE);
  3267  12   21:6   374 		    GENLDC(GATTR.TYPTR^.MAXLENG);
  3268  12   21:6   379 		    IF SY = COMMA THEN INSYMBOL ELSE ERROR(20);
  3269  12   21:6   394 		    EXPRESSION(FSYS + [RPARENT]); LOAD;
  3270  12   21:6   408 		    IF GATTR.TYPTR <> NIL THEN
  3271  12   21:7   413 		      IF GATTR.TYPTR <> INTPTR THEN ERROR(125);
  3272  12   21:6   422 		    GEN2(77(*CXP*),0(*SYS*),24(*SINSERT*))
  3273  12   21:5   425 		  END (*INSERT*) ;
  3274  12   21:4   429 	      20: BEGIN (*POS*)
  3275  12   21:6   429 		    STRGVAR(FSYS + [COMMA],FALSE);
  3276  12   21:6   442 		    IF SY = COMMA THEN INSYMBOL ELSE ERROR(20);
  3277  12   21:6   457 		    STRGVAR(FSYS + [RPARENT],FALSE);
  3278  12   21:6   470 		    GENLDC(0); GENLDC(0);
  3279  12   21:6   476 		    GEN2(77(*CXP*),0(*SYS*),27(*SPOS*));
  3280  12   21:6   481 		    GATTR.TYPTR := INTPTR
  3281  12   21:5   481 		  END (*POS*) ;
  3282  12   21:4   486 	      24: BEGIN (*IDSEARCH*)
  3283  12   21:6   486 		    VARIABLE(FSYS + [COMMA]); LOADADDRESS;
  3284  12   21:6   500 		    IF SY = COMMA THEN INSYMBOL ELSE ERROR(20);
  3285  12   21:6   515 		    VARIABLE(FSYS + [RPARENT]); LOADADDRESS;
  3286  12   21:6   529 		    GEN1(30(*CSP*),7(*IDS*))
  3287  12   21:5   531 		  END (*IDSEARCH*) ;
  3288  12   21:4   535 	      25: BEGIN (*TREESEARCH*)
  3289  12   21:6   535 		    IF SY = COMMA THEN INSYMBOL ELSE ERROR(20);
  3290  12   21:6   550 		    VARIABLE(FSYS + [COMMA]); LOADADDRESS;
  3291  12   21:6   564 		    IF SY = COMMA THEN INSYMBOL ELSE ERROR(20);
  3292  12   21:6   579 		    VARIABLE(FSYS + [RPARENT]); LOADADDRESS;
  3293  12   21:6   593 		    GATTR.TYPTR := INTPTR;
  3294  12   21:6   596 		    GEN1(30(*CSP*),8(*TRS*))
  3295  12   21:5   598 		  END (*TREESEARCH*) ;
  3296  12   21:4   602 	      26: BEGIN (*TIME*)
  3297  12   21:6   602 		    VARIABLE(FSYS + [COMMA]); LOADADDRESS;
  3298  12   21:6   616 		    IF GATTR.TYPTR <> NIL THEN
  3299  12   21:7   621 		      IF GATTR.TYPTR <> INTPTR THEN ERROR(125);
  3300  12   21:6   630 		    IF SY = COMMA THEN INSYMBOL ELSE ERROR(20);
  3301  12   21:6   645 		    VARIABLE(FSYS + [RPARENT]); LOADADDRESS;
  3302  12   21:6   659 		    IF GATTR.TYPTR <> NIL THEN
  3303  12   21:7   664 		      IF GATTR.TYPTR <> INTPTR THEN ERROR(125);
  3304  12   21:6   673 		    GEN1(30(*CSP*),9(*TIM*))
  3305  12   21:5   675 		  END (*TIME*) ;
  3306  12   21:4   679      33,28,29,30: BEGIN (*OPEN,RESET,REWRITE*)
  3307  12   21:6   679 		    VARIABLE(FSYS + [COMMA,RPARENT]); LOADADDRESS;
  3308  12   21:6   693 		    IF GATTR.TYPTR <> NIL THEN
  3309  12   21:7   698 		      IF GATTR.TYPTR^.FORM <> FILES THEN ERROR(125);
  3310  12   21:6   708 		    IF SY <> COMMA THEN
  3311  12   21:7   714 		      IF LKEY = 33 THEN
  3312  12   21:8   719 			GEN2(77(*CXP*),0(*SYS*),4(*FRESET*))
  3313  12   21:7   722 		      ELSE ERROR(20)
  3314  12   21:6   727 		    ELSE
  3315  12   21:7   732 		      BEGIN INSYMBOL;
  3316  12   21:8   735 			STRGVAR(FSYS + [RPARENT],FALSE);
  3317  12   21:8   748 			IF (LKEY = 28) OR (LKEY = 30) THEN
  3318  12   21:9   757 			  GENLDC(0)
  3319  12   21:8   758 			ELSE GENLDC(1);
  3320  12   21:8   765 			GENLDC(0); GEN2(77(*CXP*),0(*SYS*),5(*FOPEN*))
  3321  12   21:7   771 		      END;
  3322  12   21:6   773 		    IF IOCHECK THEN GEN1(30(*CSP*),0(*IOC*))
  3323  12   21:5   779 		  END (*OPEN*) ;
  3324  12   21:4   783 	      39: BEGIN (*TRUNC*)
  3325  12   21:6   783 		    IF GATTR.TYPTR = INTPTR THEN
  3326  12   21:7   788 		      BEGIN GEN0(10(*FLT*));
  3327  12   21:8   791 			GATTR.TYPTR := REALPTR
  3328  12   21:7   791 		      END;
  3329  12   21:6   795 		    IF GATTR.TYPTR <> NIL THEN
  3330  12   21:7   800 		      IF GATTR.TYPTR = REALPTR THEN
  3331  12   21:8   806 			GEN1(30(*CSP*),23(*TRUNC*)) (*** TEMPORARY -- 
  3332  12   21:8   808 					  TRUNC WILL BE CSP 14 IN II.0 ***)
  3333  12   21:7   808 		      ELSE
  3334  12   21:8   812 			IF GATTR.TYPTR^.FORM = LONGINT THEN
  3335  12   21:9   818 			  BEGIN
  3336  12   21:0   818 			    GENLDC(20(*DTNC*)); GENNR(DECOPS)
  3337  12   21:9   822 			  END
  3338  12   21:8   824 			ELSE ERROR(125);
  3339  12   21:6   830 		    GATTR.TYPTR := INTPTR
  3340  12   21:5   830 		  END
  3341  12   21:4   833 	  END (*SPECIAL CASES*) ;
  3342  12   21:3   920 	IF WASLPARENT THEN
  3343  12   21:4   923 	  IF SY = RPARENT THEN INSYMBOL ELSE ERROR(4)
  3344  12   21:2   935       END (*SPECIAL PROCEDURES AND FUNCTIONS*)
  3345  12   21:1   938     ELSE CALLNONSPECIAL
  3346  12   21:0   940   END (*CALL*) ;
  3347  12   21:0   962 
  3348  12   21:0   962 (* --- BODYPART.D.TEXT --- *)
  3349  12   21:0   962 
  3350  12   21:0   962 (*    COPYRIGHT (C) 1979, REGENTS OF THE	*)
  3351  12   21:0   962 (*    UNIVERSITY OF CALIFORNIA, SAN DIEGO	*)
  3352  12   21:0   962 
  3353  12   19:D     1   PROCEDURE EXPRESSION(*FSYS: SETOFSYS*);
  3354  12   19:D     5     LABEL 1; 	(* STRING COMPARE KLUDGE *)
  3355  12   19:D     5     VAR LATTR: ATTR; LOP: OPERATOR; TYPIND: INTEGER;
  3356  12   19:D    12 	LSTRGIC,LSIZE: ADDRRANGE; LSTRING,GSTRING: BOOLEAN;
  3357  12   19:D    16 	LMIN,LMAX: INTEGER;
  3358  12   19:D    18 
  3359  12   41:D     1     PROCEDURE FLOATIT(VAR FSP: STP; FORCEFLOAT: BOOLEAN);
  3360  12   41:0     0     BEGIN
  3361  12   41:1     0       IF (GATTR.TYPTR = REALPTR) OR (FSP = REALPTR) OR FORCEFLOAT THEN
  3362  12   41:2    14 	BEGIN
  3363  12   41:3    14 	  IF GATTR.TYPTR = INTPTR THEN
  3364  12   41:4    19 	    BEGIN GEN0(10(*FLT*)); GATTR.TYPTR := REALPTR END;
  3365  12   41:3    26 	  IF FSP = INTPTR THEN
  3366  12   41:4    32 	    BEGIN GEN0(9(*FLO*)); FSP := REALPTR END
  3367  12   41:2    39 	END
  3368  12   41:0    39     END (*FLOATIT*) ;
  3369  12   41:0    52 
  3370  12   42:D     1     PROCEDURE STRETCHIT(VAR FSP: STP);
  3371  12   42:0     0     BEGIN
  3372  12   42:1     0       IF (FSP^.FORM = LONGINT) OR (GATTR.TYPTR^.FORM = LONGINT) THEN
  3373  12   42:2    12 	IF GATTR.TYPTR = INTPTR THEN
  3374  12   42:3    17 	  BEGIN GENLDC(18(*DCVT*)); GENNR(DECOPS); GATTR.TYPTR := LONGINTPTR END
  3375  12   42:2    27 	ELSE
  3376  12   42:3    29 	  IF FSP = INTPTR THEN
  3377  12   42:4    35 	    BEGIN GENLDC(14(*DCV*)); GENNR(DECOPS); FSP := LONGINTPTR END
  3378  12   42:0    45     END (*STRETCHIT*) ;
  3379  12   42:0    58 
  3380  12   43:D     1     PROCEDURE SIMPLEEXPRESSION(FSYS: SETOFSYS);
  3381  12   43:D     5       VAR LATTR: ATTR; LOP: OPERATOR; SIGNED: BOOLEAN;
  3382  12   43:D    12 
  3383  12   44:D     1       PROCEDURE TERM(FSYS: SETOFSYS);
  3384  12   44:D     5 	VAR LATTR: ATTR; LSP: STP; LOP: OPERATOR;
  3385  12   44:D    12 
  3386  12   45:D     1 	PROCEDURE FACTOR(FSYS: SETOFSYS);
  3387  12   45:D     5 	  VAR LCP: CTP; LVP: CSP; VARPART,ALLCONST: BOOLEAN;
  3388  12   45:D     9 	      LSP: STP; HIGHVAL,LOWVAL,LIC,LOP: INTEGER;
  3389  12   45:D    14 	      CSTPART: SET OF 0..127;
  3390  12   45:0     0 	BEGIN
  3391  12   45:1     0 	  IF NOT (SY IN FACBEGSYS) THEN
  3392  12   45:2    11 	    BEGIN ERROR(58); SKIP(FSYS + FACBEGSYS);
  3393  12   45:3    31 	      GATTR.TYPTR := NIL
  3394  12   45:2    31 	    END;
  3395  12   45:1    34 	  WHILE SY IN FACBEGSYS DO
  3396  12   45:2    44 	    BEGIN
  3397  12   45:3    44 	      CASE SY OF
  3398  12   45:3    48 	(*ID*)  IDENT:
  3399  12   45:4    48 		  BEGIN SEARCHID([KONST,FORMALVARS,ACTUALVARS,FIELD,FUNC],LCP);
  3400  12   45:5    57 		    INSYMBOL;
  3401  12   45:5    60 		    IF LCP^.KLASS = FUNC THEN
  3402  12   45:6    67 		      BEGIN CALL(FSYS,LCP); GATTR.KIND := EXPR END
  3403  12   45:5    80 		    ELSE
  3404  12   45:6    82 		      IF LCP^.KLASS = KONST THEN
  3405  12   45:7    89 			WITH GATTR, LCP^ DO
  3406  12   45:8    92 			  BEGIN TYPTR := IDTYPE; KIND := CST;
  3407  12   45:9   100 			    CVAL := VALUES
  3408  12   45:8   102 			  END
  3409  12   45:6   108 		      ELSE SELECTOR(FSYS,LCP);
  3410  12   45:5   120 		    IF GATTR.TYPTR <> NIL THEN
  3411  12   45:6   125 		      WITH GATTR,TYPTR^ DO
  3412  12   45:7   128 			IF FORM = SUBRANGE THEN TYPTR := RANGETYPE
  3413  12   45:4   135 		  END;
  3414  12   45:3   142 	(*CST*) INTCONST:
  3415  12   45:4   142 		  BEGIN
  3416  12   45:5   142 		    WITH GATTR DO
  3417  12   45:6   142 		      BEGIN TYPTR := INTPTR; KIND := CST;
  3418  12   45:7   148 			CVAL := VAL
  3419  12   45:6   150 		      END;
  3420  12   45:5   154 		    INSYMBOL
  3421  12   45:4   154 		  END;
  3422  12   45:3   159 		REALCONST:
  3423  12   45:4   159 		  BEGIN
  3424  12   45:5   159 		    WITH GATTR DO
  3425  12   45:6   159 		      BEGIN TYPTR := REALPTR; KIND := CST;
  3426  12   45:7   166 			CVAL := VAL
  3427  12   45:6   168 		      END;
  3428  12   45:5   172 		    INSYMBOL
  3429  12   45:4   172 		  END;
  3430  12   45:3   177 		STRINGCONST:
  3431  12   45:4   177 		  BEGIN
  3432  12   45:5   177 		    WITH GATTR DO
  3433  12   45:6   177 		      BEGIN
  3434  12   45:7   177 			IF LGTH = 1 THEN TYPTR := CHARPTR
  3435  12   45:7   183 			ELSE
  3436  12   45:8   189 			  BEGIN NEW(LSP,ARRAYS,TRUE,TRUE);
  3437  12   45:9   194 			    LSP^ := STRGPTR^;
  3438  12   45:9   199 			    LSP^.MAXLENG := LGTH;
  3439  12   45:9   205 			    TYPTR := LSP
  3440  12   45:8   205 			  END;
  3441  12   45:7   208 			KIND := CST; CVAL := VAL
  3442  12   45:6   213 		      END;
  3443  12   45:5   217 		    INSYMBOL
  3444  12   45:4   217 		  END;
  3445  12   45:3   222 		LONGCONST:
  3446  12   45:4   222 		  BEGIN
  3447  12   45:5   222 		    WITH GATTR DO
  3448  12   45:6   222 		      BEGIN NEW(LSP,LONGINT);
  3449  12   45:7   227 			LSP^ := LONGINTPTR^;
  3450  12   45:7   232 			LSP^.SIZE := DECSIZE(LGTH);
  3451  12   45:7   241 		        TYPTR := LSP; KIND := CST; CVAL := VAL
  3452  12   45:6   249 		      END;
  3453  12   45:5   253 		    INSYMBOL
  3454  12   45:4   253 		  END;
  3455  12   45:3   258 	(*(*)   LPARENT:
  3456  12   45:4   258 		  BEGIN INSYMBOL; EXPRESSION(FSYS + [RPARENT]);
  3457  12   45:5   273 		    IF SY = RPARENT THEN INSYMBOL ELSE ERROR(4)
  3458  12   45:4   285 		  END;
  3459  12   45:3   290 	(*NOT*) NOTSY:
  3460  12   45:4   290 		  WITH GATTR DO
  3461  12   45:5   290 		    BEGIN INSYMBOL; FACTOR(FSYS);
  3462  12   45:6   302 		      IF (KIND = CST) AND (TYPTR = BOOLPTR) THEN
  3463  12   45:7   312 			CVAL.IVAL := ORD(NOT ODD(CVAL.IVAL))
  3464  12   45:6   314 		      ELSE
  3465  12   45:7   318 		      BEGIN LOAD; GEN0(19(*NOT*));
  3466  12   45:8   323 			IF TYPTR <> NIL THEN
  3467  12   45:9   328 			  IF TYPTR <> BOOLPTR THEN
  3468  12   45:0   334 			    BEGIN ERROR(135); TYPTR := NIL END
  3469  12   45:7   343 		      END
  3470  12   45:5   343 		    END;
  3471  12   45:3   345 	(*[*)   LBRACK:
  3472  12   45:4   345 		  BEGIN INSYMBOL; CSTPART := [ ]; VARPART := FALSE;
  3473  12   45:5   358 		    NEW(LSP,POWER);
  3474  12   45:5   363 		    WITH LSP^ DO
  3475  12   45:6   366 		      BEGIN ELSET := NIL; SIZE := 0; FORM := POWER END;
  3476  12   45:5   382 		    IF SY = RBRACK THEN
  3477  12   45:6   388 		      BEGIN
  3478  12   45:7   388 			WITH GATTR DO
  3479  12   45:8   388 			  BEGIN TYPTR := LSP; KIND := CST END;
  3480  12   45:7   394 			INSYMBOL
  3481  12   45:6   394 		      END
  3482  12   45:5   397 		    ELSE
  3483  12   45:6   399 		      BEGIN
  3484  12   45:7   399 			REPEAT EXPRESSION(FSYS + [COMMA,RBRACK,COLON]);
  3485  12   45:8   416 			  IF GATTR.TYPTR <> NIL THEN
  3486  12   45:9   421 			    IF GATTR.TYPTR^.FORM <> SCALAR THEN
  3487  12   45:0   427 			      BEGIN ERROR(136); GATTR.TYPTR := NIL END
  3488  12   45:9   436 			    ELSE
  3489  12   45:0   438 			      IF COMPTYPES(LSP^.ELSET,GATTR.TYPTR) THEN
  3490  12   45:1   448 				BEGIN ALLCONST := FALSE; LOP := 23(*SGS*);
  3491  12   45:2   454 				  IF (GATTR.KIND = CST) AND
  3492  12   45:2   457 				     (GATTR.CVAL.IVAL <= 127) THEN
  3493  12   45:3   463 				    BEGIN ALLCONST := TRUE;
  3494  12   45:4   466 				      LOWVAL := GATTR.CVAL.IVAL;
  3495  12   45:4   469 				      HIGHVAL := LOWVAL
  3496  12   45:3   469 				    END;
  3497  12   45:2   472 				  LIC := IC; LOAD;
  3498  12   45:2   477 				  IF SY = COLON THEN
  3499  12   45:3   483 				    BEGIN INSYMBOL; LOP := 20(*SRS*);
  3500  12   45:4   489 				      EXPRESSION(FSYS + [COMMA,RBRACK]);
  3501  12   45:4   506 				      IF COMPTYPES(LSP^.ELSET,GATTR.TYPTR) THEN
  3502  12   45:4   516 				      ELSE
  3503  12   45:5   518 					BEGIN ERROR(137); GATTR.TYPTR:=NIL END;
  3504  12   45:4   527 				      IF ALLCONST THEN
  3505  12   45:5   530 					IF (GATTR.KIND = CST) AND
  3506  12   45:5   533 					   (GATTR.CVAL.IVAL <= 127) THEN
  3507  12   45:6   539 					    HIGHVAL := GATTR.CVAL.IVAL
  3508  12   45:5   539 					ELSE
  3509  12   45:6   544 					  BEGIN LOAD; ALLCONST := FALSE END
  3510  12   45:4   549 				      ELSE LOAD
  3511  12   45:3   551 				    END;
  3512  12   45:2   553 				  IF ALLCONST THEN
  3513  12   45:3   556 				    BEGIN IC := LIC; (*FORGET FIRST CONST*)
  3514  12   45:4   559 				      CSTPART := CSTPART + [LOWVAL..HIGHVAL]
  3515  12   45:3   569 				    END
  3516  12   45:2   574 				  ELSE
  3517  12   45:3   576 				    BEGIN GEN0(LOP);
  3518  12   45:4   579 				      IF VARPART THEN GEN0(28(*UNI*))
  3519  12   45:4   583 				      ELSE VARPART := TRUE
  3520  12   45:3   587 				    END;
  3521  12   45:2   590 				  LSP^.ELSET := GATTR.TYPTR;
  3522  12   45:2   595 				  GATTR.TYPTR := LSP
  3523  12   45:1   595 				END
  3524  12   45:0   598 			      ELSE ERROR(137);
  3525  12   45:8   606 			  TEST := SY <> COMMA;
  3526  12   45:8   612 			  IF NOT TEST THEN INSYMBOL
  3527  12   45:7   616 			UNTIL TEST;
  3528  12   45:7   622 			IF SY = RBRACK THEN INSYMBOL ELSE ERROR(12)
  3529  12   45:6   634 		      END;
  3530  12   45:5   637 		    IF VARPART THEN
  3531  12   45:6   640 		      BEGIN
  3532  12   45:7   640 			IF CSTPART <> [ ] THEN
  3533  12   45:8   650 			  BEGIN
  3534  12   45:9   650 			    SCONST^.PVAL := CSTPART;
  3535  12   45:9   663 			    SCONST^.CCLASS := PSET;
  3536  12   45:9   667 			    GATTR.CVAL.VALP := SCONST;
  3537  12   45:9   671 			    GATTR.KIND := CST;
  3538  12   45:9   674 			    LOAD; GEN0(28(*UNI*))
  3539  12   45:8   677 			  END;
  3540  12   45:7   679 			GATTR.KIND := EXPR
  3541  12   45:6   679 		      END
  3542  12   45:5   682 		    ELSE
  3543  12   45:6   684 		      BEGIN
  3544  12   45:7   684 			SCONST^.PVAL := CSTPART;
  3545  12   45:7   697 			SCONST^.CCLASS := PSET;
  3546  12   45:7   701 			GATTR.CVAL.VALP := SCONST;
  3547  12   45:7   705 			GATTR.KIND := CST
  3548  12   45:6   705 		      END
  3549  12   45:4   708 		  END
  3550  12   45:3   708 	      END (*CASE*) ;
  3551  12   45:3   816 	      IF NOT (SY IN FSYS) THEN
  3552  12   45:4   827 		BEGIN ERROR(6); SKIP(FSYS + FACBEGSYS) END
  3553  12   45:2   847 	    END (*WHILE*)
  3554  12   45:0   847 	END (*FACTOR*) ;
  3555  12   45:0   880 
  3556  12   44:0     0       BEGIN (*TERM*)
  3557  12   44:1     0 	FACTOR(FSYS + [MULOP]);
  3558  12   44:1    20 	WHILE SY = MULOP DO
  3559  12   44:2    26 	  BEGIN LOAD; LATTR := GATTR; LOP := OP;
  3560  12   44:3    38 	    INSYMBOL; FACTOR(FSYS + [MULOP]); LOAD;
  3561  12   44:3    62 	    IF (LATTR.TYPTR <> NIL) AND (GATTR.TYPTR <> NIL) THEN
  3562  12   44:4    71 	      CASE LOP OF
  3563  12   44:4    74       (***)     MUL:  BEGIN FLOATIT(LATTR.TYPTR,FALSE); STRETCHIT(LATTR.TYPTR);
  3564  12   44:6    83 			IF (LATTR.TYPTR = INTPTR) AND (GATTR.TYPTR = INTPTR)
  3565  12   44:6    89 			  THEN GEN0(15(*MPI*))
  3566  12   44:6    93 			ELSE
  3567  12   44:7    97 			  IF (LATTR.TYPTR = REALPTR) AND
  3568  12   44:7   101 			     (GATTR.TYPTR = REALPTR) THEN GEN0(16(*MPR*))
  3569  12   44:7   109 			  ELSE
  3570  12   44:8   113 			    IF (GATTR.TYPTR^.FORM = LONGINT) AND
  3571  12   44:8   117 			       (LATTR.TYPTR^.FORM = LONGINT) THEN
  3572  12   44:9   124 			      BEGIN GENLDC(8(*DMP*)); GENNR(DECOPS) END
  3573  12   44:8   130 			    ELSE
  3574  12   44:9   132 			      IF (LATTR.TYPTR^.FORM = POWER)
  3575  12   44:9   136 				  AND COMPTYPES(LATTR.TYPTR,GATTR.TYPTR) THEN
  3576  12   44:0   146 				GEN0(12(*INT*))
  3577  12   44:9   147 			      ELSE BEGIN ERROR(134); GATTR.TYPTR:=NIL END
  3578  12   44:5   160 		      END;
  3579  12   44:4   162       (*/*)     RDIV: BEGIN FLOATIT(LATTR.TYPTR,TRUE);
  3580  12   44:6   167 			IF (LATTR.TYPTR = REALPTR) AND
  3581  12   44:6   171 			   (GATTR.TYPTR = REALPTR) THEN GEN0(7(*DVR*))
  3582  12   44:6   179 			ELSE BEGIN ERROR(134); GATTR.TYPTR := NIL END
  3583  12   44:5   192 		      END;
  3584  12   44:4   194       (*DIV*)   IDIV: BEGIN STRETCHIT(LATTR.TYPTR);
  3585  12   44:6   198 			IF (LATTR.TYPTR = INTPTR) AND
  3586  12   44:6   201 			   (GATTR.TYPTR = INTPTR) THEN GEN0(6(*DVI*))
  3587  12   44:6   208 			ELSE
  3588  12   44:7   212 			  IF (LATTR.TYPTR^.FORM = LONGINT) AND
  3589  12   44:7   216 			     (GATTR.TYPTR^.FORM = LONGINT) THEN
  3590  12   44:8   223 			    BEGIN GENLDC(10(*DDV*)); GENNR(DECOPS) END
  3591  12   44:7   229 			  ELSE BEGIN ERROR(134); GATTR.TYPTR := NIL END
  3592  12   44:5   240 		      END;
  3593  12   44:4   242       (*MOD*)   IMOD: IF (LATTR.TYPTR = INTPTR) AND
  3594  12   44:5   245 			 (GATTR.TYPTR = INTPTR) THEN GEN0(14(*MOD*))
  3595  12   44:5   252 		      ELSE BEGIN ERROR(134); GATTR.TYPTR := NIL END;
  3596  12   44:4   267       (*AND*)   ANDOP:IF (LATTR.TYPTR = BOOLPTR) AND
  3597  12   44:5   271 			 (GATTR.TYPTR = BOOLPTR) THEN GEN0(4(*AND*))
  3598  12   44:5   279 		      ELSE BEGIN ERROR(134); GATTR.TYPTR := NIL END
  3599  12   44:4   292 	      END (*CASE*)
  3600  12   44:3   312 	    ELSE GATTR.TYPTR := NIL
  3601  12   44:2   314 	  END (*WHILE*)
  3602  12   44:0   317       END (*TERM*) ;
  3603  12   44:0   342 
  3604  12   43:0     0     BEGIN (*SIMPLEEXPRESSION*)
  3605  12   43:1     0       SIGNED := FALSE;
  3606  12   43:1     3       IF (SY = ADDOP) AND (OP IN [PLUS,MINUS]) THEN
  3607  12   43:2    15 	BEGIN SIGNED := OP = MINUS; INSYMBOL END;
  3608  12   43:1    24       TERM(FSYS + [ADDOP]);
  3609  12   43:1    44       IF SIGNED THEN
  3610  12   43:2    47 	BEGIN LOAD;
  3611  12   43:3    49 	  IF GATTR.TYPTR = INTPTR THEN GEN0(17(*NGI*))
  3612  12   43:3    55 	  ELSE
  3613  12   43:4    59 	    IF GATTR.TYPTR = REALPTR THEN GEN0(18(*NGR*))
  3614  12   43:4    66 	    ELSE
  3615  12   43:5    70 	      IF GATTR.TYPTR^.FORM = LONGINT THEN
  3616  12   43:6    76 	        BEGIN GENLDC(6(*DNG*)); GENNR(DECOPS) END
  3617  12   43:5    82 	      ELSE BEGIN ERROR(134); GATTR.TYPTR := NIL END
  3618  12   43:2    93 	END;
  3619  12   43:1    93       WHILE SY = ADDOP DO
  3620  12   43:2    99 	BEGIN LOAD; LATTR := GATTR; LOP := OP;
  3621  12   43:3   111 	  INSYMBOL; TERM(FSYS + [ADDOP]); LOAD;
  3622  12   43:3   136 	  IF (LATTR.TYPTR <> NIL) AND (GATTR.TYPTR <> NIL) THEN
  3623  12   43:4   145 	    CASE LOP OF
  3624  12   43:4   148     (*+*)     PLUS:
  3625  12   43:5   148 		BEGIN FLOATIT(LATTR.TYPTR,FALSE); STRETCHIT(LATTR.TYPTR);
  3626  12   43:6   157 		  IF (LATTR.TYPTR = INTPTR)AND(GATTR.TYPTR = INTPTR) THEN
  3627  12   43:7   166 		    GEN0(2(*ADI*))
  3628  12   43:6   167 		  ELSE
  3629  12   43:7   171 		    IF (LATTR.TYPTR = REALPTR)AND(GATTR.TYPTR = REALPTR) THEN
  3630  12   43:8   182 		      GEN0(3(*ADR*))
  3631  12   43:7   183 		    ELSE
  3632  12   43:8   187 		      IF (GATTR.TYPTR^.FORM = LONGINT) AND
  3633  12   43:8   191 			 (LATTR.TYPTR^.FORM = LONGINT) THEN
  3634  12   43:9   198 			BEGIN GENLDC(2(*DAD*)); GENNR(DECOPS) END
  3635  12   43:8   204 		      ELSE
  3636  12   43:9   206 			IF (LATTR.TYPTR^.FORM = POWER)
  3637  12   43:9   210 			   AND COMPTYPES(LATTR.TYPTR,GATTR.TYPTR) THEN
  3638  12   43:0   220 			  GEN0(28(*UNI*))
  3639  12   43:9   221 			ELSE BEGIN ERROR(134); GATTR.TYPTR := NIL END
  3640  12   43:5   234 		END;
  3641  12   43:4   236     (*-*)     MINUS:
  3642  12   43:5   236 		BEGIN FLOATIT(LATTR.TYPTR,FALSE); STRETCHIT(LATTR.TYPTR);
  3643  12   43:6   245 		  IF (LATTR.TYPTR = INTPTR) AND (GATTR.TYPTR = INTPTR) THEN
  3644  12   43:7   254 		    GEN0(21(*SBI*))
  3645  12   43:6   255 		  ELSE
  3646  12   43:7   259 		    IF (LATTR.TYPTR = REALPTR) AND (GATTR.TYPTR = REALPTR)
  3647  12   43:7   267 		      THEN GEN0(22(*SBR*))
  3648  12   43:7   271 		    ELSE
  3649  12   43:8   275 		      IF (GATTR.TYPTR^.FORM = LONGINT) AND
  3650  12   43:8   279 			 (LATTR.TYPTR^.FORM = LONGINT) THEN
  3651  12   43:9   286 			BEGIN GENLDC(4(*DSB*)); GENNR(DECOPS) END
  3652  12   43:8   292 		      ELSE
  3653  12   43:9   294 			IF (LATTR.TYPTR^.FORM = POWER)
  3654  12   43:9   298 			    AND COMPTYPES(LATTR.TYPTR,GATTR.TYPTR) THEN
  3655  12   43:0   308 			  GEN0(5(*DIF*))
  3656  12   43:9   309 			ELSE BEGIN ERROR(134); GATTR.TYPTR := NIL END
  3657  12   43:5   322 		END;
  3658  12   43:4   324     (*OR*)    OROP:
  3659  12   43:5   324 		IF (LATTR.TYPTR = BOOLPTR) AND (GATTR.TYPTR = BOOLPTR) THEN
  3660  12   43:6   335 		  GEN0(13(*IOR*))
  3661  12   43:5   336 		ELSE BEGIN ERROR(134); GATTR.TYPTR := NIL END
  3662  12   43:4   349 	    END (*CASE*)
  3663  12   43:3   364 	  ELSE GATTR.TYPTR := NIL
  3664  12   43:2   366 	END (*WHILE*)
  3665  12   43:0   369     END (*SIMPLEEXPRESSION*) ;
  3666  12   43:0   394 
  3667  12   46:D     1     PROCEDURE MAKEPA(VAR STRGFSP: STP; PAFSP: STP);
  3668  12   46:D     3       VAR LMIN,LMAX: INTEGER;
  3669  12   46:0     0     BEGIN
  3670  12   46:1     0       IF PAFSP^.INXTYPE <> NIL THEN
  3671  12   46:2     6 	BEGIN GETBOUNDS(PAFSP^.INXTYPE,LMIN,LMAX);
  3672  12   46:3    15 	  IF LMAX-LMIN+1 <> STRGFSP^.MAXLENG THEN ERROR(129)
  3673  12   46:2    30 	END;
  3674  12   46:1    33       STRGFSP := PAFSP
  3675  12   46:0    34     END (*MAKEPA*) ;
  3676  12   46:0    48 
  3677  12   19:0     0   BEGIN (*EXPRESSION*)
  3678  12   19:1     0     SIMPLEEXPRESSION(FSYS + [RELOP]);
  3679  12   19:1    20     IF SY = RELOP THEN
  3680  12   19:2    26       BEGIN
  3681  12   19:3    26 	LSTRING := (GATTR.KIND = CST) AND
  3682  12   19:3    29 		(STRGTYPE(GATTR.TYPTR) OR (GATTR.TYPTR = CHARPTR));
  3683  12   19:3    43 	IF GATTR.TYPTR <> NIL THEN
  3684  12   19:4    48 	  IF GATTR.TYPTR^.FORM <= POWER THEN LOAD
  3685  12   19:4    54 	  ELSE LOADADDRESS;
  3686  12   19:3    60 	LATTR := GATTR; LOP := OP; LSTRGIC := STRGCSTIC;
  3687  12   19:3    74 	INSYMBOL; SIMPLEEXPRESSION(FSYS);
  3688  12   19:3    86 	GSTRING := (GATTR.KIND = CST) AND
  3689  12   19:3    89 		(STRGTYPE(GATTR.TYPTR) OR (GATTR.TYPTR = CHARPTR));
  3690  12   19:3   103 	IF GATTR.TYPTR <> NIL THEN
  3691  12   19:4   108 	  IF GATTR.TYPTR^.FORM <= POWER THEN LOAD
  3692  12   19:4   114 	  ELSE LOADADDRESS;
  3693  12   19:3   120 	IF (LATTR.TYPTR <> NIL) AND (GATTR.TYPTR <> NIL) THEN
  3694  12   19:4   129 	  IF LOP = INOP THEN
  3695  12   19:5   134 	    IF GATTR.TYPTR^.FORM = POWER THEN
  3696  12   19:6   140 	      IF COMPTYPES(LATTR.TYPTR,GATTR.TYPTR^.ELSET) THEN
  3697  12   19:7   150 		GEN0(11(*INN*))
  3698  12   19:6   151 	      ELSE BEGIN ERROR(129); GATTR.TYPTR := NIL END
  3699  12   19:5   164 	    ELSE BEGIN ERROR(130); GATTR.TYPTR := NIL END
  3700  12   19:4   175 	  ELSE
  3701  12   19:5   177 	    BEGIN
  3702  12   19:6   177 	      IF LATTR.TYPTR <> GATTR.TYPTR THEN
  3703  12   19:7   182 		BEGIN FLOATIT(LATTR.TYPTR,FALSE); STRETCHIT(LATTR.TYPTR) END;
  3704  12   19:6   191 	      IF LSTRING THEN
  3705  12   19:7   194 		BEGIN
  3706  12   19:8   194 		  IF PAOFCHAR(GATTR.TYPTR) THEN
  3707  12   19:9   202 		    IF NOT GATTR.TYPTR^.AISSTRNG THEN
  3708  12   19:0   207 		      BEGIN STRGTOPA(LSTRGIC);
  3709  12   19:1   210 			MAKEPA(LATTR.TYPTR,GATTR.TYPTR)
  3710  12   19:0   213 		      END
  3711  12   19:7   215 		END
  3712  12   19:6   215 	      ELSE
  3713  12   19:7   217 		IF GSTRING THEN
  3714  12   19:8   220 		  BEGIN
  3715  12   19:9   220 		    IF PAOFCHAR(LATTR.TYPTR) THEN
  3716  12   19:0   228 		      IF NOT LATTR.TYPTR^.AISSTRNG THEN
  3717  12   19:1   233 			BEGIN STRGTOPA(STRGCSTIC);
  3718  12   19:2   237 			  MAKEPA(GATTR.TYPTR,LATTR.TYPTR)
  3719  12   19:1   240 			END;
  3720  12   19:8   242 		  END;
  3721  12   19:6   242 	      IF (LSTRING AND STRGTYPE(GATTR.TYPTR)) OR
  3722  12   19:6   250 		 (GSTRING AND STRGTYPE(LATTR.TYPTR)) THEN GOTO 1;
  3723  12   19:6   263 	      IF COMPTYPES(LATTR.TYPTR,GATTR.TYPTR) THEN
  3724  12   19:7   272 		BEGIN LSIZE := LATTR.TYPTR^.SIZE; (*INVALID FOR LONG INTEGERS*)
  3725  12   19:8   276 		  CASE LATTR.TYPTR^.FORM OF
  3726  12   19:8   280 		    SCALAR:
  3727  12   19:9   280 		      IF LATTR.TYPTR = REALPTR THEN TYPIND := 1
  3728  12   19:9   286 		      ELSE
  3729  12   19:0   291 			IF LATTR.TYPTR = BOOLPTR THEN TYPIND := 3
  3730  12   19:0   297 			ELSE TYPIND := 0;
  3731  12   19:8   307 		    POINTER:
  3732  12   19:9   307 		      BEGIN
  3733  12   19:0   307 			IF LOP IN [LTOP,LEOP,GTOP,GEOP] THEN ERROR(131);
  3734  12   19:0   321 			TYPIND := 0
  3735  12   19:9   321 		      END;
  3736  12   19:8   326 		    LONGINT: TYPIND := 7;
  3737  12   19:8   331 		    POWER:
  3738  12   19:9   331 		      BEGIN
  3739  12   19:0   331 			IF LOP IN [LTOP,GTOP] THEN ERROR(132);
  3740  12   19:0   345 			TYPIND := 4
  3741  12   19:9   345 		      END;
  3742  12   19:8   350 		    ARRAYS:
  3743  12   19:9   350 		      BEGIN
  3744  12   19:0   350 			TYPIND := 6;
  3745  12   19:0   353 			IF PAOFCHAR(LATTR.TYPTR) THEN
  3746  12   19:1   361 			  IF LATTR.TYPTR^.AISSTRNG THEN
  3747  12   19:2   365 		1:	    TYPIND := 2
  3748  12   19:1   365 			  ELSE
  3749  12   19:2   370 			    BEGIN TYPIND := 5;
  3750  12   19:3   373 			      IF LATTR.TYPTR^.INXTYPE <> NIL THEN
  3751  12   19:4   379 				BEGIN
  3752  12   19:5   379 				  GETBOUNDS(LATTR.TYPTR^.INXTYPE,LMIN,LMAX);
  3753  12   19:5   388 				  LSIZE := LMAX - LMIN + 1
  3754  12   19:4   392 				END
  3755  12   19:2   396 			    END
  3756  12   19:0   396 			ELSE
  3757  12   19:1   398 			  IF LOP IN [LTOP,LEOP,GTOP,GEOP] THEN ERROR(131)
  3758  12   19:9   409 		      END;
  3759  12   19:8   414 		    RECORDS:
  3760  12   19:9   414 		      BEGIN
  3761  12   19:0   414 			IF LOP IN [LTOP,LEOP,GTOP,GEOP] THEN ERROR(131);
  3762  12   19:0   428 			TYPIND := 6
  3763  12   19:9   428 		      END;
  3764  12   19:8   433 		    FILES:
  3765  12   19:9   433 		      BEGIN ERROR(133); TYPIND := 0 END
  3766  12   19:8   442 		  END;
  3767  12   19:8   468 		  IF TYPIND = 7 THEN
  3768  12   19:9   473 		    BEGIN GENLDC(ORD(LOP)); GENLDC(16(*DCMP*));
  3769  12   19:0   479 		      GENNR(DECOPS)
  3770  12   19:9   480 		    END
  3771  12   19:8   482 		  ELSE
  3772  12   19:9   484 		    CASE LOP OF
  3773  12   19:9   487 		      LTOP: GEN2(53(*LES*),TYPIND,LSIZE);
  3774  12   19:9   494 		      LEOP: GEN2(52(*LEQ*),TYPIND,LSIZE);
  3775  12   19:9   501 		      GTOP: GEN2(49(*GRT*),TYPIND,LSIZE);
  3776  12   19:9   508 		      GEOP: GEN2(48(*GEQ*),TYPIND,LSIZE);
  3777  12   19:9   515 		      NEOP: GEN2(55(*NEQ*),TYPIND,LSIZE);
  3778  12   19:9   522 		      EQOP: GEN2(47(*EQU*),TYPIND,LSIZE)
  3779  12   19:9   525 		    END
  3780  12   19:7   548 		END
  3781  12   19:6   548 	      ELSE ERROR(129)
  3782  12   19:5   553 	    END;
  3783  12   19:3   556 	GATTR.TYPTR := BOOLPTR; GATTR.KIND := EXPR
  3784  12   19:2   560       END (*SY = RELOP*)
  3785  12   19:0   563   END (*EXPRESSION*) ;
  3786  12   19:0   588 
  3787  12   19:0   588 (* --- BODYPART.E.TEXT --- *)
  3788  12   19:0   588 
  3789  12   19:0   588 (*    COPYRIGHT (C) 1979, REGENTS OF THE	*)
  3790  12   19:0   588 (*    UNIVERSITY OF CALIFORNIA, SAN DIEGO	*)
  3791  12   19:0   588 
  3792  12   47:D     1   PROCEDURE STATEMENT(FSYS: SETOFSYS);
  3793  12   47:D     5     LABEL 1;
  3794  12   47:D     5     VAR LCP: CTP; TTOP: DISPRANGE; LLP: LABELP; HEAP: ^INTEGER;
  3795  12   47:D     9 
  3796  12   48:D     1     PROCEDURE ASSIGNMENT(FCP: CTP);
  3797  12   48:D     2       VAR LATTR: ATTR; CSTRING,PAONLEFT: BOOLEAN; LMIN,LMAX: INTEGER;
  3798  12   48:0     0     BEGIN SELECTOR(FSYS + [BECOMES],FCP);
  3799  12   48:1    16       IF SY = BECOMES THEN
  3800  12   48:2    22 	BEGIN LMAX := 0; CSTRING := FALSE;
  3801  12   48:3    28 	  IF GATTR.TYPTR <> NIL THEN
  3802  12   48:4    33 	    IF (GATTR.ACCESS = INDRCT) OR (GATTR.TYPTR^.FORM > POWER) THEN
  3803  12   48:5    43 	      LOADADDRESS;
  3804  12   48:3    45 	  PAONLEFT := PAOFCHAR(GATTR.TYPTR);
  3805  12   48:3    53 	  LATTR := GATTR;
  3806  12   48:3    59 	  INSYMBOL; EXPRESSION(FSYS);
  3807  12   48:3    72 	  IF GATTR.KIND = CST THEN
  3808  12   48:4    77 	    CSTRING := (GATTR.TYPTR = CHARPTR) OR STRGTYPE(GATTR.TYPTR);
  3809  12   48:3    90 	  IF GATTR.TYPTR <> NIL THEN
  3810  12   48:4    95 	    IF GATTR.TYPTR^.FORM <= POWER THEN LOAD
  3811  12   48:4   101 	    ELSE LOADADDRESS;
  3812  12   48:3   107 	  IF (LATTR.TYPTR <> NIL) AND (GATTR.TYPTR <> NIL) THEN
  3813  12   48:4   116 	    BEGIN
  3814  12   48:5   116 	      IF GATTR.TYPTR = INTPTR THEN
  3815  12   48:6   121 		IF COMPTYPES(REALPTR,LATTR.TYPTR) THEN
  3816  12   48:7   131 		  BEGIN GEN0(10(*FLT*)); GATTR.TYPTR := REALPTR END;
  3817  12   48:5   138 	      IF COMPTYPES(LONGINTPTR,LATTR.TYPTR) THEN
  3818  12   48:6   148 		BEGIN
  3819  12   48:7   148 		  IF GATTR.TYPTR = INTPTR THEN
  3820  12   48:8   153 		    BEGIN GENLDC(18(*DCVT*)); GENNR(DECOPS);
  3821  12   48:9   159 		      GATTR.TYPTR := LONGINTPTR
  3822  12   48:8   159 		    END;
  3823  12   48:7   163 		  IF GATTR.TYPTR^.FORM <> LONGINT THEN
  3824  12   48:8   169 		    BEGIN ERROR(129); GATTR.TYPTR := LONGINTPTR END
  3825  12   48:6   179 		END;
  3826  12   48:5   179 	      IF PAONLEFT THEN
  3827  12   48:6   182 		IF LATTR.TYPTR^.AISSTRNG THEN
  3828  12   48:7   186 		  IF CSTRING AND (GATTR.TYPTR = CHARPTR) THEN
  3829  12   48:8   194 		    GATTR.TYPTR := STRGPTR
  3830  12   48:7   194 		  ELSE
  3831  12   48:6   200 		ELSE
  3832  12   48:7   202 		  IF LATTR.TYPTR^.INXTYPE <> NIL THEN
  3833  12   48:8   208 		    BEGIN GETBOUNDS(LATTR.TYPTR^.INXTYPE,LMIN,LMAX);
  3834  12   48:9   217 		      LMAX := LMAX - LMIN + 1;
  3835  12   48:9   224 		      IF CSTRING AND (GATTR.TYPTR <> CHARPTR) THEN
  3836  12   48:0   232 			BEGIN STRGTOPA(STRGCSTIC);
  3837  12   48:1   236 			  IF LMAX <> GATTR.TYPTR^.MAXLENG THEN ERROR(129);
  3838  12   48:1   249 			  GATTR.TYPTR := LATTR.TYPTR
  3839  12   48:0   249 			END
  3840  12   48:8   252 		    END
  3841  12   48:7   252 		  ELSE GATTR.TYPTR := LATTR.TYPTR;
  3842  12   48:5   257 	      IF COMPTYPES(LATTR.TYPTR,GATTR.TYPTR) THEN
  3843  12   48:6   266 		CASE LATTR.TYPTR^.FORM OF
  3844  12   48:6   270 		  SUBRANGE: BEGIN
  3845  12   48:8   270 			      IF RANGECHECK THEN
  3846  12   48:9   274 				BEGIN
  3847  12   48:0   274 				  GENLDC(LATTR.TYPTR^.MIN.IVAL);
  3848  12   48:0   278 				  GENLDC(LATTR.TYPTR^.MAX.IVAL);
  3849  12   48:0   282 				  GEN0(8(*CHK*))
  3850  12   48:9   283 				END;
  3851  12   48:8   285 			      STORE(LATTR)
  3852  12   48:7   287 			    END;
  3853  12   48:6   291 		  POWER:    BEGIN
  3854  12   48:8   291 			      GEN1(32(*ADJ*),LATTR.TYPTR^.SIZE);
  3855  12   48:8   296 			      STORE(LATTR)
  3856  12   48:7   298 			    END;
  3857  12   48:6   302 		  SCALAR,
  3858  12   48:6   302 		  POINTER:  STORE(LATTR);
  3859  12   48:6   308 		  LONGINT: BEGIN
  3860  12   48:8   308 			      GENLDC(LATTR.TYPTR^.SIZE);
  3861  12   48:8   312 			      GENLDC(0(*DAJ*));
  3862  12   48:8   315 			      GENNR(DECOPS);
  3863  12   48:8   318 			      STORE(LATTR)
  3864  12   48:7   320 			    END;
  3865  12   48:6   324 		  ARRAYS:  IF PAONLEFT THEN
  3866  12   48:8   327 			     IF LATTR.TYPTR^.AISSTRNG THEN
  3867  12   48:9   331 			       GEN1(42(*SAS*),LATTR.TYPTR^.MAXLENG)
  3868  12   48:8   335 			     ELSE GEN1(40(*MOV*),(LMAX+1) DIV 2)
  3869  12   48:7   345 			   ELSE GEN1(40(*MOV*),LATTR.TYPTR^.SIZE);
  3870  12   48:6   356 		  RECORDS: GEN1(40(*MOV*),LATTR.TYPTR^.SIZE);
  3871  12   48:6   363 		  FILES:   ERROR(146)
  3872  12   48:6   366 		END
  3873  12   48:5   394 	      ELSE ERROR(129)
  3874  12   48:4   399 	    END
  3875  12   48:2   402 	END (*SY = BECOMES*)
  3876  12   48:1   402       ELSE ERROR(51)
  3877  12   48:0   405     END (*ASSIGNMENT*) ;
  3878  12   48:0   426 
  3879  12   49:D     1     PROCEDURE GOTOSTATEMENT;
  3880  12   49:D     1       VAR LLP: LABELP; FOUND: BOOLEAN; TTOP: DISPRANGE;
  3881  12   49:0     0     BEGIN
  3882  12   49:1     0       IF NOT GOTOOK THEN ERROR(6);
  3883  12   49:1     9       IF SY = INTCONST THEN
  3884  12   49:2    15 	BEGIN
  3885  12   49:3    15 	  FOUND := FALSE; TTOP := TOP;
  3886  12   49:3    21 	  WHILE DISPLAY[TTOP].OCCUR <> BLCK DO TTOP := TTOP - 1;
  3887  12   49:3    38 	  LLP := DISPLAY[TTOP].FLABEL;
  3888  12   49:3    46 	  WHILE (LLP <> NIL) AND NOT FOUND DO
  3889  12   49:4    54 	    WITH LLP^ DO
  3890  12   49:5    57 	      IF LABVAL = VAL.IVAL THEN
  3891  12   49:6    64 		BEGIN FOUND := TRUE;
  3892  12   49:7    67 		  GENJMP(57(*UJP*),CODELBP)
  3893  12   49:6    70 		END
  3894  12   49:5    72 	      ELSE LLP := NEXTLAB;
  3895  12   49:3    80 	  IF NOT FOUND THEN ERROR(167);
  3896  12   49:3    90 	  INSYMBOL
  3897  12   49:2    90 	END
  3898  12   49:1    93       ELSE ERROR(15)
  3899  12   49:0    96     END (*GOTOSTATEMENT*) ;
  3900  12   49:0   116 
  3901  12   50:D     1     PROCEDURE COMPOUNDSTATEMENT;
  3902  12   50:0     0     BEGIN
  3903  12   50:1     0       REPEAT
  3904  12   50:2     0 	REPEAT STATEMENT(FSYS + [SEMICOLON,ENDSY])
  3905  12   50:2    13 	UNTIL NOT (SY IN STATBEGSYS);
  3906  12   50:2    26 	TEST := SY <> SEMICOLON;
  3907  12   50:2    32 	IF NOT TEST THEN INSYMBOL
  3908  12   50:1    36       UNTIL TEST;
  3909  12   50:1    42       IF SY = ENDSY THEN INSYMBOL ELSE ERROR(13)
  3910  12   50:0    54     END (*COMPOUNDSTATEMENET*) ;
  3911  12   50:0    74 
  3912  12   51:D     1     PROCEDURE IFSTATEMENT;
  3913  12   51:D     1       VAR LCIX1,LCIX2: LBP; LIC: INTEGER; CONDCOMPILE,NOTHENCLAUSE: BOOLEAN;
  3914  12   51:0     0     BEGIN
  3915  12   51:1     0       CONDCOMPILE := FALSE;
  3916  12   51:1     3       EXPRESSION(FSYS + [THENSY]);
  3917  12   51:1    18       IF (GATTR.KIND = CST) THEN
  3918  12   51:2    23 	IF (GATTR.TYPTR = BOOLPTR) THEN
  3919  12   51:3    29 	  BEGIN CONDCOMPILE := TRUE;
  3920  12   51:4    32 	    NOTHENCLAUSE := NOT ODD(GATTR.CVAL.IVAL);
  3921  12   51:4    36 	    LIC := IC
  3922  12   51:3    36 	  END;
  3923  12   51:1    39       IF NOT CONDCOMPILE THEN
  3924  12   51:2    43         BEGIN GENLABEL(LCIX1); GENFJP(LCIX1) END;
  3925  12   51:1    50       IF SY = THENSY THEN INSYMBOL ELSE ERROR(52);
  3926  12   51:1    65       STATEMENT(FSYS + [ELSESY]);
  3927  12   51:1    80       IF CONDCOMPILE THEN
  3928  12   51:2    83 	IF NOTHENCLAUSE THEN IC := LIC
  3929  12   51:2    86 	ELSE LIC := IC;
  3930  12   51:1    94       IF SY = ELSESY THEN
  3931  12   51:2   100 	BEGIN
  3932  12   51:3   100 	  IF NOT CONDCOMPILE THEN
  3933  12   51:4   104 	    BEGIN GENLABEL(LCIX2); GENJMP(57(*UJP*),LCIX2); PUTLABEL(LCIX1) END;
  3934  12   51:3   115 	  INSYMBOL; STATEMENT(FSYS);
  3935  12   51:3   128 	  IF CONDCOMPILE THEN
  3936  12   51:4   131 	    BEGIN
  3937  12   51:5   131 	      IF NOT NOTHENCLAUSE THEN IC := LIC
  3938  12   51:4   135 	    END
  3939  12   51:3   138 	  ELSE PUTLABEL(LCIX2)
  3940  12   51:2   141 	END
  3941  12   51:1   143       ELSE
  3942  12   51:2   145 	IF NOT CONDCOMPILE THEN PUTLABEL(LCIX1)
  3943  12   51:0   150     END (*IFSTATEMENT*) ;
  3944  12   51:0   164 
  3945  12   52:D     1     PROCEDURE CASESTATEMENT;
  3946  12   52:D     1       LABEL 1;
  3947  12   52:D     1       TYPE CIP = ^CASEINFO;
  3948  12   52:D     1 	   CASEINFO = RECORD
  3949  12   52:D     1 			NEXT: CIP;
  3950  12   52:D     1 			CSSTART: INTEGER;
  3951  12   52:D     1 			CSLAB: INTEGER
  3952  12   52:D     1 		      END;
  3953  12   52:D     1       VAR LSP,LSP1: STP; FSTPTR,LPT1,LPT2,LPT3: CIP; LVAL: VALU;
  3954  12   52:D     8 	  LADDR, LCIX: LBP; NULSTMT, LMIN, LMAX: INTEGER;
  3955  12   52:0     0     BEGIN EXPRESSION(FSYS + [OFSY,COMMA,COLON]);
  3956  12   52:1    15       LOAD; GENLABEL(LCIX); GENJMP(57(*UJP*),LCIX);
  3957  12   52:1    25       LSP := GATTR.TYPTR;
  3958  12   52:1    28       IF LSP <> NIL THEN
  3959  12   52:2    33 	IF (LSP^.FORM <> SCALAR) OR (LSP = REALPTR) THEN
  3960  12   52:3    44 	  BEGIN ERROR(144); LSP := NIL END;
  3961  12   52:1    53       IF SY = OFSY THEN INSYMBOL ELSE ERROR(8);
  3962  12   52:1    68       FSTPTR := NIL; GENLABEL(LADDR);
  3963  12   52:1    75       REPEAT
  3964  12   52:2    75 	LPT3 := NIL;
  3965  12   52:2    78 	REPEAT CONSTANT(FSYS + [COMMA,COLON],LSP1,LVAL);
  3966  12   52:3    96 	  IF LSP <> NIL THEN
  3967  12   52:4   101 	    IF COMPTYPES(LSP,LSP1) THEN
  3968  12   52:5   110 	      BEGIN LPT1 := FSTPTR; LPT2 := NIL;
  3969  12   52:6   116 		WHILE LPT1 <> NIL DO
  3970  12   52:7   121 		  WITH LPT1^ DO
  3971  12   52:8   124 		    BEGIN
  3972  12   52:9   124 		      IF CSLAB <= LVAL.IVAL THEN
  3973  12   52:0   130 			BEGIN IF CSLAB = LVAL.IVAL THEN ERROR(156);
  3974  12   52:1   142 			  GOTO 1
  3975  12   52:0   144 			END;
  3976  12   52:9   144 		      LPT2 := LPT1; LPT1 := NEXT
  3977  12   52:8   147 		    END;
  3978  12   52:6   153     1:          NEW(LPT3);
  3979  12   52:6   158 		WITH LPT3^ DO
  3980  12   52:7   161 		  BEGIN NEXT := LPT1; CSLAB := LVAL.IVAL;
  3981  12   52:8   169 		    CSSTART := IC
  3982  12   52:7   172 		  END;
  3983  12   52:6   174 		IF LPT2 = NIL THEN FSTPTR := LPT3
  3984  12   52:6   179 		ELSE LPT2^.NEXT := LPT3
  3985  12   52:5   185 	      END
  3986  12   52:4   187 	    ELSE ERROR(147);
  3987  12   52:3   195 	  TEST := SY <> COMMA;
  3988  12   52:3   201 	  IF NOT TEST THEN INSYMBOL
  3989  12   52:2   205 	UNTIL TEST;
  3990  12   52:2   211 	IF SY = COLON THEN INSYMBOL ELSE ERROR(5);
  3991  12   52:2   226 	REPEAT STATEMENT(FSYS + [SEMICOLON])
  3992  12   52:2   237 	UNTIL NOT (SY IN STATBEGSYS);
  3993  12   52:2   250 	IF LPT3 <> NIL THEN
  3994  12   52:3   255 	  GENJMP(57(*UJP*),LADDR);
  3995  12   52:2   259 	TEST := SY <> SEMICOLON;
  3996  12   52:2   265 	IF NOT TEST THEN INSYMBOL
  3997  12   52:1   269       UNTIL TEST OR (SY = ENDSY);
  3998  12   52:1   280       PUTLABEL(LCIX);
  3999  12   52:1   283       IF FSTPTR <> NIL THEN
  4000  12   52:2   288 	BEGIN LMAX := FSTPTR^.CSLAB;
  4001  12   52:3   292 	  LPT1 := FSTPTR; FSTPTR := NIL;
  4002  12   52:3   298 	  REPEAT LPT2 := LPT1^.NEXT; LPT1^.NEXT := FSTPTR;
  4003  12   52:4   305 	    FSTPTR := LPT1; LPT1 := LPT2
  4004  12   52:3   308 	  UNTIL LPT1 = NIL;
  4005  12   52:3   316 	  LMIN := FSTPTR^.CSLAB;
  4006  12   52:3   320 	      GEN0(44(*XJP*));
  4007  12   52:3   323 	      GENWORD(LMIN); GENWORD(LMAX);
  4008  12   52:3   331 	      NULSTMT := IC;
  4009  12   52:3   334 	      GENJMP(57(*UJP*),LADDR);
  4010  12   52:3   338 	      REPEAT
  4011  12   52:4   338 		WITH FSTPTR^ DO
  4012  12   52:5   341 		  BEGIN
  4013  12   52:6   341 		    WHILE CSLAB > LMIN DO
  4014  12   52:7   347 		      BEGIN GENWORD(IC-NULSTMT); LMIN := LMIN + 1 END;
  4015  12   52:6   360 		    GENWORD(IC-CSSTART);
  4016  12   52:6   367 		    FSTPTR := NEXT; LMIN := LMIN + 1
  4017  12   52:5   372 		  END
  4018  12   52:3   376 	      UNTIL FSTPTR = NIL;
  4019  12   52:3   381 	      PUTLABEL(LADDR)
  4020  12   52:2   382 	END;
  4021  12   52:1   384 	IF SY = ENDSY THEN INSYMBOL ELSE ERROR(13)
  4022  12   52:0   396     END (*CASESTATEMENT*) ;
  4023  12   52:0   426 
  4024  12   53:D     1     PROCEDURE REPEATSTATEMENT;
  4025  12   53:D     1       VAR LADDR: LBP;
  4026  12   53:0     0     BEGIN GENLABEL(LADDR); PUTLABEL(LADDR);
  4027  12   53:1     7       REPEAT
  4028  12   53:2     7 	REPEAT STATEMENT(FSYS + [SEMICOLON,UNTILSY])
  4029  12   53:2    20 	UNTIL NOT (SY IN STATBEGSYS);
  4030  12   53:2    33 	TEST := SY <> SEMICOLON;
  4031  12   53:2    39 	IF NOT TEST THEN INSYMBOL
  4032  12   53:1    43       UNTIL TEST;
  4033  12   53:1    49       IF SY = UNTILSY THEN
  4034  12   53:2    55 	BEGIN INSYMBOL; EXPRESSION(FSYS); GENFJP(LADDR)
  4035  12   53:2    69 	END
  4036  12   53:1    71       ELSE ERROR(53)
  4037  12   53:0    74     END (*REPEATSTATEMENT*) ;
  4038  12   53:0    94 
  4039  12   54:D     1     PROCEDURE WHILESTATEMENT;
  4040  12   54:D     1       VAR LADDR, LCIX: LBP;
  4041  12   54:0     0     BEGIN GENLABEL(LADDR); PUTLABEL(LADDR);
  4042  12   54:1     7       EXPRESSION(FSYS + [DOSY]); GENLABEL(LCIX); GENFJP(LCIX);
  4043  12   54:1    27       IF SY = DOSY THEN INSYMBOL ELSE ERROR(54);
  4044  12   54:1    42       STATEMENT(FSYS); GENJMP(57(*UJP*),LADDR); PUTLABEL(LCIX)
  4045  12   54:0    57     END (*WHILESTATEMENT*) ;
  4046  12   54:0    72 
  4047  12   55:D     1     PROCEDURE FORSTATEMENT;
  4048  12   55:D     1       VAR LATTR: ATTR; LSP: STP;  LSY: SYMBOL;
  4049  12   55:D     8 	  LCIX, LADDR: LBP;
  4050  12   55:0     0     BEGIN
  4051  12   55:1     0       IF SY = IDENT THEN
  4052  12   55:2     6 	BEGIN SEARCHID(VARS,LCP);
  4053  12   55:3    17 	  WITH LCP^, LATTR DO
  4054  12   55:4    22 	    BEGIN TYPTR := IDTYPE; KIND := VARBL;
  4055  12   55:5    29 	      IF KLASS = ACTUALVARS THEN
  4056  12   55:6    36 		BEGIN ACCESS := DRCT; VLEVEL := VLEV;
  4057  12   55:7    44 		  DPLMT := VADDR
  4058  12   55:6    44 		END
  4059  12   55:5    49 	      ELSE BEGIN ERROR(155); TYPTR := NIL END
  4060  12   55:4    60 	    END;
  4061  12   55:3    60 	  IF LATTR.TYPTR <> NIL THEN
  4062  12   55:4    65 	    IF (LATTR.TYPTR^.FORM > SUBRANGE)
  4063  12   55:4    69 	       OR COMPTYPES(REALPTR,LATTR.TYPTR) THEN
  4064  12   55:5    80 	      BEGIN ERROR(143); LATTR.TYPTR := NIL END;
  4065  12   55:3    89 	  INSYMBOL
  4066  12   55:2    89 	END
  4067  12   55:1    92       ELSE
  4068  12   55:2    94 	BEGIN ERROR(2); SKIP(FSYS + [BECOMES,TOSY,DOWNTOSY,DOSY])
  4069  12   55:2   111 	END;
  4070  12   55:1   114       IF SY = BECOMES THEN
  4071  12   55:2   120 	BEGIN INSYMBOL; EXPRESSION(FSYS + [TOSY,DOWNTOSY,DOSY]);
  4072  12   55:3   138 	  IF GATTR.TYPTR <> NIL THEN
  4073  12   55:4   143 	    IF GATTR.TYPTR^.FORM <> SCALAR THEN ERROR(144)
  4074  12   55:4   152 	      ELSE
  4075  12   55:5   157 		IF COMPTYPES(LATTR.TYPTR,GATTR.TYPTR) THEN
  4076  12   55:6   166 		  BEGIN LOAD;
  4077  12   55:7   168 		    IF LATTR.TYPTR <> NIL THEN
  4078  12   55:8   173 		      IF (LATTR.TYPTR^.FORM = SUBRANGE) AND RANGECHECK THEN
  4079  12   55:9   182 			BEGIN
  4080  12   55:0   182 			  GENLDC(LATTR.TYPTR^.MIN.IVAL);
  4081  12   55:0   186 			  GENLDC(LATTR.TYPTR^.MAX.IVAL);
  4082  12   55:0   190 			  GEN0(8(*CHK*))
  4083  12   55:9   191 			END;
  4084  12   55:7   193 		    STORE(LATTR)
  4085  12   55:6   195 		  END
  4086  12   55:5   197 		ELSE ERROR(145)
  4087  12   55:2   202 	END
  4088  12   55:1   205       ELSE
  4089  12   55:2   207 	BEGIN ERROR(51); SKIP(FSYS + [TOSY,DOWNTOSY,DOSY]) END;
  4090  12   55:1   227       GENLABEL(LADDR);
  4091  12   55:1   231       IF SY IN [TOSY,DOWNTOSY] THEN
  4092  12   55:2   240 	BEGIN LSY := SY; INSYMBOL; EXPRESSION(FSYS + [DOSY]);
  4093  12   55:3   260 	  IF GATTR.TYPTR <> NIL THEN
  4094  12   55:4   265 	    IF GATTR.TYPTR^.FORM <> SCALAR THEN ERROR(144)
  4095  12   55:4   274 	    ELSE
  4096  12   55:5   279 	      IF COMPTYPES(LATTR.TYPTR,GATTR.TYPTR) THEN
  4097  12   55:6   288 		BEGIN LOAD;
  4098  12   55:7   290 		  IF LATTR.TYPTR <> NIL THEN
  4099  12   55:8   295 		    IF (LATTR.TYPTR^.FORM = SUBRANGE) AND RANGECHECK THEN
  4100  12   55:9   304 		      BEGIN
  4101  12   55:0   304 			GENLDC(LATTR.TYPTR^.MIN.IVAL);
  4102  12   55:0   308 			GENLDC(LATTR.TYPTR^.MAX.IVAL);
  4103  12   55:0   312 			GEN0(8(*CHK*))
  4104  12   55:9   313 		      END;
  4105  12   55:7   315 		  GEN2(56(*STR*),0,LC); PUTLABEL(LADDR);
  4106  12   55:7   323 		  GATTR := LATTR; LOAD; GEN2(54(*LOD*),0,LC);
  4107  12   55:7   336 		  LC := LC + INTSIZE;
  4108  12   55:7   341 		  IF LC > LCMAX THEN LCMAX := LC;
  4109  12   55:7   350 		  IF LSY = TOSY THEN GEN2(52(*LEQ*),0,INTSIZE)
  4110  12   55:7   358 		  ELSE GEN2(48(*GEQ*),0,INTSIZE);
  4111  12   55:6   367 		END
  4112  12   55:5   367 	      ELSE ERROR(145)
  4113  12   55:2   372 	END
  4114  12   55:1   375       ELSE BEGIN ERROR(55); SKIP(FSYS + [DOSY]) END;
  4115  12   55:1   395       GENLABEL(LCIX); GENJMP(33(*FJP*),LCIX);
  4116  12   55:1   403       IF SY = DOSY THEN INSYMBOL ELSE ERROR(54);
  4117  12   55:1   418       STATEMENT(FSYS);
  4118  12   55:1   428       GATTR := LATTR; LOAD; GENLDC(1);
  4119  12   55:1   439       IF LSY = TOSY THEN GEN0(2(*ADI*)) ELSE GEN0(21(*SBI*));
  4120  12   55:1   452       STORE(LATTR); GENJMP(57(*UJP*),LADDR); PUTLABEL(LCIX);
  4121  12   55:1   463       LC := LC - INTSIZE
  4122  12   55:0   464     END (*FORSTATEMENT*) ;
  4123  12   55:0   482 
  4124  12   55:0   482 
  4125  12   56:D     1     PROCEDURE WITHSTATEMENT;
  4126  12   56:D     1       VAR LCP: CTP; LCNT1,LCNT2: DISPRANGE;
  4127  12   56:0     0     BEGIN LCNT1 := 0; LCNT2 := 0;
  4128  12   56:1     6       REPEAT
  4129  12   56:2     6 	IF SY = IDENT THEN
  4130  12   56:3    12 	  BEGIN SEARCHID(VARS + [FIELD],LCP); INSYMBOL END
  4131  12   56:2    28 	ELSE BEGIN ERROR(2); LCP := UVARPTR END;
  4132  12   56:2    38 	SELECTOR(FSYS + [COMMA,DOSY],LCP);
  4133  12   56:2    52 	IF GATTR.TYPTR <> NIL THEN
  4134  12   56:3    57 	  IF GATTR.TYPTR^.FORM = RECORDS THEN
  4135  12   56:4    63 	    IF TOP < DISPLIMIT THEN
  4136  12   56:5    68 	      BEGIN TOP := TOP + 1; LCNT1 := LCNT1 + 1;
  4137  12   56:6    78 		WITH DISPLAY[TOP] DO
  4138  12   56:7    85 		  BEGIN FNAME := GATTR.TYPTR^.FSTFLD END;
  4139  12   56:6    89 		IF GATTR.ACCESS = DRCT THEN
  4140  12   56:7    94 		  WITH DISPLAY[TOP] DO
  4141  12   56:8   101 		    BEGIN OCCUR := CREC; CLEV := GATTR.VLEVEL;
  4142  12   56:9   111 		      CDSPL := GATTR.DPLMT
  4143  12   56:8   114 		    END
  4144  12   56:6   116 		ELSE
  4145  12   56:7   118 		  BEGIN LOADADDRESS; GEN2(56(*STR*),0,LC);
  4146  12   56:8   125 		    WITH DISPLAY[TOP] DO
  4147  12   56:9   132 		      BEGIN OCCUR := VREC; VDSPL := LC END;
  4148  12   56:8   142 		    LC := LC + PTRSIZE; LCNT2 := LCNT2 + PTRSIZE;
  4149  12   56:8   152 		    IF LC > LCMAX THEN LCMAX := LC
  4150  12   56:7   158 		  END
  4151  12   56:5   161 	      END
  4152  12   56:4   161 	    ELSE ERROR(250)
  4153  12   56:3   166 	  ELSE ERROR(140);
  4154  12   56:2   177 	TEST := SY <> COMMA;
  4155  12   56:2   183 	IF NOT TEST THEN INSYMBOL
  4156  12   56:1   187       UNTIL TEST;
  4157  12   56:1   193       IF SY = DOSY THEN INSYMBOL ELSE ERROR(54);
  4158  12   56:1   208       STATEMENT(FSYS);
  4159  12   56:1   218       TOP := TOP - LCNT1; LC := LC - LCNT2;
  4160  12   56:0   228     END (*WITHSTATEMENT*) ;
  4161  12   56:0   242 
  4162  12   47:0     0   BEGIN (*STATEMENT*)
  4163  12   47:1     0     STMTLEV := STMTLEV + 1;
  4164  12   47:1     6     IF SY = INTCONST THEN (*LABEL*)
  4165  12   47:2    12       BEGIN TTOP := TOP;
  4166  12   47:3    15 	WHILE DISPLAY[TTOP].OCCUR <> BLCK DO TTOP := TTOP-1;
  4167  12   47:3    32 	LLP := DISPLAY[TTOP].FLABEL;
  4168  12   47:3    40 	WHILE LLP <> NIL DO
  4169  12   47:4    45 	  WITH LLP^ DO
  4170  12   47:5    48 	    IF LABVAL = VAL.IVAL THEN
  4171  12   47:6    55 	      BEGIN
  4172  12   47:7    55 		IF CODELBP^.DEFINED THEN ERROR(165);
  4173  12   47:7    66 		PUTLABEL(CODELBP); GOTO 1
  4174  12   47:6    72 	      END
  4175  12   47:5    72 	    ELSE LLP := NEXTLAB;
  4176  12   47:3    80 	ERROR(167);
  4177  12   47:3    86   1:    INSYMBOL;
  4178  12   47:3    89 	IF SY = COLON THEN INSYMBOL ELSE ERROR(5)
  4179  12   47:2   101       END;
  4180  12   47:1   104     IF DEBUGGING THEN
  4181  12   47:2   108       BEGIN GEN1(85(*BPT*),SCREENDOTS+1); BPTONLINE := TRUE END;
  4182  12   47:1   118     IF NOT (SY IN FSYS + [IDENT]) THEN
  4183  12   47:2   132       BEGIN ERROR(6); SKIP(FSYS) END;
  4184  12   47:1   146     IF SY IN STATBEGSYS + [IDENT] THEN
  4185  12   47:2   159       BEGIN MARK(HEAP); (*FOR LABEL CLEANUP*)
  4186  12   47:3   163 	CASE SY OF
  4187  12   47:3   167 	  IDENT:    BEGIN SEARCHID(VARS + [FIELD,FUNC,PROC],LCP);
  4188  12   47:5   180 		      INSYMBOL;
  4189  12   47:5   183 		      IF LCP^.KLASS = PROC THEN CALL(FSYS,LCP)
  4190  12   47:5   198 		      ELSE ASSIGNMENT(LCP)
  4191  12   47:4   203 		    END;
  4192  12   47:3   207 	  BEGINSY:  BEGIN INSYMBOL; COMPOUNDSTATEMENT END;
  4193  12   47:3   214 	  GOTOSY:   BEGIN INSYMBOL; GOTOSTATEMENT END;
  4194  12   47:3   221 	  IFSY:     BEGIN INSYMBOL; IFSTATEMENT END;
  4195  12   47:3   228 	  CASESY:   BEGIN INSYMBOL; CASESTATEMENT END;
  4196  12   47:3   235 	  WHILESY:  BEGIN INSYMBOL; WHILESTATEMENT END;
  4197  12   47:3   242 	  REPEATSY: BEGIN INSYMBOL; REPEATSTATEMENT END;
  4198  12   47:3   249 	  FORSY:    BEGIN INSYMBOL; FORSTATEMENT END;
  4199  12   47:3   256 	  WITHSY:   BEGIN INSYMBOL; WITHSTATEMENT END
  4200  12   47:3   261 	END;
  4201  12   47:3   324 	RELEASE(HEAP);
  4202  12   47:3   328 	IF IC + 100 > MAXCODE THEN
  4203  12   47:4   337 	  BEGIN ERROR(253); IC := 0 END;
  4204  12   47:3   346 	IF NOT (SY IN [SEMICOLON,ENDSY,ELSESY,UNTILSY]) THEN
  4205  12   47:4   356 	  BEGIN ERROR(6); SKIP(FSYS) END
  4206  12   47:2   370       END;
  4207  12   47:1   370     STMTLEV := STMTLEV - 1
  4208  12   47:0   372   END (*STATEMENT*) ;
  4209  12   47:0   394 
  4210  12   57:D     1 PROCEDURE BODY;
  4211  12   57:D     1 VAR LLC1,EXITIC: ADDRRANGE;  LCP: CTP;  LOP: OPRANGE;
  4212  12   57:D     5      LLP: LABELP;  LMIN,LMAX: INTEGER;  JTINX: JTABRANGE;
  4213  12   57:D     9      DUMMYVAR: ARRAY[0..0] OF INTEGER; (*FOR PRETTY DISPLAY OF STACK AND HEAP*)
  4214  12   57:D    10 
  4215  12   57:0     0 BEGIN
  4216  12   57:1     0   IF (NOSWAP) AND (STARTINGUP) THEN 
  4217  12   57:2     7     BEGIN
  4218  12   57:3     7       DECLARATIONPART(FSYS); (* BRING IN DECLARATIONPART *)
  4219  12   57:3    18       EXIT(BODYPART);
  4220  12   57:2    22     END;
  4221  12   57:1    22   NEXTJTAB := 1;
  4222  12   57:1    26   IF NOISY THEN
  4223  12   57:2    30     BEGIN WRITELN(OUTPUT);
  4224  12   57:3    36       IF NOT NOSWAP THEN (*MUST ADJUST DISPLAY OF STACK AND HEAP*)
  4225  12   57:4    41 	UNITWRITE(3,DUMMYVAR[-1600],35); 
  4226  12   57:3    56       DUMMYVAR[0]:=MEMAVAIL;
  4227  12   57:3    64       IF DUMMYVAR[0] < SMALLESTSPACE THEN SMALLESTSPACE:=DUMMYVAR[0];
  4228  12   57:3    83       IF FPROCP <> NIL THEN
  4229  12   57:4    90 	  WRITELN(OUTPUT,FPROCP^.NAME,' [',DUMMYVAR[0]:5,' words]');
  4230  12   57:3   149       WRITE(OUTPUT,'<',SCREENDOTS:4,'>')
  4231  12   57:2   174     END;
  4232  12   57:1   174   IF FPROCP <> NIL THEN
  4233  12   57:2   181     BEGIN
  4234  12   57:3   181       LLC1 := FPROCP^.LOCALLC; LCP := FPROCP^.NEXT;
  4235  12   57:3   194       WHILE LCP <> NIL DO
  4236  12   57:4   199 	WITH LCP^ DO
  4237  12   57:5   202 	  BEGIN
  4238  12   57:6   202 	      IF IDTYPE <> NIL THEN
  4239  12   57:7   208 		IF (KLASS = ACTUALVARS) THEN
  4240  12   57:8   215 		  IF (IDTYPE^.FORM > POWER) THEN
  4241  12   57:9   222 		    BEGIN LLC1 := LLC1 - PTRSIZE;
  4242  12   57:0   227 		      GEN2(50(*LDA*),0,VADDR);
  4243  12   57:0   234 		      GEN2(54(*LOD*),0,LLC1);
  4244  12   57:0   239 		      IF PAOFCHAR(IDTYPE) THEN
  4245  12   57:1   248 			WITH IDTYPE^ DO
  4246  12   57:2   252 			  IF AISSTRNG THEN GEN1(42(*SAS*),MAXLENG)
  4247  12   57:2   260 			  ELSE
  4248  12   57:3   264 			    IF INXTYPE <> NIL THEN
  4249  12   57:4   270 			      BEGIN GETBOUNDS(INXTYPE,LMIN,LMAX);
  4250  12   57:5   279 				GEN1(40(*MOV*),(LMAX-LMIN+1+1) DIV 2)
  4251  12   57:4   289 			      END
  4252  12   57:3   291 			    ELSE
  4253  12   57:0   293 		      ELSE GEN1(40(*MOV*),IDTYPE^.SIZE)
  4254  12   57:9   299 		    END
  4255  12   57:8   301 		  ELSE LLC1 := LLC1 - IDTYPE^.SIZE
  4256  12   57:7   306 		ELSE
  4257  12   57:8   312 		  IF KLASS = FORMALVARS THEN LLC1 := LLC1 - PTRSIZE;
  4258  12   57:6   324 	    LCP := NEXT
  4259  12   57:5   324 	  END;
  4260  12   57:2   330     END;
  4261  12   57:1   330   STARTDOTS := SCREENDOTS;
  4262  12   57:1   334   LCMAX := LC;
  4263  12   57:1   337   LLP := DISPLAY[TOP].FLABEL;
  4264  12   57:1   345   WHILE LLP <> NIL DO
  4265  12   57:2   350     BEGIN GENLABEL(LLP^.CODELBP);
  4266  12   57:3   355       LLP := LLP^.NEXTLAB
  4267  12   57:2   356     END;
  4268  12   57:1   361   IF NOT INMODULE THEN
  4269  12   57:2   366     IF LEVEL = 1 THEN
  4270  12   57:3   372       BEGIN LCP := USINGLIST;
  4271  12   57:4   376 	WHILE LCP <> NIL DO
  4272  12   57:5   381 	  BEGIN
  4273  12   57:6   381 	    IF LCP^.SEGID >= 0 THEN
  4274  12   57:7   388 	      BEGIN GENLDC(LCP^.SEGID); GEN1(30(*CSP*),21(*GETSEG*)) END;
  4275  12   57:6   397 	    LCP := LCP^.NEXT
  4276  12   57:5   398 	  END;
  4277  12   57:4   403 	IF USERINFO.STUPID THEN
  4278  12   57:5   408 	    GEN2(77(*CXP*),6(*TURTLE*),1(*INIT*))
  4279  12   57:3   411       END;
  4280  12   57:1   413   LCP := DISPLAY[TOP].FFILE;
  4281  12   57:1   421   WHILE LCP <> NIL DO
  4282  12   57:2   426     WITH LCP^,IDTYPE^ DO
  4283  12   57:3   433       BEGIN
  4284  12   57:4   433 	GEN2(50(*LDA*),0,VADDR);
  4285  12   57:4   440 	GEN2(50(*LDA*),0,VADDR+FILESIZE);
  4286  12   57:4   451 	IF FILTYPE = NIL THEN GENLDC(-1)
  4287  12   57:4   459 	ELSE
  4288  12   57:5   463 	  IF IDTYPE = INTRACTVPTR THEN GENLDC(0)
  4289  12   57:5   471 	  ELSE
  4290  12   57:6   475 	    IF FILTYPE = CHARPTR THEN GENLDC(-2)
  4291  12   57:6   484 	    ELSE GENLDC(FILTYPE^.SIZE);
  4292  12   57:4   493 	GEN2(77(*CXP*),0(*SYS*),3(*FINIT*));
  4293  12   57:4   498 	LCP := NEXT
  4294  12   57:3   498       END;
  4295  12   57:1   504   IF (LEVEL = 1) AND NOT SYSCOMP THEN
  4296  12   57:2   514     GEN1(85(*BPT*),SCREENDOTS+1);
  4297  12   57:1   521   REPEAT
  4298  12   57:2   521     REPEAT STATEMENT(FSYS + [SEMICOLON,ENDSY])
  4299  12   57:2   534     UNTIL NOT (SY IN STATBEGSYS);
  4300  12   57:2   547     TEST := SY <> SEMICOLON;
  4301  12   57:2   553     IF NOT TEST THEN INSYMBOL
  4302  12   57:1   557   UNTIL TEST;
  4303  12   57:1   563   IF SY = ENDSY THEN INSYMBOL ELSE ERROR(13);
  4304  12   57:1   578   EXITIC := IC;
  4305  12   57:1   581   LCP := DISPLAY[TOP].FFILE;
  4306  12   57:1   589   WHILE LCP <> NIL DO
  4307  12   57:2   594     WITH LCP^ DO
  4308  12   57:3   597       BEGIN
  4309  12   57:4   597 	GEN2(50(*LDA*),0,VADDR);
  4310  12   57:4   604 	GENLDC(0); GEN2(77(*CXP*),0(*SYS*),6(*FCLOSE*));
  4311  12   57:4   612 	LCP := NEXT
  4312  12   57:3   612       END;
  4313  12   57:1   618   IF NOT INMODULE THEN
  4314  12   57:2   623     IF LEVEL = 1 THEN
  4315  12   57:3   629       BEGIN
  4316  12   57:4   629 	LCP := USINGLIST;
  4317  12   57:4   633 	WHILE LCP <> NIL DO
  4318  12   57:5   638 	  BEGIN
  4319  12   57:6   638 	    IF LCP^.SEGID >= 0 THEN
  4320  12   57:7   645 	      BEGIN GENLDC(LCP^.SEGID); GEN1(30(*CSP*),22(*RELSEG*)) END;
  4321  12   57:6   654 	    LCP := LCP^.NEXT
  4322  12   57:5   655 	  END
  4323  12   57:3   658       END;
  4324  12   57:1   660   IF FPROCP = NIL THEN GEN0(86(*XIT*))
  4325  12   57:1   668   ELSE
  4326  12   57:2   672     BEGIN
  4327  12   57:3   672       IF FPROCP^.PFLEV = 0 THEN LOP := 65(*RBP*)
  4328  12   57:3   681       ELSE LOP := 45(*RNP*);
  4329  12   57:3   689       IF FPROCP^.IDTYPE = NIL THEN GEN1(LOP,0)
  4330  12   57:3   699       ELSE GEN1(LOP,FPROCP^.IDTYPE^.SIZE)
  4331  12   57:2   709     END;
  4332  12   57:1   711   LLP := DISPLAY[TOP].FLABEL;  (* CHECK UNDEFINED LABELS *)
  4333  12   57:1   719   WHILE LLP <> NIL DO
  4334  12   57:2   724     WITH LLP^,CODELBP^ DO
  4335  12   57:3   731       BEGIN
  4336  12   57:4   731 	IF NOT DEFINED THEN
  4337  12   57:5   736 	  IF REFLIST <> MAXADDR THEN ERROR(168);
  4338  12   57:4   750 	LLP := NEXTLAB
  4339  12   57:3   750       END;
  4340  12   57:1   756   JTINX := NEXTJTAB - 1;
  4341  12   57:1   763   IF ODD(IC) THEN IC := IC + 1;
  4342  12   57:1   771   WHILE JTINX > 0 DO
  4343  12   57:2   776     BEGIN GENWORD(IC-JTAB[JTINX]); JTINX := JTINX-1 END;
  4344  12   57:1   795   IF FPROCP = NIL THEN
  4345  12   57:2   802     BEGIN GENWORD((LCMAX-LCAFTERMARKSTACK)*2); GENWORD(0) END
  4346  12   57:1   815   ELSE
  4347  12   57:2   817     WITH FPROCP^ DO
  4348  12   57:3   822       BEGIN GENWORD((LCMAX-LOCALLC)*2);
  4349  12   57:4   833 	GENWORD((LOCALLC-LCAFTERMARKSTACK)*2)
  4350  12   57:3   840       END;
  4351  12   57:1   843   GENWORD(IC-EXITIC); GENWORD(IC);
  4352  12   57:1   853   GENBYTE(CURPROC); GENBYTE(LEVEL-1);
  4353  12   57:1   865   IF NOT CODEINSEG THEN
  4354  12   57:2   870     BEGIN CODEINSEG := TRUE;
  4355  12   57:3   873       SEGTABLE[SEG].DISKADDR := CURBLK
  4356  12   57:2   881     END;
  4357  12   57:1   885   WRITECODE(FALSE);
  4358  12   57:1   889   SEGINX := SEGINX + IC;
  4359  12   57:1   895   PROCTABLE[CURPROC] := SEGINX - 2
  4360  12   57:0   904 END (*BODY*) ;
  4361  12   57:0   946 
  4362  12    1:0     0 BEGIN (*BODYPART*)
  4363  12    1:1     0   BODY
  4364  12    1:0     0 END ;
  4365  12    1:0    14 
  4366  12    1:0    14 (* --- UNITPART.TEXT --- *)    
  4367  12    1:0    14 
  4368  12    1:0    14     (******************************************************************)
  4369  12    1:0    14     (*                                                                *)
  4370  12    1:0    14     (*  Copyright (c) l979 Regents of the University of California.   *)
  4371  12    1:0    14     (*  Permission to copy or distribute this software or documen-    *)
  4372  12    1:0    14     (*  tation in hard or soft copy granted only by written license   *) 
  4373  12    1:0    14     (*  obtained from the Institute for Information Systems.          *)
  4374  12    1:0    14     (*                                                                *)
  4375  12    1:0    14     (******************************************************************)
  4376  12    1:0    14 
  4377  13    1:D     1 SEGMENT PROCEDURE WRITELINKERINFO(DECSTUFF:BOOLEAN);
  4378  13    1:D     2   TYPE
  4379  13    1:D     2     LITYPES = (EOFMARK,MODDULE,GLOBREF,PUBBLIC,PRIVVATE,CONNSTANT,GLOBDEF,
  4380  13    1:D     2 	       PUBLICDEF,CONSTDEF,EXTPROC,EXTFUNC,SSEPPROC,SSEPFUNC,
  4381  13    1:D     2 	       SEPPREF,SEPFREF);
  4382  13    1:D     2     OPFORMAT = (WORD, BYTE, BIG);
  4383  13    1:D     2     LIENTRY = RECORD
  4384  13    1:D     2 		LINAME: ALPHA;
  4385  13    1:D     2 		CASE LITYPE: LITYPES OF
  4386  13    1:D     2 		  MODDULE,
  4387  13    1:D     2 		  PUBBLIC,
  4388  13    1:D     2 		  PRIVVATE,
  4389  13    1:D     2 		  SEPPREF,
  4390  13    1:D     2 		  SEPFREF:          (FORMAT: OPFORMAT;
  4391  13    1:D     2 				     NREFS: INTEGER;
  4392  13    1:D     2 				     NWORDS: INTEGER);
  4393  13    1:D     2 		  CONSTDEF:         (CONSTANT: INTEGER);
  4394  13    1:D     2 		  PUBLICDEF:        (BASEOFFSET: INTEGER);
  4395  13    1:D     2 		  EXTPROC,EXTFUNC,
  4396  13    1:D     2 		  SSEPPROC,SSEPFUNC:(PROCNUM: INTEGER;
  4397  13    1:D     2 				     NPARAMS: INTEGER;
  4398  13    1:D     2 				     RANGE: ^INTEGER)
  4399  13    1:D     2 	      END;
  4400  13    1:D     2 
  4401  13    1:D     2   VAR FCP,LCP: CTP; CURRENTBLOCK: INTEGER; I: NONRESIDENT;
  4402  13    1:D     6       EXTNAME: ALPHA; FIC: ADDRRANGE;
  4403  13    1:D    11       LIREC: LIENTRY;
  4404  13    1:D    19 
  4405  13    2:D     1   PROCEDURE GETREFS(ID,LENGTH: INTEGER);
  4406  13    2:D     3     VAR LIC: ADDRRANGE; J,MAX,BLOCKCOUNT,COUNT: INTEGER;
  4407  13    2:D     8 
  4408  13    3:D     1     PROCEDURE GETNEXTBLOCK;
  4409  13    3:0     0     BEGIN
  4410  13    3:1     0       CURRENTBLOCK := CURRENTBLOCK + 1;
  4411  13    3:1     8       IF CURRENTBLOCK > REFBLK THEN CURRENTBLOCK := 0;
  4412  13    3:1    21       IF BLOCKREAD(REFFILE,REFLIST^,1,CURRENTBLOCK) <> 1 THEN;
  4413  13    3:0    42     END (*GETNEXTBLOCK*) ;
  4414  13    3:0    54 
  4415  13    2:0     0   BEGIN (*GETREFS*)
  4416  13    2:1     0     IF (NREFS = 1) AND (REFBLK = 0) THEN EXIT(GETREFS);
  4417  13    2:1    17     COUNT := 0; 
  4418  13    2:1    20     FOR BLOCKCOUNT := 0 TO REFBLK DO
  4419  13    2:2    33       BEGIN
  4420  13    2:3    33 	IF CURRENTBLOCK < REFBLK THEN MAX := REFSPERBLK ELSE MAX := NREFS-1;
  4421  13    2:3    56 	FOR J := 1 TO MAX DO
  4422  13    2:4    67 	  IF ID = REFLIST^[J].KEY THEN
  4423  13    2:5    80 	    BEGIN GENWORD(REFLIST^[J].OFFSET); COUNT := COUNT + 1 END;
  4424  13    2:3   104 	IF BLOCKCOUNT < REFBLK THEN GETNEXTBLOCK;
  4425  13    2:2   113       END;
  4426  13    2:1   120     LIC := IC; IC := FIC; GENWORD(COUNT); IC := LIC;
  4427  13    2:1   135     (*NOW FILL REST OF 8-WORD RECORD*)
  4428  13    2:1   135     FOR J := 1 TO ((8 - (COUNT MOD 8)) MOD 8) DO GENWORD(0)
  4429  13    2:0   153   END (* GETREFS *) ;
  4430  13    2:0   182 
  4431  13    4:D     1   PROCEDURE GLOBALSEARCH(FCP: CTP);
  4432  13    4:D     2     VAR NEEDEDBYLINKER: BOOLEAN;
  4433  13    4:D     3     
  4434  13    4:0     0   BEGIN
  4435  13    4:1     0     NEEDEDBYLINKER := TRUE;
  4436  13    4:1     3     WITH LIREC,FCP^ DO
  4437  13    4:2     6       CASE KLASS OF
  4438  13    4:2    11 	TYPES: NEEDEDBYLINKER := FALSE;
  4439  13    4:2    16 	KONST: IF (IDTYPE^.SIZE = 1) AND NOT INMODULE THEN
  4440  13    4:4    27 		 BEGIN LITYPE := CONSTDEF;
  4441  13    4:5    31 		   CONSTANT := VALUES.IVAL
  4442  13    4:4    32 		 END
  4443  13    4:3    37 	       ELSE NEEDEDBYLINKER := FALSE;
  4444  13    4:2    44 	FORMALVARS,
  4445  13    4:2    44 	ACTUALVARS:
  4446  13    4:3    44 	       BEGIN
  4447  13    4:4    44 		 IF INMODULE THEN
  4448  13    4:5    48 		   BEGIN
  4449  13    4:6    48 		     IF PUBLIC THEN
  4450  13    4:7    53 		       BEGIN LITYPE := PUBBLIC;
  4451  13    4:8    57 			 NWORDS := 0
  4452  13    4:7    57 		       END
  4453  13    4:6    61 		     ELSE
  4454  13    4:7    63 		       BEGIN LITYPE := PRIVVATE;
  4455  13    4:8    67 			 IF KLASS = FORMALVARS THEN
  4456  13    4:9    74 			   NWORDS := PTRSIZE
  4457  13    4:8    74 			 ELSE
  4458  13    4:9    80 			   NWORDS := IDTYPE^.SIZE
  4459  13    4:7    82 		       END;
  4460  13    4:6    86 		     FORMAT := BIG
  4461  13    4:5    86 		   END
  4462  13    4:4    90 		 ELSE
  4463  13    4:5    92 		   BEGIN LITYPE := PUBLICDEF;
  4464  13    4:6    96 		     BASEOFFSET := VADDR
  4465  13    4:5    96 		   END
  4466  13    4:3   102 	       END;
  4467  13    4:2   104 	FIELD: NEEDEDBYLINKER := FALSE;
  4468  13    4:2   109 	PROC,
  4469  13    4:2   109 	FUNC:  BEGIN
  4470  13    4:4   109 		 IF PFDECKIND = DECLARED THEN
  4471  13    4:5   116 		   IF PFKIND = ACTUAL THEN
  4472  13    4:6   123 		     IF KLASS = PROC THEN
  4473  13    4:7   130 		       IF EXTURNAL THEN
  4474  13    4:8   135 			 IF SEPPROC THEN LITYPE := SEPPREF
  4475  13    4:8   139 			 ELSE LITYPE := EXTPROC
  4476  13    4:7   145 		       ELSE
  4477  13    4:8   151 			 IF SEPPROC THEN
  4478  13    4:9   155 			   LITYPE := SSEPPROC
  4479  13    4:8   155 			 ELSE NEEDEDBYLINKER := FALSE
  4480  13    4:6   161 		     ELSE (*KLASS = FUNC*)
  4481  13    4:7   166 		       IF EXTURNAL THEN
  4482  13    4:8   171 			 IF SEPPROC THEN LITYPE := SEPFREF
  4483  13    4:8   175 			 ELSE LITYPE := EXTFUNC
  4484  13    4:7   181 		       ELSE
  4485  13    4:8   187 			 IF SEPPROC THEN
  4486  13    4:9   191 			   LITYPE := SSEPFUNC
  4487  13    4:8   191 			 ELSE NEEDEDBYLINKER := FALSE
  4488  13    4:5   197 		   ELSE NEEDEDBYLINKER := FALSE
  4489  13    4:4   202 		 ELSE NEEDEDBYLINKER := FALSE;
  4490  13    4:4   210 		 IF NEEDEDBYLINKER THEN
  4491  13    4:5   213 		   BEGIN
  4492  13    4:6   213 		     LCP := NEXT; NPARAMS := 0;
  4493  13    4:6   222 		     WHILE LCP <> NIL DO
  4494  13    4:7   229 		       BEGIN
  4495  13    4:8   229 			 WITH LCP^ DO
  4496  13    4:9   234 			   IF KLASS = FORMALVARS THEN
  4497  13    4:0   241 			     NPARAMS := NPARAMS + PTRSIZE
  4498  13    4:9   244 			   ELSE
  4499  13    4:0   251 			     IF KLASS = ACTUALVARS THEN
  4500  13    4:1   258 			       IF IDTYPE^.FORM <= POWER THEN
  4501  13    4:2   265 				 NPARAMS := NPARAMS + IDTYPE^.SIZE
  4502  13    4:1   270 			       ELSE NPARAMS := NPARAMS + PTRSIZE;
  4503  13    4:8   285 			 LCP := LCP^.NEXT
  4504  13    4:7   288 		       END;
  4505  13    4:6   294 		     IF LITYPE IN [SEPPREF,SEPFREF] THEN
  4506  13    4:7   304 		       BEGIN FORMAT := BYTE; NWORDS := NPARAMS END
  4507  13    4:6   314 		     ELSE
  4508  13    4:7   316 		       BEGIN PROCNUM := PFNAME; RANGE := NIL END
  4509  13    4:5   326 		   END
  4510  13    4:3   326 		 END (*PROC,FUNC*);
  4511  13    4:2   328         MODULE:  BEGIN
  4512  13    4:4   328 		   IF NOT INMODULE THEN NEEDEDBYLINKER := FALSE
  4513  13    4:4   333 		   ELSE
  4514  13    4:5   338 		     BEGIN LITYPE := MODDULE; NWORDS := 0; FORMAT := BYTE END
  4515  13    4:3   350 		 END
  4516  13    4:2   350       END (*CASE,WITH*);
  4517  13    4:1   376     IF NEEDEDBYLINKER THEN
  4518  13    4:2   379       IF SEGTABLE[SEG].SEGKIND = 2 (*SEGPROC*) THEN
  4519  13    4:3   390 	WITH LIREC DO
  4520  13    4:4   390 	  IF (LITYPE = CONSTDEF) OR (LITYPE = PUBLICDEF) THEN
  4521  13    4:5   403 	    NEEDEDBYLINKER := FALSE;
  4522  13    4:1   406     IF NEEDEDBYLINKER THEN
  4523  13    4:2   409       WITH LIREC DO
  4524  13    4:3   409 	BEGIN LINAME := FCP^.NAME;
  4525  13    4:4   415 	  FOR LGTH := 1 TO 8 DO GENBYTE(ORD(LINAME[LGTH]));
  4526  13    4:4   446 	  GENWORD(ORD(LITYPE));
  4527  13    4:4   452 	  CASE LITYPE OF
  4528  13    4:4   457 	    MODDULE,
  4529  13    4:4   457 	    PUBBLIC,
  4530  13    4:4   457 	    PRIVVATE,
  4531  13    4:4   457 	    SEPPREF,SEPFREF: BEGIN
  4532  13    4:6   457 			       GENWORD(ORD(FORMAT));
  4533  13    4:6   463 			       FIC := IC; GENWORD(0);
  4534  13    4:6   471 			       GENWORD(NWORDS);
  4535  13    4:6   477 			       IF LITYPE = MODDULE THEN GETREFS(FCP^.SEGID,1)
  4536  13    4:6   488 			       ELSE
  4537  13    4:7   492 				IF LITYPE IN [SEPPREF,SEPFREF] THEN
  4538  13    4:8   502 				  GETREFS(-FCP^.PFNAME,1)
  4539  13    4:7   507 				ELSE GETREFS(FCP^.VADDR + 32,FCP^.IDTYPE^.SIZE);
  4540  13    4:5   521 			     END;
  4541  13    4:4   523 	    CONSTDEF: BEGIN  GENWORD(CONSTANT); GENWORD(0); GENWORD(0) END;
  4542  13    4:4   539 	    PUBLICDEF: BEGIN GENWORD(BASEOFFSET); GENWORD(0); GENWORD(0) END;
  4543  13    4:4   555 	    EXTPROC,EXTFUNC:     BEGIN
  4544  13    4:6   555 				   GENWORD(PROCNUM);
  4545  13    4:6   561 				   GENWORD(NPARAMS);
  4546  13    4:6   567 				   GENWORD(ORD(RANGE))
  4547  13    4:5   570 				 END;
  4548  13    4:4   575 	    SSEPPROC,SSEPFUNC:   BEGIN
  4549  13    4:6   575 				   GENWORD(PROCNUM);
  4550  13    4:6   581 				   GENWORD(NPARAMS);
  4551  13    4:6   587 				   GENWORD(ORD(RANGE));
  4552  13    4:6   593 				   FOR LGTH := 1 TO 8 DO
  4553  13    4:7   605 				     GENBYTE(ORD(LINAME[LGTH]));
  4554  13    4:6   624 				   IF LITYPE = SSEPPROC THEN 
  4555  13    4:7   631 				     GENWORD(ORD(SEPPREF))
  4556  13    4:6   632 				   ELSE GENWORD(ORD(SEPFREF));
  4557  13    4:6   641 				   GENWORD(ORD(BYTE));
  4558  13    4:6   645 				   FIC := IC; GENWORD(0); GENWORD(NPARAMS);
  4559  13    4:6   659 				   GETREFS(-PROCNUM,1)
  4560  13    4:5   664 				 END
  4561  13    4:4   666 	  END(*CASE*)
  4562  13    4:3   704 	END(*WITH*);
  4563  13    4:1   704     IF IC >= 1024 THEN BEGIN WRITECODE(FALSE); IC := 0 END;
  4564  13    4:1   718 
  4565  13    4:1   718     IF FCP^.LLINK <> NIL THEN GLOBALSEARCH(FCP^.LLINK);
  4566  13    4:1   728     IF FCP^.RLINK <> NIL THEN GLOBALSEARCH(FCP^.RLINK)
  4567  13    4:1   736 
  4568  13    4:0   736   END (*GLOBALSEARCH*);
  4569  13    4:0   766 
  4570  13    1:0     0 BEGIN (*WRITELINKERINFO*)
  4571  13    1:1     0   IC := 0;
  4572  13    1:1     3   IF CODEINSEG THEN ERROR(399);
  4573  13    1:1    13   IF INMODULE THEN
  4574  13    1:2    17       CURRENTBLOCK := REFBLK;
  4575  13    1:1    22   IF DECSTUFF THEN (*SKIP IF NO DECLARATIONPART LINKER INFO*)
  4576  13    1:2    25     BEGIN FCP := DISPLAY[GLEV].FNAME;
  4577  13    1:3    34       IF FCP <> NIL THEN GLOBALSEARCH(FCP)
  4578  13    1:2    40     END;
  4579  13    1:2    42   (*NOW DO NONRESIDENT PROCS*)
  4580  13    1:1    42   WITH LIREC DO
  4581  13    1:2    42     FOR I := SEEK TO DECOPS DO
  4582  13    1:3    54       IF PFNUMOF[I] <> 0 THEN
  4583  13    1:4    65 	BEGIN
  4584  13    1:5    65 	  CASE I OF
  4585  13    1:5    68 	    SEEK:       BEGIN LINAME := 'FSEEK   '; NPARAMS := 2 END;
  4586  13    1:5    88 	    FREADREAL:  BEGIN LINAME := 'FREADREA'; NPARAMS := 2 END;
  4587  13    1:5   108 	    FWRITEREAL: BEGIN LINAME := 'FWRITERE'; NPARAMS := 5 END;
  4588  13    1:5   128 	    FREADDEC:   BEGIN LINAME := 'FREADDEC'; NPARAMS := 3 END;
  4589  13    1:5   148 	    FWRITEDEC:  BEGIN LINAME := 'FWRITEDE';
  4590  13    1:7   163 				    NPARAMS := 2+DECSIZE(MAXDEC) END;
  4591  13    1:5   175 	    DECOPS:     BEGIN LINAME := 'DECOPS  '; NPARAMS := 0 END;
  4592  13    1:5   195 	  END;
  4593  13    1:5   214 	  FOR LGTH := 1 TO 8 DO GENBYTE(ORD(LINAME[LGTH]));
  4594  13    1:5   245 	  IF SEPPROC THEN
  4595  13    1:6   249 	    BEGIN GENWORD(ORD(SEPPREF));
  4596  13    1:7   253 	      GENWORD(ORD(BYTE)); FIC := IC; GENWORD(0); GENWORD(NPARAMS);
  4597  13    1:7   269 	      GETREFS(-PFNUMOF[I],1)
  4598  13    1:6   278 	    END
  4599  13    1:5   280 	  ELSE
  4600  13    1:6   282 	    BEGIN GENWORD(ORD(EXTPROC));
  4601  13    1:7   286 	      GENWORD(PFNUMOF[I]); GENWORD(NPARAMS); GENWORD(0)
  4602  13    1:6   302 	    END;
  4603  13    1:5   305 	  PFNUMOF[I] := 0;
  4604  13    1:4   313 	END;
  4605  13    1:4   320   (* NOW DO EOFMARK END-RECORD*)
  4606  13    1:1   320   FOR LGTH := 1 TO 8 DO GENBYTE(ORD(' '));
  4607  13    1:1   345   GENWORD(ORD(EOFMARK)); GENWORD(LCMAX);
  4608  13    1:1   354   GENWORD(0);GENWORD(0);
  4609  13    1:1   362   WRITECODE(TRUE);
  4610  13    1:1   366   CLINKERINFO := FALSE;
  4611  13    1:1   369   IF DECSTUFF THEN DLINKERINFO := FALSE
  4612  13    1:0   372 END (*WRITELINKERINFO*); 
  4613  13    1:0   398 
  4614  14    1:D     1 SEGMENT PROCEDURE UNITPART(FSYS: SETOFSYS);
  4615  14    1:D     5   VAR UMARKP: TESTP;
  4616  14    1:D     6 
  4617  14    2:D     1   PROCEDURE OPENREFFILE;
  4618  14    2:0     0   BEGIN
  4619  14    2:1     0     REWRITE(REFFILE,'*SYSTEM.INFO[*]');
  4620  14    2:1    26     IF IORESULT <> 0 THEN ERROR(402)
  4621  14    2:0    35   END (* OPENREFFILE *) ;
  4622  14    2:0    50 
  4623  14    3:D     1   PROCEDURE UNITDECLARATION(FSYS: SETOFSYS; VAR UMARKP:TESTP);
  4624  14    3:D     6     VAR LCP: CTP; FOUND: BOOLEAN; LLEXSTK: LEXSTKREC;
  4625  14    3:0     0   BEGIN
  4626  14    3:1     0     IF INMODULE THEN ERROR(182 (* NESTED MODULES NOT ALLOWED *));
  4627  14    3:1    10     IF CODEINSEG THEN
  4628  14    3:2    14       BEGIN ERROR(399); SEGINX := 0; CURBYTE := 0 END;
  4629  14    3:1    27     WITH LLEXSTK DO
  4630  14    3:2    27       BEGIN
  4631  14    3:3    27 	DOLDTOP := TOP;
  4632  14    3:3    30 	DOLDLEV := LEVEL;
  4633  14    3:3    34 	POLDPROC := CURPROC;
  4634  14    3:3    38 	SOLDPROC := NEXTPROC;
  4635  14    3:3    42 	DOLDSEG := SEG;
  4636  14    3:3    45 	DLLC := LC;
  4637  14    3:3    48 	PREVLEXSTACKP := TOS
  4638  14    3:2    48       END;
  4639  14    3:1    52     SEG := NEXTSEG;
  4640  14    3:1    56     NEXTSEG := NEXTSEG + 1;
  4641  14    3:1    62     IF NEXTSEG > MAXSEG THEN ERROR(250);
  4642  14    3:1    74     NEXTPROC := 1;
  4643  14    3:1    77     LC := LCAFTERMARKSTACK;
  4644  14    3:1    80     PUBLICPROCS := FALSE;
  4645  14    3:1    83     INMODULE := TRUE;
  4646  14    3:1    86     INSYMBOL;
  4647  14    3:1    89     IF SY <> IDENT THEN ERROR(2)
  4648  14    3:1    96     ELSE
  4649  14    3:2   101       BEGIN FOUND := FALSE;
  4650  14    3:3   104 	LCP := MODPTR;
  4651  14    3:3   108 	WHILE (LCP <> NIL) AND NOT FOUND DO
  4652  14    3:4   116 	  IF LCP^.NAME <> ID THEN LCP := LCP^.NEXT
  4653  14    3:4   125 	  ELSE BEGIN FOUND := TRUE; ERROR(101) END;
  4654  14    3:3   139 	IF NOT FOUND THEN
  4655  14    3:4   143 	  BEGIN NEW(LCP,MODULE);
  4656  14    3:5   148 	    WITH LCP^ DO
  4657  14    3:6   151 	      BEGIN NAME := ID; IDTYPE := NIL; NEXT := MODPTR;
  4658  14    3:7   170 		KLASS := MODULE; SEGID := SEG
  4659  14    3:6   180 	      END;
  4660  14    3:5   182 	    MODPTR := LCP
  4661  14    3:4   182 	  END;
  4662  14    3:2   185       END;
  4663  14    3:1   185     SEGTABLE[SEG].SEGNAME := ID;
  4664  14    3:1   197     MARK(UMARKP);
  4665  14    3:1   200     NEW(REFLIST);
  4666  14    3:1   208     NEW(TOS);
  4667  14    3:1   213     TOS^ := LLEXSTK;
  4668  14    3:1   219     LEVEL := 1;
  4669  14    3:1   222     IF TOP < DISPLIMIT THEN
  4670  14    3:2   227       BEGIN TOP := TOP +1;
  4671  14    3:3   232 	WITH DISPLAY[TOP] DO
  4672  14    3:4   239 	  BEGIN FNAME := NIL; FFILE := NIL; FLABEL := NIL; OCCUR := BLCK END;
  4673  14    3:3   261 	IF LCP <> NIL THEN ENTERID(LCP)
  4674  14    3:2   267       END
  4675  14    3:1   270     ELSE ERROR(250);
  4676  14    3:1   278     INSYMBOL;
  4677  14    3:1   281     IF SY = SEMICOLON THEN INSYMBOL ELSE ERROR(14)
  4678  14    3:0   293   END (*UNITDECLARATION*) ;
  4679  14    3:0   310 
  4680  14    1:0     0 BEGIN (*UNITPART*)
  4681  14    1:1     0   OPENREFFILE;
  4682  14    1:1     2   REPEAT
  4683  14    1:2     2     RESET(REFFILE); NREFS := 1; REFBLK := 0;
  4684  14    1:2    16     IF (SY = SEPARATSY) THEN
  4685  14    1:3    22       BEGIN SEPPROC := TRUE;
  4686  14    1:4    25 	INSYMBOL; IF SY <> UNITSY THEN ERROR(24)
  4687  14    1:3    35       END
  4688  14    1:2    38     ELSE
  4689  14    1:3    40       SEPPROC := FALSE;
  4690  14    1:2    43     UNITDECLARATION(FSYS,UMARKP);
  4691  14    1:2    54     IF SEPPROC THEN SEGTABLE[SEG].SEGKIND := 4 ELSE SEGTABLE[SEG].SEGKIND := 3;
  4692  14    1:2    80     SEGTABLE[SEG].TEXTADDR := CURBLK;
  4693  14    1:2    92     WRITETEXT;
  4694  14    1:2    95     IF SY = INTERSY THEN INSYMBOL
  4695  14    1:2   101     ELSE ERROR(22);
  4696  14    1:2   110     ININTERFACE := TRUE;
  4697  14    1:2   113     DECLARATIONPART(FSYS);
  4698  14    1:2   123     IF PUBLICPROCS THEN
  4699  14    1:3   127       BEGIN
  4700  14    1:4   127 	ININTERFACE := FALSE;
  4701  14    1:4   130 	IF SY <> IMPLESY THEN BEGIN ERROR(23); SKIP(FSYS - STATBEGSYS) END
  4702  14    1:4   156 	ELSE INSYMBOL;
  4703  14    1:4   161 	BLOCK(FSYS - [SEPARATSY,UNITSY,INTERSY,IMPLESY]);
  4704  14    1:4   183 	IF REFBLK > 0 THEN
  4705  14    1:5   190 	  IF BLOCKWRITE(REFFILE,REFLIST^,1,REFBLK) <> 1 THEN ERROR(402);
  4706  14    1:4   217 	WRITELINKERINFO(TRUE);
  4707  14    1:3   221       END
  4708  14    1:2   221     ELSE
  4709  14    1:3   223       BEGIN DLINKERINFO := FALSE;
  4710  14    1:4   226 	WITH SEGTABLE[SEG] DO
  4711  14    1:5   234 	  BEGIN CODELENG := 0; DISKADDR :=CURBLK; SEGKIND := 0 END;
  4712  14    1:3   249       END;
  4713  14    1:2   249     SEPPROC := FALSE; (*FALSE WHENEVER NOT INMODULE*)
  4714  14    1:2   252     INMODULE := FALSE;
  4715  14    1:2   255     IF SY = ENDSY THEN INSYMBOL
  4716  14    1:2   261     ELSE BEGIN ERROR(13); SKIP(FSYS) END;
  4717  14    1:2   280     IF SY <> PERIOD THEN
  4718  14    1:3   286       IF SY = SEMICOLON THEN INSYMBOL
  4719  14    1:3   292       ELSE ERROR(14);
  4720  14    1:2   301     WITH TOS^ DO
  4721  14    1:3   305 	BEGIN
  4722  14    1:4   305 	  TOP := DOLDTOP;
  4723  14    1:4   309 	  LEVEL := DOLDLEV;
  4724  14    1:4   313 	  CURPROC := POLDPROC;
  4725  14    1:4   317 	  NEXTPROC := SOLDPROC;
  4726  14    1:4   321 	  SEG := DOLDSEG;
  4727  14    1:4   325 	  LC := DLLC;
  4728  14    1:3   329 	END;
  4729  14    1:2   329     TOS := TOS^.PREVLEXSTACKP;
  4730  14    1:2   335     RELEASE(UMARKP)
  4731  14    1:1   337   UNTIL NOT (SY IN [UNITSY,SEPARATSY]);
  4732  14    1:1   357   CLOSE(REFFILE)
  4733  14    1:0   364 END (*UNITPART*);
  4734  14    1:0   378 
  4735  14    1:0   378 (* --- PROCS.A.TEXT --- *)
  4736  14    1:0   378 
  4737  14    1:0   378     (******************************************************************)
  4738  14    1:0   378     (*                                                                *)
  4739  14    1:0   378     (*  Copyright (c) l979 Regents of the University of California.   *)
  4740  14    1:0   378     (*  Permission to copy or distribute this software or documen-    *)
  4741  14    1:0   378     (*  tation in hard or soft copy granted only by written license   *) 
  4742  14    1:0   378     (*  obtained from the Institute for Information Systems.          *)
  4743  14    1:0   378     (*                                                                *)
  4744  14    1:0   378     (******************************************************************)
  4745  14    1:0   378 
  4746   1    2:D     1 PROCEDURE ERROR(*ERRORNUM: INTEGER*);
  4747   1    2:D     2   VAR CH: CHAR; ERRSTART: INTEGER;
  4748   1    2:D     4       A: PACKED ARRAY [0..179] OF CHAR;
  4749   1    2:0     0 BEGIN
  4750   1    2:1     0   WITH USERINFO DO
  4751   1    2:2     0     IF (ERRSYM <> SYMCURSOR) OR (ERRBLK <> SYMBLK) THEN
  4752   1    2:3    14       BEGIN ERRBLK := SYMBLK;
  4753   1    2:4    19 	ERRSYM := SYMCURSOR; ERRNUM := ERRORNUM;
  4754   1    2:4    27 	IF STUPID THEN CH := 'E'
  4755   1    2:4    32 	ELSE
  4756   1    2:5    37 	  BEGIN
  4757   1    2:6    37 	    IF NOISY THEN WRITELN(OUTPUT)
  4758   1    2:6    47 	    ELSE
  4759   1    2:7    49 	      IF LIST AND (ERRORNUM <= 400) THEN
  4760   1    2:8    59 		EXIT(ERROR);
  4761   1    2:6    63 	    IF LINESTART = 0 THEN
  4762   1    2:7    69 	      WRITE(OUTPUT,SYMBUFP^:SYMCURSOR)
  4763   1    2:6    80 	    ELSE
  4764   1    2:7    82 	      BEGIN
  4765   1    2:8    82 		ERRSTART := SCAN(-(LINESTART-1),=CHR(EOL),
  4766   1    2:8    89 				    SYMBUFP^[LINESTART-2])+LINESTART-1;
  4767   1    2:8   104 		MOVELEFT(SYMBUFP^[ERRSTART],A[0],SYMCURSOR-ERRSTART);
  4768   1    2:8   114 		WRITE(OUTPUT,A:SYMCURSOR-ERRSTART)
  4769   1    2:7   128 	      END;
  4770   1    2:6   128 	    WRITELN(OUTPUT,' <<<<');
  4771   1    2:6   149 	    WRITE(OUTPUT,'Line ',SCREENDOTS,', error ',ERRORNUM:0,':');
  4772   1    2:6   207 	    IF NOISY THEN
  4773   1    2:7   211 	      WRITE(OUTPUT,' <sp>(continue), <esc>(terminate), E(dit');
  4774   1    2:6   261 	    WRITE(OUTPUT,CHR(7));
  4775   1    2:6   269 	    REPEAT READ(KEYBOARD,CH)
  4776   1    2:6   277 	    UNTIL (CH = ' ') OR (CH = 'E') OR (CH = 'e') OR (CH = ALTMODE)
  4777   1    2:5   293 	  END;
  4778   1    2:4   296 	IF (CH = 'E') OR (CH = 'e') THEN
  4779   1    2:5   305 	  BEGIN ERRBLK := SYMBLK-2; EXIT(PASCALCOMPILER) END; 
  4780   1    2:4   316 	IF (ERRORNUM > 400) OR (CH = CHR(27)) THEN
  4781   1    2:5   327 	  BEGIN ERRBLK := 0; EXIT(PASCALCOMPILER) END; 
  4782   1    2:4   335 	WRITELN(OUTPUT);
  4783   1    2:4   341 	IF NOISY THEN
  4784   1    2:5   345 	  WRITE(OUTPUT,'<',SCREENDOTS:4,'>')
  4785   1    2:3   370       END
  4786   1    2:0   370 END (*ERROR*) ;
  4787   1    2:0   388 
  4788   1    3:D     1 PROCEDURE GETNEXTPAGE;
  4789   1    3:0     0 BEGIN SYMCURSOR := 0; LINESTART := 0;
  4790   1    3:1     6   IF USING THEN
  4791   1    3:2    10     BEGIN
  4792   1    3:3    10       IF USEFILE = WORKCODE THEN
  4793   1    3:4    17 	BEGIN
  4794   1    3:5    17 	  IF BLOCKREAD(USERINFO.WORKCODE^,SYMBUFP^,2,SYMBLK) <> 2 THEN
  4795   1    3:6    35 	    USING := FALSE
  4796   1    3:4    35 	END
  4797   1    3:3    38       ELSE
  4798   1    3:4    40 	IF USEFILE = SYSLIBRARY THEN
  4799   1    3:5    47 	  IF BLOCKREAD(LIBRARY,SYMBUFP^,2,SYMBLK) <> 2 THEN
  4800   1    3:6    65 	    USING := FALSE;
  4801   1    3:3    68       IF NOT USING THEN
  4802   1    3:4    73 	BEGIN
  4803   1    3:5    73 	  SYMBLK := PREVSYMBLK; SYMCURSOR := PREVSYMCURSOR;
  4804   1    3:5    83 	  LINESTART := PREVLINESTART
  4805   1    3:4    83 	END
  4806   1    3:2    88     END;
  4807   1    3:1    88   IF NOT USING THEN
  4808   1    3:2    93     BEGIN
  4809   1    3:3    93       IF INCLUDING THEN
  4810   1    3:4    97 	IF BLOCKREAD(INCLFILE,SYMBUFP^,2,SYMBLK) <> 2 THEN
  4811   1    3:5   115 	  BEGIN CLOSE(INCLFILE); INCLUDING := FALSE;
  4812   1    3:6   125 	    SYMBLK := OLDSYMBLK; SYMCURSOR := OLDSYMCURSOR;
  4813   1    3:6   135 	    LINESTART := OLDLINESTART
  4814   1    3:5   135 	  END
  4815   1    3:2   140     END;
  4816   1    3:1   140   IF NOT (INCLUDING OR USING) THEN
  4817   1    3:2   148     IF BLOCKREAD(USERINFO.WORKSYM^,SYMBUFP^,2,SYMBLK) <> 2 THEN
  4818   1    3:3   166       ERROR(401);
  4819   1    3:1   171   IF SYMCURSOR = 0 THEN
  4820   1    3:2   176     BEGIN
  4821   1    3:3   176       IF INMODULE THEN
  4822   1    3:4   180 	IF ININTERFACE AND NOT USING THEN WRITETEXT;
  4823   1    3:3   190       IF SYMBUFP^[0] = CHR(16(*DLE*)) THEN
  4824   1    3:4   197        SYMCURSOR := 2
  4825   1    3:2   197     END;
  4826   1    3:1   200   SYMBLK := SYMBLK+2
  4827   1    3:0   202 END (*GETNEXTPAGE*) ;
  4828   1    3:0   218 
  4829   1    3:0   218 (*$I+*)
  4830   1    4:D     1 PROCEDURE PRINTLINE;
  4831   1    4:D     1   VAR DORLEV,STARORC: CHAR; LENG: INTEGER;
  4832   1    4:D     4       A: PACKED ARRAY [0..99] OF CHAR;
  4833   1    4:0     0 BEGIN STARORC := ':';
  4834   1    4:1     3   IF DP THEN DORLEV := 'D'
  4835   1    4:1     7   ELSE DORLEV := CHR((BEGSTMTLEV MOD 10) + ORD('0'));
  4836   1    4:1    20   IF BPTONLINE THEN STARORC := '*';
  4837   1    4:1    27   WRITE(LP,SCREENDOTS:6,SEG:4,CURPROC:5,
  4838   1    4:1    59 	    STARORC,DORLEV,LINEINFO:6,' ');
  4839   1    4:1   100   LENG := SYMCURSOR-LINESTART;
  4840   1    4:1   106   IF LENG > 100 THEN LENG := 100;
  4841   1    4:1   114   MOVELEFT(SYMBUFP^[LINESTART],A,LENG);
  4842   1    4:1   123   IF A[0] = CHR(16(*DLE*)) THEN
  4843   1    4:2   131     BEGIN
  4844   1    4:3   131       IF A[1] > ' ' THEN
  4845   1    4:4   139 	WRITE(LP,' ':ORD(A[1])-ORD(' '));
  4846   1    4:3   154       LENG := LENG-2;
  4847   1    4:3   159       MOVELEFT(A[2],A,LENG)
  4848   1    4:2   168     END;
  4849   1    4:1   168   A[LENG-1] := CHR(EOL); (*JUST TO MAKE SURE*)
  4850   1    4:1   175   WRITE(LP,A:LENG);
  4851   1    4:1   187   WITH USERINFO DO
  4852   1    4:2   187     IF (ERRBLK = SYMBLK) AND (ERRSYM > LINESTART) THEN
  4853   1    4:3   202       WRITELN(LP,'>>>>>> Error # ',ERRNUM)
  4854   1    4:0   249 END (*PRINTLINE*) ;
  4855   1    4:0   262 (*$I-*)
  4856   1    4:0   262 
  4857   1    5:D     1 PROCEDURE ENTERID(*FCP: CTP*);
  4858   1    5:D     2   VAR LCP,LCP1: CTP; I: INTEGER;
  4859   1    5:0     0 BEGIN LCP := DISPLAY[TOP].FNAME;
  4860   1    5:1     8   IF LCP = NIL THEN DISPLAY[TOP].FNAME := FCP
  4861   1    5:1    18   ELSE
  4862   1    5:2    22     BEGIN I := TREESEARCH(LCP,LCP1,FCP^.NAME);
  4863   1    5:3    30       WHILE I = 0 DO
  4864   1    5:4    35 	BEGIN ERROR(101);
  4865   1    5:5    38 	  IF LCP1^.RLINK = NIL THEN I := 1
  4866   1    5:5    44 	  ELSE I := TREESEARCH(LCP1^.RLINK,LCP1,FCP^.NAME)
  4867   1    5:4    56 	END;
  4868   1    5:3    60       IF I = 1 THEN LCP1^.RLINK := FCP ELSE LCP1^.LLINK := FCP
  4869   1    5:2    75     END;
  4870   1    5:1    77   FCP^.LLINK := NIL; FCP^.RLINK := NIL
  4871   1    5:0    85 END (*ENTERID*) ;
  4872   1    5:0   102 
  4873   1    6:D     1 PROCEDURE INSYMBOL; (* COMPILER VERSION 3.4 06-NOV-76 *)
  4874   1    6:D     1   LABEL 1;
  4875   1    6:D     1   VAR LVP: CSP; X: INTEGER;
  4876   1    6:D     3 
  4877   1   21:D     1 PROCEDURE CHECKEND;
  4878   1   21:0     0 BEGIN (* CHECKS FOR THE END OF THE PAGE *)
  4879   1   21:1     0   SCREENDOTS := SCREENDOTS+1;
  4880   1   21:1     6   SYMCURSOR := SYMCURSOR + 1;
  4881   1   21:1    11   IF NOISY THEN
  4882   1   21:2    15     BEGIN WRITE(OUTPUT,'.');
  4883   1   21:3    23       IF (SCREENDOTS-STARTDOTS) MOD 50 = 0 THEN
  4884   1   21:4    34 	BEGIN WRITELN(OUTPUT);
  4885   1   21:5    40 	  WRITE(OUTPUT,'<',SCREENDOTS:4,'>')
  4886   1   21:4    65 	END
  4887   1   21:2    65     END;
  4888   1   21:1    65   IF LIST THEN PRINTLINE;
  4889   1   21:1    71   BPTONLINE := FALSE;
  4890   1   21:1    74   IF SYMBUFP^[SYMCURSOR]=CHR(0) THEN GETNEXTPAGE
  4891   1   21:1    81   ELSE LINESTART := SYMCURSOR;
  4892   1   21:1    88   IF SYMBUFP^[SYMCURSOR] = CHR(12(*FF*)) THEN SYMCURSOR:=SYMCURSOR+1;
  4893   1   21:1   100   IF SYMBUFP^[SYMCURSOR] = CHR(16(*DLE*)) THEN
  4894   1   21:2   107     SYMCURSOR := SYMCURSOR+2
  4895   1   21:1   108   ELSE
  4896   1   21:2   114     BEGIN
  4897   1   21:3   114       SYMCURSOR := SYMCURSOR+SCAN(80,<>CHR(9),SYMBUFP^[SYMCURSOR]);
  4898   1   21:3   126       SYMCURSOR := SYMCURSOR+SCAN(80,<>' ',SYMBUFP^[SYMCURSOR])
  4899   1   21:2   135     END;
  4900   1   21:1   138   IF DP THEN LINEINFO := LC ELSE LINEINFO := IC
  4901   1   21:0   147 END;
  4902   1   21:0   162 
  4903   1   22:D     1 PROCEDURE COMMENTER(STOPPER: CHAR);
  4904   1   22:D     2   VAR CH,SW,DEL: CHAR; LTITLE: STRING[40];
  4905   1   22:D    26 
  4906   1   23:D     1   PROCEDURE SCANSTRING(VAR STRG: STRING; MAXLENG: INTEGER);
  4907   1   23:D     3     VAR LENG: INTEGER;
  4908   1   23:0     0   BEGIN SYMCURSOR := SYMCURSOR+2;
  4909   1   23:1     5     LENG := SCAN(MAXLENG,=STOPPER,SYMBUFP^[SYMCURSOR]);
  4910   1   23:1    17     STRG[0] := CHR(LENG);
  4911   1   23:1    21     MOVELEFT(SYMBUFP^[SYMCURSOR],STRG[1],LENG);
  4912   1   23:1    28     SYMCURSOR := SYMCURSOR+LENG+1
  4913   1   23:0    31   END (*SCANSTRING*) ;
  4914   1   23:0    48 
  4915   1   22:0     0 BEGIN
  4916   1   22:1     0   SYMCURSOR := SYMCURSOR+1; (* POINT TO THE FIRST CH PAST "(*" *)
  4917   1   22:1     5   IF SYMBUFP^[SYMCURSOR]='$' THEN
  4918   1   22:2    12      IF SYMBUFP^[SYMCURSOR+1] <> STOPPER THEN
  4919   1   22:3    21 	REPEAT
  4920   1   22:4    21 	  CH := SYMBUFP^[SYMCURSOR+1];
  4921   1   22:4    28 	  SW := SYMBUFP^[SYMCURSOR+2];
  4922   1   22:4    35 	  DEL := SYMBUFP^[SYMCURSOR+3];
  4923   1   22:4    42 	  IF (SW = ',') OR (SW = STOPPER) THEN
  4924   1   22:5    51 	    BEGIN DEL := SW; SW := '+';
  4925   1   22:6    57 	      SYMCURSOR := SYMCURSOR-1
  4926   1   22:5    58 	    END;
  4927   1   22:4    62 	  CASE CH OF
  4928   1   22:4    65 	  'C': BEGIN
  4929   1   22:6    65 		 IF LEVEL > 1 THEN ERROR(194);
  4930   1   22:6    76 		 NEW(COMMENT); SCANSTRING(COMMENT^,80); EXIT(COMMENTER)
  4931   1   22:5    92 	       END;
  4932   1   22:4    94 	  'D': DEBUGGING := (SW='+');
  4933   1   22:4   101 	  'F': FLIPBYTES := (SW='+');
  4934   1   22:4   108 	  'G': GOTOOK := (SW='+');
  4935   1   22:4   115 	  'I': IF (SW='+') OR (SW='-') THEN IOCHECK := (SW='+')
  4936   1   22:5   127 	       ELSE
  4937   1   22:6   131 		 BEGIN SCANSTRING(LTITLE,40);
  4938   1   22:7   136 		   IF STOPPER = '*' THEN
  4939   1   22:8   141 		     SYMCURSOR := SYMCURSOR+1;
  4940   1   22:7   146 		   IF LIST THEN
  4941   1   22:8   150 		     BEGIN
  4942   1   22:9   150 		       SYMCURSOR := SYMCURSOR + 1;
  4943   1   22:9   155 		       PRINTLINE;
  4944   1   22:9   157 		       SYMCURSOR := SYMCURSOR - 1;
  4945   1   22:8   162 		     END;
  4946   1   22:7   162 		   IF INCLUDING OR INMODULE AND ININTERFACE THEN
  4947   1   22:8   172 		     BEGIN ERROR(406); EXIT(COMMENTER) END;
  4948   1   22:7   181 		   OPENOLD(INCLFILE,LTITLE);
  4949   1   22:7   191 		   IF IORESULT <> 0 THEN
  4950   1   22:8   197 		     BEGIN OPENOLD(INCLFILE,CONCAT(LTITLE,'.TEXT'));
  4951   1   22:9   232 			IF IORESULT <> 0 THEN ERROR(403)
  4952   1   22:8   241 		     END;
  4953   1   22:7   243 		   INCLUDING := TRUE;
  4954   1   22:7   246 		   OLDSYMCURSOR := SYMCURSOR;
  4955   1   22:7   250 		   OLDLINESTART := LINESTART;
  4956   1   22:7   255 		   OLDSYMBLK := SYMBLK-2;
  4957   1   22:7   262 		   SYMBLK := 2; GETNEXTPAGE;
  4958   1   22:7   267 		   INSYMBOL; EXIT(INSYMBOL)
  4959   1   22:6   273 		 END;
  4960   1   22:4   275 	  'L': IF (SW='+') OR (SW='-') THEN
  4961   1   22:6   284 		 BEGIN LIST := (SW='+');
  4962   1   22:7   289 		   IF LIST THEN OPENNEW(LP,'*SYSTEM.LST.TEXT')
  4963   1   22:6   320 		 END
  4964   1   22:5   320 	       ELSE
  4965   1   22:6   322 		 BEGIN SCANSTRING(LTITLE,40);
  4966   1   22:7   327 		   OPENNEW(LP,LTITLE);
  4967   1   22:7   337 		   LIST := IORESULT = 0;
  4968   1   22:7   343 		   EXIT(COMMENTER)
  4969   1   22:6   347 		 END;
  4970   1   22:4   349 	  'Q': NOISY := (SW='-');
  4971   1   22:4   356 	  'P': WRITE(LP,CHR(12(*FF*)));
  4972   1   22:4   366 	  'R': RANGECHECK := (SW='+');
  4973   1   22:4   373 	  'S': NOSWAP:=(SW='-');
  4974   1   22:4   380 	  'T': TINY := (SW='+');
  4975   1   22:4   387 	  'U': IF (SW='+') OR (SW='-') THEN
  4976   1   22:6   396 		 BEGIN SYSCOMP := (SW = '-');
  4977   1   22:7   401 		   RANGECHECK := NOT SYSCOMP;
  4978   1   22:7   406 		   IOCHECK := RANGECHECK;
  4979   1   22:7   410 		   GOTOOK := SYSCOMP
  4980   1   22:6   410 		 END
  4981   1   22:5   414 	       ELSE
  4982   1   22:6   416 		 IF NOT USING THEN
  4983   1   22:7   421 		   BEGIN SCANSTRING(SYSTEMLIB,40);
  4984   1   22:8   427 		     CLOSE(LIBRARY); LIBNOTOPEN := TRUE;
  4985   1   22:8   437 		     EXIT(COMMENTER)
  4986   1   22:7   441 		   END
  4987   1   22:4   441 	  END (*CASES*);
  4988   1   22:4   488 	  SYMCURSOR := SYMCURSOR+3;
  4989   1   22:3   493 	UNTIL DEL <> ',';
  4990   1   22:1   498   SYMCURSOR := SYMCURSOR-1; (* ADJUST *)
  4991   1   22:1   503   REPEAT
  4992   1   22:2   503     REPEAT
  4993   1   22:3   503       SYMCURSOR := SYMCURSOR+1;
  4994   1   22:3   508       WHILE SYMBUFP^[SYMCURSOR] = CHR(EOL) DO CHECKEND
  4995   1   22:2   515     UNTIL SYMBUFP^[SYMCURSOR]=STOPPER;
  4996   1   22:1   526   UNTIL (SYMBUFP^[SYMCURSOR+1]=')') OR (STOPPER='}');
  4997   1   22:1   539   SYMCURSOR := SYMCURSOR+1;
  4998   1   22:0   544 END (*COMMENTER*);
  4999   1   22:0   574 
  5000   1   24:D     1 PROCEDURE STRING;
  5001   1   24:D     1 LABEL 1;
  5002   1   24:D     1 VAR
  5003   1   24:D     1   T: PACKED ARRAY [1..80] OF CHAR;
  5004   1   24:D    41   TP,NBLANKS,L: INTEGER;
  5005   1   24:D    44   DUPLE: BOOLEAN;
  5006   1   24:D    45 
  5007   1   24:0     0 BEGIN
  5008   1   24:1     0   DUPLE := FALSE; (* INDICATES WHEN '' IS PRESENT *)
  5009   1   24:1     3   TP := 0; (* INDEX INTO TEMPORARY STRING *)
  5010   1   24:1     6   REPEAT
  5011   1   24:2     6     IF DUPLE THEN SYMCURSOR := SYMCURSOR+1;
  5012   1   24:2    15     REPEAT
  5013   1   24:3    15       SYMCURSOR := SYMCURSOR+1;
  5014   1   24:3    20       TP := TP+1;
  5015   1   24:3    26       IF SYMBUFP^[SYMCURSOR] = CHR(EOL) THEN
  5016   1   24:4    33 	BEGIN ERROR(202); CHECKEND; GOTO 1 END;
  5017   1   24:3    42       T[TP] := SYMBUFP^[SYMCURSOR];
  5018   1   24:2    52     UNTIL SYMBUFP^[SYMCURSOR]='''';
  5019   1   24:2    59     DUPLE := TRUE;
  5020   1   24:1    62   UNTIL SYMBUFP^[SYMCURSOR+1]<>'''';
  5021   1   24:1    71 1:  TP := TP-1; (* ADJUST *)
  5022   1   24:1    77   SY := STRINGCONST; OP := NOOP;
  5023   1   24:1    83   LGTH := TP; (* GROSS *)
  5024   1   24:1    87   IF TP=1 (* SINGLE CHARACTER CONSTANT *)
  5025   1   24:1    89     THEN
  5026   1   24:2    93       VAL.IVAL := ORD(T[1])
  5027   1   24:1    99     ELSE
  5028   1   24:2   103       WITH SCONST^ DO
  5029   1   24:3   107 	BEGIN
  5030   1   24:4   107 	  CCLASS := STRG;
  5031   1   24:4   111 	  SLGTH := TP;
  5032   1   24:4   118 	  MOVELEFT(T[1],SVAL[1],TP);
  5033   1   24:4   134 	  VAL.VALP := SCONST
  5034   1   24:3   134 	END
  5035   1   24:0   138 END(*STRING*);
  5036   1   24:0   154 
  5037   1   25:D     1 PROCEDURE NUMBER;
  5038   1   25:D     1 VAR
  5039   1   25:D     1   EXPONENT,ENDI,ENDF,ENDE,SIGN,IPART,FPART,EPART,
  5040   1   25:D     1   ISUM:  INTEGER;
  5041   1   25:D    10   TIPE: (REALTIPE,INTEGERTIPE);
  5042   1   25:D    11   RSUM: REAL;
  5043   1   25:D    13   NOTLONG: BOOLEAN;
  5044   1   25:D    14   K,J: INTEGER;
  5045   1   25:0     0 BEGIN
  5046   1   25:0     0   (* TAKES A NUMBER AND DECIDES WHETHER IT'S REAL
  5047   1   25:0     0      OR INTEGER AND CONVERTS IT TO THE INTERNAL
  5048   1   25:0     0      FORM. *)
  5049   1   25:1     0   TIPE := INTEGERTIPE;
  5050   1   25:1     3   ENDI := 0;
  5051   1   25:1     6   ENDF := 0;
  5052   1   25:1     9   ENDE := 0;
  5053   1   25:1    12   SIGN := 1;
  5054   1   25:1    15   NOTLONG := TRUE;
  5055   1   25:1    18   EPART := 9999; (* OUT OF REACH *)
  5056   1   25:1    23   IPART := SYMCURSOR; (* INTEGER PART STARTS HERE *)
  5057   1   25:1    26   REPEAT
  5058   1   25:2    26     SYMCURSOR := SYMCURSOR+1
  5059   1   25:1    27   UNTIL (SYMBUFP^[SYMCURSOR]<'0') OR (SYMBUFP^[SYMCURSOR]>'9');
  5060   1   25:1    44   (* SYMCURSOR NOW POINTS AT FIRST CHARACTER PAST INTEGER PART *)
  5061   1   25:1    44   ENDI := SYMCURSOR-1; (* MARK THE END OF IPART *)
  5062   1   25:1    49   IF SYMBUFP^[SYMCURSOR]='.'
  5063   1   25:1    52     THEN
  5064   1   25:2    56       IF SYMBUFP^[SYMCURSOR+1]<>'.'  (* WATCH OUT FOR '..' *)
  5065   1   25:2    61 	THEN
  5066   1   25:3    65 	  BEGIN
  5067   1   25:4    65 	    TIPE := REALTIPE;
  5068   1   25:4    68 	    SYMCURSOR := SYMCURSOR+1;
  5069   1   25:4    73 	    FPART := SYMCURSOR; (* BEGINNING OF FPART *)
  5070   1   25:4    76 	    WHILE (SYMBUFP^[SYMCURSOR] >= '0') AND
  5071   1   25:4    81 		  (SYMBUFP^[SYMCURSOR] <= '9') DO
  5072   1   25:5    89 	      SYMCURSOR := SYMCURSOR+1;
  5073   1   25:4    96 	    IF SYMCURSOR = FPART THEN ERROR(201);
  5074   1   25:4   106 	    ENDF := SYMCURSOR-1;
  5075   1   25:3   111 	  END;
  5076   1   25:1   111   IF SYMBUFP^[SYMCURSOR]='E'
  5077   1   25:1   114     THEN
  5078   1   25:2   118       BEGIN
  5079   1   25:3   118 	TIPE := REALTIPE;
  5080   1   25:3   121 	SYMCURSOR := SYMCURSOR+1;
  5081   1   25:3   126 	IF SYMBUFP^[SYMCURSOR]='-'
  5082   1   25:3   129 	  THEN
  5083   1   25:4   133 	    BEGIN
  5084   1   25:5   133 	      SYMCURSOR := SYMCURSOR+1;
  5085   1   25:5   138 	      SIGN := -1;
  5086   1   25:4   142 	    END
  5087   1   25:3   142 	  ELSE
  5088   1   25:4   144 	    IF SYMBUFP^[SYMCURSOR]='+'
  5089   1   25:4   147 	      THEN
  5090   1   25:5   151 		SYMCURSOR := SYMCURSOR+1;
  5091   1   25:3   156 	EPART := SYMCURSOR; (* BEGINNING OF EXPONENT *)
  5092   1   25:3   159 	WHILE (SYMBUFP^[SYMCURSOR]>='0') AND (SYMBUFP^[SYMCURSOR]<='9') DO
  5093   1   25:4   172 	  SYMCURSOR := SYMCURSOR+1;
  5094   1   25:3   179   	ENDE := SYMCURSOR-1;
  5095   1   25:3   184 	IF ENDE<EPART THEN ERROR(201); (* ERROR IN REAL CONSTANT *)
  5096   1   25:2   194       END;
  5097   1   25:2   194   (* NOW CONVERT TO INTERNAL FORM *)
  5098   1   25:1   194   IF TIPE=INTEGERTIPE THEN
  5099   1   25:2   199     BEGIN
  5100   1   25:3   199       ISUM := 0;
  5101   1   25:3   202       FOR J := IPART TO ENDI DO
  5102   1   25:4   213 	BEGIN
  5103   1   25:5   213 	  IF (ISUM>MAXINT DIV 10) OR ((ISUM=MAXINT DIV 10) AND 
  5104   1   25:5   227 		      (ORD(SYMBUFP^[J]) - ORD('0') > MAXINT MOD 10)) THEN
  5105   1   25:6   242 	      BEGIN NOTLONG := FALSE; K := J; J := ENDI END
  5106   1   25:5   251 	  ELSE ISUM := ISUM*10+(ORD(SYMBUFP^[J])-ORD('0'));
  5107   1   25:4   264 	END;
  5108   1   25:3   271 	IF NOTLONG THEN
  5109   1   25:4   274 	  BEGIN
  5110   1   25:5   274 	    SY := INTCONST;  OP := NOOP;
  5111   1   25:5   280 	    VAL.IVAL := ISUM;
  5112   1   25:4   283 	  END
  5113   1   25:3   283 	ELSE
  5114   1   25:4   285 	  BEGIN 
  5115   1   25:5   285 	    IF ENDI - IPART >= MAXDEC THEN
  5116   1   25:6   292 	      BEGIN ERROR(203); IPART := ENDI; K := ENDI END;
  5117   1   25:5   303 	    NEW(LVP,LONG);
  5118   1   25:5   309 	    WITH LVP^ DO
  5119   1   25:6   314 	      BEGIN CCLASS := LONG; J := 4; LLENG := 0;
  5120   1   25:7   325 		WHILE K <= ENDI DO
  5121   1   25:8   330 		  BEGIN
  5122   1   25:9   330 		    IF J = 4 THEN
  5123   1   25:0   335 		      BEGIN LLENG := LLENG + 1;
  5124   1   25:1   343 			LONGVAL[LLENG] := ISUM;
  5125   1   25:1   354 			ISUM := 0;
  5126   1   25:1   357 			J := 0
  5127   1   25:0   357 		      END;
  5128   1   25:9   360 		    ISUM := ISUM * 10 + ORD(SYMBUFP^[K])-ORD('0');
  5129   1   25:9   371 	            K := K + 1; J := J + 1
  5130   1   25:8   377 		  END;
  5131   1   25:7   383 	        LLAST := J;
  5132   1   25:7   388 		IF J > 0 THEN
  5133   1   25:8   393 		  BEGIN LLENG := LLENG + 1;
  5134   1   25:9   401 		    LONGVAL[LLENG] := ISUM
  5135   1   25:8   410 		  END;
  5136   1   25:6   412 	      END;
  5137   1   25:5   412 	    SY := LONGCONST; OP := NOOP;
  5138   1   25:5   418 	    LGTH := ENDI - IPART + 1;
  5139   1   25:5   425 	    VAL.VALP := LVP
  5140   1   25:4   425 	  END;
  5141   1   25:2   430     END (*TIPE = INTEGERTIPE*)
  5142   1   25:1   430   ELSE
  5143   1   25:2   432     BEGIN (* REAL NUMBER HERE *)
  5144   1   25:3   432       RSUM := 0;
  5145   1   25:3   438       FOR J := IPART TO ENDI DO
  5146   1   25:4   449 	BEGIN
  5147   1   25:5   449 	  RSUM := RSUM*10+(ORD(SYMBUFP^[J])-ORD('0'));
  5148   1   25:4   467 	END;
  5149   1   25:3   474       FOR J := ENDF DOWNTO FPART DO
  5150   1   25:4   485 	RSUM := RSUM+(ORD(SYMBUFP^[J])-ORD('0'))/PWROFTEN(J-FPART+1);
  5151   1   25:3   515       EXPONENT := 0;
  5152   1   25:3   518       FOR J := EPART TO ENDE DO
  5153   1   25:4   529 	EXPONENT := EXPONENT*10+ORD(SYMBUFP^[J])-ORD('0');
  5154   1   25:3   547       IF SIGN=-1 THEN
  5155   1   25:4   553 	RSUM := RSUM/PWROFTEN(EXPONENT)
  5156   1   25:3   560       ELSE
  5157   1   25:4   567 	RSUM := RSUM*PWROFTEN(EXPONENT);
  5158   1   25:3   579       SY := REALCONST;  OP := NOOP;
  5159   1   25:3   585       NEW(LVP,REEL);
  5160   1   25:3   591       LVP^.CCLASS := REEL;
  5161   1   25:3   596       LVP^.RVAL := RSUM;
  5162   1   25:3   607       VAL.VALP := LVP;
  5163   1   25:2   612     END;
  5164   1   25:1   612   SYMCURSOR := SYMCURSOR-1; (* ADJUST FOR POSTERITY *)
  5165   1   25:0   617 END (*NUMBER*) ;
  5166   1   25:0   652 
  5167   1    6:0     0 BEGIN (* INSYMBOL *)
  5168   1    6:1     0   IF GETSTMTLEV THEN BEGIN BEGSTMTLEV := STMTLEV; GETSTMTLEV := FALSE END;
  5169   1    6:1    11   OP := NOOP;
  5170   1    6:1    14 1:  SY := OTHERSY; (* IF NO CASES EXERCISED BLOW UP *)
  5171   1    6:1    17   CASE SYMBUFP^[SYMCURSOR] OF
  5172   1    6:1    22   '''':STRING;
  5173   1    6:1    26   '0','1','2','3','4','5','6','7','8','9':
  5174   1    6:2    26        NUMBER;
  5175   1    6:1    30   'A','B','C','D','E','F','G','H','I','J','K','L','M',
  5176   1    6:1    30   'N','O','P','Q','R','S','T','U','V','W','X','Y','Z',
  5177   1    6:1    30   'a','b','c','d','e','f','g','h','i','j','k','l','m',
  5178   1    6:1    30   'n','o','p','q','r','s','t','u','v','w','x','y','z':
  5179   1    6:2    30        IDSEARCH(SYMCURSOR,SYMBUFP^); (* MAGIC PROC *)
  5180   1    6:1    37   '{': BEGIN COMMENTER('}'); GOTO 1 END;
  5181   1    6:1    44   '(': BEGIN
  5182   1    6:3    44 	 IF SYMBUFP^[SYMCURSOR+1]='*' THEN
  5183   1    6:4    53 	     BEGIN
  5184   1    6:5    53 		SYMCURSOR := SYMCURSOR+1;
  5185   1    6:5    58 		COMMENTER('*');
  5186   1    6:5    61 		SYMCURSOR := SYMCURSOR+1;
  5187   1    6:5    66 		GOTO 1; (* GET ANOTHER TOKEN *)
  5188   1    6:4    68 	     END
  5189   1    6:3    68 	   ELSE
  5190   1    6:4    70 	     SY := LPARENT;
  5191   1    6:2    73        END;
  5192   1    6:1    75   ')': SY := RPARENT;
  5193   1    6:1    80   ',': SY := COMMA;
  5194   1    6:1    85   ' ','	': BEGIN SYMCURSOR := SYMCURSOR+1; GOTO 1; END;
  5195   1    6:1    94   '.': BEGIN
  5196   1    6:3    94 	 IF SYMBUFP^[SYMCURSOR+1]='.'
  5197   1    6:3    99 	   THEN
  5198   1    6:4   103 	     BEGIN
  5199   1    6:5   103 	       SYMCURSOR := SYMCURSOR+1;
  5200   1    6:5   108 	       SY := COLON
  5201   1    6:4   108 	     END
  5202   1    6:3   111 	   ELSE
  5203   1    6:4   113 	     SY := PERIOD;
  5204   1    6:2   116        END;
  5205   1    6:1   118   ':': IF SYMBUFP^[SYMCURSOR+1]='='
  5206   1    6:2   123 	 THEN
  5207   1    6:3   127 	   BEGIN
  5208   1    6:4   127 	     SYMCURSOR := SYMCURSOR+1;
  5209   1    6:4   132 	     SY := BECOMES;
  5210   1    6:3   135 	  END
  5211   1    6:2   135 	ELSE
  5212   1    6:3   137 	   SY := COLON;
  5213   1    6:1   142   ';': SY := SEMICOLON;
  5214   1    6:1   147   '^': SY := ARROW;
  5215   1    6:1   152   '[': SY := LBRACK;
  5216   1    6:1   157   ']': SY := RBRACK;
  5217   1    6:1   162   '*': BEGIN SY := MULOP; OP := MUL END;
  5218   1    6:1   170   '+': BEGIN SY := ADDOP; OP := PLUS END;
  5219   1    6:1   178   '-': BEGIN SY := ADDOP; OP := MINUS END;
  5220   1    6:1   186   '/': BEGIN SY := MULOP; OP := RDIV END;
  5221   1    6:1   194   '<': BEGIN
  5222   1    6:3   194 	 SY := RELOP;
  5223   1    6:3   197 	 OP := LTOP;
  5224   1    6:3   200 	 CASE SYMBUFP^[SYMCURSOR+1] OF
  5225   1    6:3   207 	   '>': BEGIN
  5226   1    6:5   207 		  OP := NEOP;
  5227   1    6:5   210 		  SYMCURSOR := SYMCURSOR+1
  5228   1    6:4   211 		END;
  5229   1    6:3   217 	   '=': BEGIN
  5230   1    6:5   217 		  OP := LEOP;
  5231   1    6:5   220 		  SYMCURSOR := SYMCURSOR+1
  5232   1    6:4   221 		END
  5233   1    6:3   225 	 END;
  5234   1    6:2   238        END;
  5235   1    6:1   240   '=': BEGIN SY := RELOP; OP := EQOP END;
  5236   1    6:1   248   '>': BEGIN
  5237   1    6:3   248 	 SY := RELOP;
  5238   1    6:3   251 	 IF SYMBUFP^[SYMCURSOR+1]='='
  5239   1    6:3   256 	   THEN
  5240   1    6:4   260 	     BEGIN
  5241   1    6:5   260 	       OP := GEOP;
  5242   1    6:5   263 	       SYMCURSOR := SYMCURSOR+1;
  5243   1    6:4   268 	     END
  5244   1    6:3   268 	   ELSE
  5245   1    6:4   270 	     OP := GTOP;
  5246   1    6:2   273        END
  5247   1    6:1   273 END (* CASE SYMBUFP^[SYMCURSOR] OF *);
  5248   1    6:1   512   IF SY=OTHERSY THEN
  5249   1    6:2   518     IF SYMBUFP^[SYMCURSOR] = CHR(EOL) THEN
  5250   1    6:3   525       BEGIN CHECKEND; GETSTMTLEV := TRUE; GOTO 1 END
  5251   1    6:2   532     ELSE ERROR(400);
  5252   1    6:1   539   SYMCURSOR := SYMCURSOR+1; (* NEXT CALL TALKS ABOUT NEXT TOKEN *)
  5253   1    6:0   544 END (*INSYMBOL*) ;
  5254   1    6:0   562 
  5255   1    6:0   562 (* --- PROCS.B.TEXT --- *)
  5256   1    6:0   562 
  5257   1    6:0   562   (*      COPYRIGHT  (C) 1979, REGENTS OF THE      *)
  5258   1    6:0   562   (*      UNIVERSITY OF CALIFORNIA, SAN DIEGO      *)
  5259   1    6:0   562 
  5260   1    7:D     1   PROCEDURE SEARCHSECTION(*FCP: CTP; VAR FCP1: CTP*);
  5261   1    7:0     0   BEGIN
  5262   1    7:1     0     IF FCP <> NIL THEN
  5263   1    7:2     5       IF TREESEARCH(FCP,FCP1,ID) = 0 THEN (*NADA*)
  5264   1    7:2    15       ELSE FCP1 := NIL
  5265   1    7:1    18     ELSE FCP1 := NIL
  5266   1    7:0    23   END (*SEARCHSECTION*) ;
  5267   1    7:0    38 
  5268   1    8:D     1   PROCEDURE SEARCHID(*FIDCLS: SETOFIDS; VAR FCP: CTP*);
  5269   1    8:D     3     LABEL 1; VAR LCP: CTP;
  5270   1    8:0     0   BEGIN
  5271   1    8:1     0     FOR DISX := TOP DOWNTO 0 DO
  5272   1    8:2    12       BEGIN LCP := DISPLAY[DISX].FNAME;
  5273   1    8:3    21 	IF LCP <> NIL THEN
  5274   1    8:4    26 	  IF TREESEARCH(LCP,LCP,ID) = 0 THEN
  5275   1    8:5    37 	    IF LCP^.KLASS IN FIDCLS THEN GOTO 1
  5276   1    8:5    47 	    ELSE
  5277   1    8:6    49 	      IF PRTERR THEN ERROR(103)
  5278   1    8:6    54 	      ELSE LCP := NIL
  5279   1    8:4    58 	  ELSE LCP := NIL
  5280   1    8:2    63       END;
  5281   1    8:1    74     IF PRTERR THEN
  5282   1    8:2    78       BEGIN ERROR(104);
  5283   1    8:3    81 	IF TYPES IN FIDCLS THEN LCP := UTYPPTR
  5284   1    8:3    87 	ELSE
  5285   1    8:4    93 	  IF ACTUALVARS IN FIDCLS THEN LCP := UVARPTR
  5286   1    8:4    99 	  ELSE
  5287   1    8:5   105 	    IF FIELD IN FIDCLS THEN LCP := UFLDPTR
  5288   1    8:5   111 	    ELSE
  5289   1    8:6   117 	      IF KONST IN FIDCLS THEN LCP := UCSTPTR
  5290   1    8:6   123 	      ELSE
  5291   1    8:7   129 		IF PROC IN FIDCLS THEN LCP := UPRCPTR
  5292   1    8:7   135 		ELSE LCP := UFCTPTR
  5293   1    8:2   141       END;
  5294   1    8:1   145 1:  FCP := LCP
  5295   1    8:0   146   END (*SEARCHID*) ;
  5296   1    8:0   162 
  5297   1    9:D     1   PROCEDURE GETBOUNDS(*FSP: STP; VAR FMIN,FMAX: INTEGER*);
  5298   1    9:0     0   BEGIN
  5299   1    9:1     0     WITH FSP^ DO
  5300   1    9:2     3       IF FORM = SUBRANGE THEN
  5301   1    9:3     9 	BEGIN FMIN := MIN.IVAL; FMAX := MAX.IVAL END
  5302   1    9:2    17       ELSE
  5303   1    9:3    19 	BEGIN FMIN := 0;
  5304   1    9:4    22 	  IF FSP = CHARPTR THEN FMAX := 255
  5305   1    9:4    29 	  ELSE
  5306   1    9:5    35 	    IF FSP^.FCONST <> NIL THEN
  5307   1    9:6    41 	      FMAX := FSP^.FCONST^.VALUES.IVAL
  5308   1    9:5    44 	    ELSE FMAX := 0
  5309   1    9:3    50 	END
  5310   1    9:0    52   END (*GETBOUNDS*) ;
  5311   1    9:0    64 
  5312   1   10:D     1   PROCEDURE SKIP(*FSYS: SETOFSYS*);
  5313   1   10:0     0   BEGIN WHILE NOT(SY IN FSYS) DO INSYMBOL
  5314   1   10:0    11   END (*SKIP*) ;
  5315   1   10:0    30 
  5316   1   11:D     3   FUNCTION PAOFCHAR(*FSP: STP): BOOLEAN*);
  5317   1   11:0     0   BEGIN PAOFCHAR := FALSE;
  5318   1   11:1     3     IF FSP <> NIL THEN
  5319   1   11:2     8       IF FSP^.FORM = ARRAYS THEN
  5320   1   11:3    14 	PAOFCHAR := FSP^.AISPACKD AND (FSP^.AELTYPE = CHARPTR)
  5321   1   11:0    21   END (*PAOFCHAR*) ;
  5322   1   11:0    36 
  5323   1   12:D     3   FUNCTION STRGTYPE(*FSP: STP) : BOOLEAN*);
  5324   1   12:0     0   BEGIN STRGTYPE := FALSE;
  5325   1   12:1     3     IF PAOFCHAR(FSP) THEN STRGTYPE := FSP^.AISSTRNG
  5326   1   12:0    11   END (*STRGTYPE*) ;
  5327   1   12:0    26 
  5328   1   13:D     3   FUNCTION DECSIZE(*I: INTEGER): INTEGER*);
  5329   1   13:0     0   BEGIN DECSIZE := (I + 3) DIV 4 + 1 (*GROSS..MAXIMUM NEEDED SPACE*)
  5330   1   13:0     5   (* BINARY FN. SHOULD BE ((I*332) DIV 100 + 1 + BITSPERWD) DIV BITSPERWD *)
  5331   1   13:0     5   END (*DECSIZE*) ;
  5332   1   13:0    22 
  5333   1   14:D     1   PROCEDURE CONSTANT(*FSYS: SETOFSYS; VAR FSP: STP; VAR FVALU: VALU*);
  5334   1   14:D     7     VAR LSP: STP; LCP: CTP; SIGN: (NONE,POS,NEG);
  5335   1   14:D    10 	LVP: CSP;
  5336   1   14:0     0   BEGIN LSP := NIL; FVALU.IVAL := 0;
  5337   1   14:1     6     IF NOT(SY IN CONSTBEGSYS) THEN
  5338   1   14:2    17       BEGIN ERROR(50); SKIP(FSYS+CONSTBEGSYS) END;
  5339   1   14:1    35     IF SY IN CONSTBEGSYS THEN
  5340   1   14:2    45       BEGIN
  5341   1   14:3    45 	IF SY = STRINGCONSTSY THEN
  5342   1   14:4    51 	  BEGIN
  5343   1   14:5    51 	    IF LGTH = 1 THEN LSP := CHARPTR
  5344   1   14:5    57 	    ELSE
  5345   1   14:6    63 	      BEGIN
  5346   1   14:7    63 		NEW(LSP,ARRAYS,TRUE,TRUE);
  5347   1   14:7    68 		LSP^ := STRGPTR^;
  5348   1   14:7    73 		LSP^.MAXLENG := LGTH;
  5349   1   14:7    79 		LSP^.INXTYPE := NIL;
  5350   1   14:7    84 		NEW(LVP);
  5351   1   14:7    91 		LVP^ := VAL.VALP^;
  5352   1   14:7    97 		VAL.VALP := LVP
  5353   1   14:6    97 	      END;
  5354   1   14:5   100 	    FVALU := VAL; INSYMBOL
  5355   1   14:4   105 	  END
  5356   1   14:3   107 	ELSE
  5357   1   14:4   109 	  BEGIN
  5358   1   14:5   109 	    SIGN := NONE;
  5359   1   14:5   112 	    IF (SY = ADDOP) AND (OP IN [PLUS,MINUS]) THEN
  5360   1   14:6   124 	      BEGIN IF OP = PLUS THEN SIGN := POS ELSE SIGN := NEG;
  5361   1   14:7   138 		INSYMBOL
  5362   1   14:6   138 	      END;
  5363   1   14:5   140 	    IF SY = IDENT THEN
  5364   1   14:6   146 	      BEGIN SEARCHID([KONST],LCP);
  5365   1   14:7   154 		WITH LCP^ DO
  5366   1   14:8   157 		  BEGIN LSP := IDTYPE; FVALU := VALUES END;
  5367   1   14:7   167 		IF SIGN <> NONE THEN
  5368   1   14:8   172 		  IF LSP = INTPTR THEN
  5369   1   14:9   177 		    BEGIN IF SIGN = NEG THEN
  5370   1   14:1   182 		      FVALU.IVAL := -FVALU.IVAL END
  5371   1   14:8   187 		  ELSE
  5372   1   14:9   189 		    IF LSP = REALPTR THEN
  5373   1   14:0   195 		      BEGIN
  5374   1   14:1   195 			IF SIGN = NEG THEN
  5375   1   14:2   200 			  BEGIN NEW(LVP,REEL);
  5376   1   14:3   205 			    LVP^.CCLASS := REEL;
  5377   1   14:3   208 			    LVP^.RVAL := -FVALU.VALP^.RVAL;
  5378   1   14:3   220 			    FVALU.VALP := LVP;
  5379   1   14:2   223 			  END
  5380   1   14:0   223 		      END
  5381   1   14:9   223 		    ELSE
  5382   1   14:0   225 		      IF COMPTYPES(LSP,LONGINTPTR) THEN
  5383   1   14:1   234 			BEGIN
  5384   1   14:2   234 			  IF SIGN = NEG THEN
  5385   1   14:3   239 			    BEGIN NEW(LVP,LONG);
  5386   1   14:4   244 			      LVP^.CCLASS := LONG;
  5387   1   14:4   247 			      LVP^.LONGVAL[1] := - FVALU.VALP^.LONGVAL[1];
  5388   1   14:4   267 			      FVALU.VALP := LVP
  5389   1   14:3   268 			    END
  5390   1   14:1   270 			END
  5391   1   14:0   270 		      ELSE ERROR(105);
  5392   1   14:7   275 		INSYMBOL;
  5393   1   14:6   277 	      END
  5394   1   14:5   277 	    ELSE
  5395   1   14:6   279 	      IF SY = INTCONST THEN
  5396   1   14:7   285 		BEGIN IF SIGN = NEG THEN VAL.IVAL := -VAL.IVAL;
  5397   1   14:8   295 		  LSP := INTPTR; FVALU := VAL; INSYMBOL
  5398   1   14:7   303 		END
  5399   1   14:6   305 	      ELSE
  5400   1   14:7   307 		IF SY = REALCONST THEN
  5401   1   14:8   313 		  BEGIN IF SIGN = NEG THEN
  5402   1   14:0   318 			  VAL.VALP^.RVAL := -VAL.VALP^.RVAL;
  5403   1   14:9   331 		    LSP := REALPTR; FVALU := VAL; INSYMBOL
  5404   1   14:8   340 		  END
  5405   1   14:7   342 		ELSE
  5406   1   14:8   344 		  IF SY = LONGCONST THEN
  5407   1   14:9   350 		    BEGIN
  5408   1   14:0   350 		      IF SIGN = NEG THEN
  5409   1   14:1   355 			BEGIN VAL.VALP^.LONGVAL[1] := - VAL.VALP^.LONGVAL[1];
  5410   1   14:2   376 			  NEW(LSP,LONGINT);
  5411   1   14:2   381 			  LSP^.SIZE := DECSIZE(LGTH);
  5412   1   14:2   389 			  LSP^.FORM := LONGINT;
  5413   1   14:2   394 			  FVALU := VAL;
  5414   1   14:2   399 			  INSYMBOL
  5415   1   14:1   399 			END
  5416   1   14:9   401 		    END
  5417   1   14:8   401 		  ELSE
  5418   1   14:9   403 		    BEGIN ERROR(106); SKIP(FSYS) END
  5419   1   14:4   415 	  END;
  5420   1   14:3   415 	IF NOT (SY IN FSYS) THEN
  5421   1   14:4   426 	  BEGIN ERROR(6); SKIP(FSYS) END
  5422   1   14:2   438 	END;
  5423   1   14:1   438     FSP := LSP
  5424   1   14:0   439   END (*CONSTANT*) ;
  5425   1   14:0   462 
  5426   1   15:D     3   FUNCTION COMPTYPES(*FSP1,FSP2: STP) : BOOLEAN*);
  5427   1   15:D     5     VAR NXT1,NXT2: CTP; COMP: BOOLEAN;
  5428   1   15:D     8       LTESTP1,LTESTP2 : TESTP;
  5429   1   15:0     0   BEGIN
  5430   1   15:1     0     IF FSP1 = FSP2 THEN COMPTYPES := TRUE
  5431   1   15:1     5     ELSE
  5432   1   15:2    10       IF (FSP1 = NIL) OR (FSP2 = NIL) THEN COMPTYPES := TRUE
  5433   1   15:2    19       ELSE
  5434   1   15:3    24 	IF FSP1^.FORM = FSP2^.FORM THEN
  5435   1   15:4    31 	  CASE FSP1^.FORM OF
  5436   1   15:4    35 	    SCALAR:
  5437   1   15:5    35 	      COMPTYPES := FALSE;
  5438   1   15:4    40 	    SUBRANGE:
  5439   1   15:5    40 	      COMPTYPES := COMPTYPES(FSP1^.RANGETYPE,
  5440   1   15:5    42 				       FSP2^.RANGETYPE);
  5441   1   15:4    52 	    POINTER:
  5442   1   15:5    52 		BEGIN
  5443   1   15:6    52 		  COMP := FALSE; LTESTP1 := GLOBTESTP;
  5444   1   15:6    59 		  LTESTP2 := GLOBTESTP;
  5445   1   15:6    63 		  WHILE LTESTP1 <> NIL DO
  5446   1   15:7    68 		    WITH LTESTP1^ DO
  5447   1   15:8    71 		      BEGIN
  5448   1   15:9    71 			IF (ELT1 = FSP1^.ELTYPE) AND
  5449   1   15:9    76 			  (ELT2 = FSP2^.ELTYPE) THEN COMP := TRUE;
  5450   1   15:9    87 			LTESTP1 := LASTTESTP
  5451   1   15:8    87 		      END;
  5452   1   15:6    93 		  IF NOT COMP THEN
  5453   1   15:7    97 		    BEGIN NEW(LTESTP1);
  5454   1   15:8   102 		      WITH LTESTP1^ DO
  5455   1   15:9   105 			BEGIN ELT1 := FSP1^.ELTYPE;
  5456   1   15:0   111 			  ELT2 := FSP2^.ELTYPE;
  5457   1   15:0   115 			  LASTTESTP := GLOBTESTP
  5458   1   15:9   118 			END;
  5459   1   15:8   121 		      GLOBTESTP := LTESTP1;
  5460   1   15:8   124 		      COMP := COMPTYPES(FSP1^.ELTYPE,FSP2^.ELTYPE)
  5461   1   15:7   128 		    END;
  5462   1   15:6   134 		  COMPTYPES := COMP; GLOBTESTP := LTESTP2
  5463   1   15:5   137 		END;
  5464   1   15:4   142 	    LONGINT: COMPTYPES := TRUE;
  5465   1   15:4   147 	    POWER:
  5466   1   15:5   147 	      COMPTYPES := COMPTYPES(FSP1^.ELSET,FSP2^.ELSET);
  5467   1   15:4   159 	    ARRAYS:
  5468   1   15:5   159 	      BEGIN
  5469   1   15:6   159 		COMP := COMPTYPES(FSP1^.AELTYPE,FSP2^.AELTYPE)
  5470   1   15:6   163 			AND (FSP1^.AISPACKD = FSP2^.AISPACKD);
  5471   1   15:6   176 		IF COMP AND FSP1^.AISPACKD THEN
  5472   1   15:7   182 		    COMP := (FSP1^.ELSPERWD = FSP2^.ELSPERWD)
  5473   1   15:7   187 			    AND (FSP1^.ELWIDTH = FSP2^.ELWIDTH)
  5474   1   15:7   192 			    AND (FSP1^.AISSTRNG = FSP2^.AISSTRNG);
  5475   1   15:6   202 		IF COMP AND NOT STRGTYPE(FSP1) THEN
  5476   1   15:7   212 		  COMP := (FSP1^.SIZE = FSP2^.SIZE);
  5477   1   15:6   219 		COMPTYPES := COMP;
  5478   1   15:5   222 	      END;
  5479   1   15:4   224 	    RECORDS:
  5480   1   15:5   224 	      BEGIN NXT1 := FSP1^.FSTFLD; NXT2 := FSP2^.FSTFLD;
  5481   1   15:6   232 		COMP := TRUE;
  5482   1   15:6   235 		WHILE (NXT1 <> NIL) AND (NXT2 <> NIL) AND COMP DO
  5483   1   15:7   246 		  BEGIN COMP:=COMPTYPES(NXT1^.IDTYPE,NXT2^.IDTYPE);
  5484   1   15:8   256 		    NXT1 := NXT1^.NEXT; NXT2 := NXT2^.NEXT
  5485   1   15:7   261 		  END;
  5486   1   15:6   266 		COMPTYPES := COMP AND (NXT1 = NIL) AND (NXT2 = NIL)
  5487   1   15:6   274 			    AND (FSP1^.RECVAR = NIL)
  5488   1   15:6   279 			    AND (FSP2^.RECVAR = NIL)
  5489   1   15:5   284 	      END;
  5490   1   15:4   289 	    FILES:
  5491   1   15:5   289 	      COMPTYPES := COMPTYPES(FSP1^.FILTYPE,FSP2^.FILTYPE)
  5492   1   15:4   293 	  END (*CASE*)
  5493   1   15:3   324 	ELSE (*FSP1^.FORM <> FSP2^.FORM*)
  5494   1   15:4   326 	  IF FSP1^.FORM = SUBRANGE THEN
  5495   1   15:5   332 	    COMPTYPES := COMPTYPES(FSP1^.RANGETYPE,FSP2)
  5496   1   15:4   335 	  ELSE
  5497   1   15:5   343 	    IF FSP2^.FORM = SUBRANGE THEN
  5498   1   15:6   349 	      COMPTYPES := COMPTYPES(FSP1,FSP2^.RANGETYPE)
  5499   1   15:5   352 	    ELSE COMPTYPES := FALSE
  5500   1   15:0   360   END (*COMPTYPES*) ;
  5501   1   15:0   390   
  5502   1   15:0   390 
  5503   1   16:D     1   PROCEDURE GENBYTE(*FBYTE: INTEGER*);
  5504   1   16:0     0   BEGIN
  5505   1   16:1     0     CODEP^[IC] := CHR(FBYTE); IC := IC+1
  5506   1   16:0     5   END (*GENBYTE*) ;
  5507   1   16:0    22 
  5508   1   17:D     1   PROCEDURE GENWORD(*FWORD: INTEGER*);
  5509   1   17:D     2    VAR TEMP: CHAR;
  5510   1   17:0     0   BEGIN
  5511   1   17:1     0     IF ODD(IC) THEN IC := IC + 1;
  5512   1   17:1     8     MOVELEFT(FWORD,CODEP^[IC],2);
  5513   1   17:1    16     IF FLIPBYTES THEN
  5514   1   17:2    20       BEGIN
  5515   1   17:3    20 	TEMP := CODEP^[IC];
  5516   1   17:3    25 	CODEP^[IC] := CODEP^[IC+1];
  5517   1   17:3    33 	CODEP^[IC+1] := TEMP
  5518   1   17:2    37       END;
  5519   1   17:1    39     IC := IC + 2
  5520   1   17:0    40   END (*GENWORD*) ;
  5521   1   17:0    56 
  5522   1   18:D     1 PROCEDURE WRITETEXT;
  5523   1   18:0     0   BEGIN
  5524   1   18:1     0     MOVELEFT(SYMBUFP^[SYMCURSOR],CODEP^[0],1024);
  5525   1   18:1     9     IF USERINFO.ERRNUM = 0 THEN
  5526   1   18:2    16       IF BLOCKWRITE(USERINFO.WORKCODE^,CODEP^[0],2,CURBLK) <> 2 THEN
  5527   1   18:3    35 	ERROR(402);
  5528   1   18:1    40     CURBLK := CURBLK + 2
  5529   1   18:0    43   END (*WRITETEXT*) ;
  5530   1   18:0    60 
  5531   1   19:D     1   PROCEDURE WRITECODE(*FORCEBUF: BOOLEAN*);
  5532   1   19:D     2     VAR CODEINX,LIC,I: INTEGER;
  5533   1   19:0     0   BEGIN CODEINX := 0; LIC := IC;
  5534   1   19:1     6     REPEAT
  5535   1   19:2     6       I := 512-CURBYTE;
  5536   1   19:2    15       IF I > LIC THEN I := LIC;
  5537   1   19:2    23       MOVELEFT(CODEP^[CODEINX],DISKBUF[CURBYTE],I);
  5538   1   19:2    34       CODEINX := CODEINX+I;
  5539   1   19:2    39       CURBYTE := CURBYTE+I;
  5540   1   19:2    47       IF (CURBYTE = 512) OR FORCEBUF THEN
  5541   1   19:3    58 	BEGIN
  5542   1   19:4    58 	  IF USERINFO.ERRNUM = 0 THEN
  5543   1   19:5    65 	    IF BLOCKWRITE(USERINFO.WORKCODE^,DISKBUF,1,CURBLK) <> 1 THEN
  5544   1   19:6    86 	      ERROR(402);
  5545   1   19:4    91 	  CURBLK := CURBLK+1; CURBYTE := 0
  5546   1   19:3    99 	END;
  5547   1   19:2   103       LIC := LIC-I
  5548   1   19:1   104     UNTIL LIC = 0;
  5549   1   19:0   113   END (*WRITECODE*) ;
  5550   1   19:0   128 
  5551   1   26:D     1   PROCEDURE FINISHSEG;
  5552   1   26:D     1     VAR I: INTEGER;
  5553   1   26:0     0   BEGIN IC := 0;
  5554   1   26:1     3     FOR I := NEXTPROC-1 DOWNTO 1 DO 
  5555   1   26:2    17       IF PROCTABLE[I] = 0 THEN 
  5556   1   26:3    28 	GENWORD(0)
  5557   1   26:2    29       ELSE 
  5558   1   26:3    33         GENWORD(SEGINX+IC-PROCTABLE[I]);
  5559   1   26:1    54     GENBYTE(SEG); GENBYTE(NEXTPROC-1);
  5560   1   26:1    63     SEGTABLE[SEG].CODELENG := SEGINX+IC;
  5561   1   26:1    74     WRITECODE(TRUE); SEGINX := 0; CODEINSEG := FALSE
  5562   1   26:0    80   END (*FINISHSEG*) ;
  5563   1   26:0    98 
  5564   1   26:0    98 (* --- BLOCK.TEXT --- *)
  5565   1   26:0    98 
  5566   1   20:D     1 PROCEDURE BLOCK(*FSYS: SETOFSYS*);
  5567   1   20:D     5 LABEL 1;
  5568   1   20:D     5 VAR BFSYFOUND: BOOLEAN;
  5569   1   20:D     6 
  5570   1   27:D     1   PROCEDURE FINDFORW(FCP: CTP);
  5571   1   27:0     0     BEGIN
  5572   1   27:1     0       IF FCP <> NIL THEN
  5573   1   27:2     5 	WITH FCP^ DO
  5574   1   27:3     8 	  BEGIN
  5575   1   27:4     8 	    IF KLASS IN [PROC,FUNC] THEN
  5576   1   27:5    16 	      IF PFDECKIND = DECLARED THEN
  5577   1   27:6    23 		IF PFKIND = ACTUAL THEN
  5578   1   27:7    30 		  IF FORWDECL THEN
  5579   1   27:8    35 		    BEGIN
  5580   1   27:9    35 		      USERINFO.ERRNUM := 117; WRITELN(OUTPUT);
  5581   1   27:9    45 		      WRITE(OUTPUT,NAME,' undefined')
  5582   1   27:8    74 		    END;
  5583   1   27:4    74 	    FINDFORW(RLINK); FINDFORW(LLINK)
  5584   1   27:3    80 	  END
  5585   1   27:0    82     END (*FINDFORW*) ;
  5586   1   27:0    94 
  5587   1   20:0     0   BEGIN (*BLOCK*)
  5588   1   20:1     0      IF (NOSWAP) AND (STARTINGUP) THEN
  5589   1   20:2     7        BEGIN
  5590   1   20:3     7 	 BODYPART(FSYS,NIL);
  5591   1   20:3    18 	 EXIT(BLOCK);
  5592   1   20:2    22        END;
  5593   1   20:1    22      IF (SY IN [UNITSY,SEPARATSY]) AND (NOT INMODULE) THEN
  5594   1   20:2    42        BEGIN
  5595   1   20:3    42 	 UNITPART(FSYS + [UNITSY,INTERSY,IMPLESY,ENDSY]);
  5596   1   20:3    65 	 IF SY = PERIOD THEN EXIT(BLOCK)
  5597   1   20:2    75        END;
  5598   1   20:1    75      NEWBLOCK:=TRUE;
  5599   1   20:1    78      REPEAT
  5600   1   20:2    78        IF NOT NEWBLOCK THEN
  5601   1   20:3    83 	 BEGIN
  5602   1   20:4    83 	   DP := FALSE; STMTLEV := 0; IC := 0; LINEINFO := 0;
  5603   1   20:4    95 	   IF (NOT SYSCOMP) OR (LEVEL>1) THEN FINDFORW(DISPLAY[TOP].FNAME);
  5604   1   20:4   113 	   IF INMODULE THEN
  5605   1   20:5   117 	     IF TOS^.PREVLEXSTACKP^.DFPROCP = OUTERBLOCK THEN
  5606   1   20:6   127 	       IF (SY = ENDSY) THEN
  5607   1   20:7   133 		 BEGIN FINISHSEG; EXIT(BLOCK) END
  5608   1   20:6   139 	       ELSE IF (SY = BEGINSY) THEN
  5609   1   20:8   147 		 BEGIN ERROR(13); FINISHSEG; EXIT(BLOCK) END;
  5610   1   20:4   156 	   IF SY = BEGINSY THEN INSYMBOL ELSE ERROR(17);
  5611   1   20:4   169 	   REPEAT 
  5612   1   20:5   169 	     BODYPART(FSYS + [CASESY] - [ENDSY], TOS^.DFPROCP);
  5613   1   20:5   195 	     BFSYFOUND := (SY = TOS^.BFSY) OR (INMODULE AND (SY = ENDSY));
  5614   1   20:5   211 	     IF NOT BFSYFOUND THEN
  5615   1   20:6   215 	       BEGIN 
  5616   1   20:7   215 		 IF TOS^.BFSY = SEMICOLON THEN
  5617   1   20:8   222 		   ERROR(14)  (*SEMICOLON EXPECTED*)
  5618   1   20:7   223 		 ELSE  ERROR(6);  (* PERIOD EXPECTED *)
  5619   1   20:7   230 		 SKIP(FSYS + [TOS^.BFSY]);
  5620   1   20:7   244 		 BFSYFOUND := (SY = TOS^.BFSY) OR (INMODULE AND (SY = ENDSY))
  5621   1   20:6   257 	     END
  5622   1   20:4   260 	   UNTIL (BFSYFOUND) OR (SY IN BLOCKBEGSYS);
  5623   1   20:4   272 	   IF NOT BFSYFOUND THEN
  5624   1   20:5   276 	     BEGIN
  5625   1   20:6   276 	       IF TOS^.BFSY = SEMICOLON THEN ERROR(14)
  5626   1   20:6   284 	       ELSE ERROR(6); (*PERIOD EXPECTED*)
  5627   1   20:6   291 	       DECLARATIONPART(FSYS);
  5628   1   20:5   301 	     END
  5629   1   20:4   301 	   ELSE
  5630   1   20:5   303 	     BEGIN
  5631   1   20:6   303 	       IF SY = SEMICOLON THEN INSYMBOL;
  5632   1   20:6   311 	       IF (NOT(SY IN [BEGINSY,PROCSY,FUNCSY,PROGSY])) AND
  5633   1   20:6   325 		  (TOS^.BFSY = SEMICOLON) THEN
  5634   1   20:7   333 		 IF NOT (INMODULE AND (SY = ENDSY)) THEN
  5635   1   20:8   343 		   BEGIN
  5636   1   20:9   343 		     ERROR(6); SKIP(FSYS);
  5637   1   20:9   355 		     DECLARATIONPART(FSYS);
  5638   1   20:8   365 		   END
  5639   1   20:7   365 		 ELSE GOTO 1
  5640   1   20:6   369 	       ELSE
  5641   1   20:7   371 	 1:      BEGIN
  5642   1   20:8   371 		   WITH TOS^ DO
  5643   1   20:9   375 		     BEGIN
  5644   1   20:0   375 		       IF DFPROCP <> NIL THEN
  5645   1   20:1   381 			 DFPROCP^.INSCOPE:=FALSE;
  5646   1   20:0   387 		       IF ISSEGMENT THEN
  5647   1   20:1   392 			 BEGIN
  5648   1   20:2   392 			   IF CODEINSEG THEN FINISHSEG;
  5649   1   20:2   398 			   IF DLINKERINFO AND (LEVEL = 1) THEN
  5650   1   20:3   407 			     BEGIN SEGTABLE[SEG].SEGKIND := 2;
  5651   1   20:4   417 			       WRITELINKERINFO(TRUE)
  5652   1   20:3   418 			     END
  5653   1   20:2   421 			   ELSE
  5654   1   20:3   423 			     IF CLINKERINFO THEN
  5655   1   20:4   427 			       BEGIN SEGTABLE[SEG].SEGKIND := 2;
  5656   1   20:5   437 				 WRITELINKERINFO(FALSE)
  5657   1   20:4   438 			       END;
  5658   1   20:2   441 			   NEXTPROC:=SOLDPROC;
  5659   1   20:2   445 			   SEG:=DOLDSEG;
  5660   1   20:1   449 			 END;
  5661   1   20:0   449 		       LEVEL:=DOLDLEV;
  5662   1   20:0   453 		       TOP:=DOLDTOP;
  5663   1   20:0   457 		       LC:=DLLC;
  5664   1   20:0   461 		       CURPROC:=POLDPROC;
  5665   1   20:9   465 		     END;
  5666   1   20:8   465 		   RELEASE(TOS^.DMARKP);
  5667   1   20:8   471 		   TOS:=TOS^.PREVLEXSTACKP;
  5668   1   20:8   477 		   NEWBLOCK:=(SY IN [PROCSY,FUNCSY,PROGSY]);
  5669   1   20:7   492 		 END
  5670   1   20:5   492 	     END
  5671   1   20:3   492 	 END
  5672   1   20:2   492        ELSE   
  5673   1   20:3   494 	 BEGIN DECLARATIONPART(FSYS);
  5674   1   20:4   504 	   IF LEVEL = 0 THEN
  5675   1   20:5   510 	     IF SY IN [UNITSY,SEPARATSY] THEN
  5676   1   20:6   526 	       BEGIN
  5677   1   20:7   526 		 UNITPART(FSYS + [UNITSY,INTERSY,IMPLESY,ENDSY]);
  5678   1   20:7   549 		 IF SY IN [PROCSY,FUNCSY,PROGSY] THEN DECLARATIONPART(FSYS)
  5679   1   20:6   571 	       END
  5680   1   20:3   574          END;
  5681   1   20:1   574      UNTIL TOS = NIL;
  5682   1   20:1   580      FINISHSEG;
  5683   1   20:0   582  END (*BLOCK*) ;
  5684   1   20:0   602 
  5685   1    1:0     0 BEGIN (* PASCALCOMPILER *)
  5686   1    1:1     0   COMPINIT;
  5687   1    1:1    55   TIME(LGTH,LOWTIME); 
  5688   1    1:1    61   BLOCK(BLOCKBEGSYS+STATBEGSYS-[CASESY]);
  5689   1    1:1    84   IF SY <> PERIOD THEN ERROR(21);
  5690   1    1:1    93   IF LIST THEN
  5691   1    1:2    97     BEGIN SCREENDOTS := SCREENDOTS+1;
  5692   1    1:3   103       SYMBUFP^[SYMCURSOR] := CHR(EOL);
  5693   1    1:3   107       SYMCURSOR := SYMCURSOR+1;
  5694   1    1:3   112       PRINTLINE
  5695   1    1:2   112     END;
  5696   1    1:1   114   USERINFO.ERRBLK := 0;
  5697   1    1:1   118   TIME(LGTH,STARTDOTS); LOWTIME := STARTDOTS-LOWTIME;
  5698   1    1:1   131   UNITWRITE(3,IC,7);
  5699   1    1:1   140   IF DLINKERINFO OR CLINKERINFO THEN
  5700   1    1:2   147     BEGIN SEGTABLE[SEG].SEGKIND := 1;
  5701   1    1:3   157       WRITELINKERINFO(TRUE)
  5702   1    1:2   158     END;
  5703   1    1:1   161   CLOSE(LP,LOCK);
  5704   1    1:1   168   IF NOISY THEN WRITELN(OUTPUT);
  5705   1    1:1   178   WRITE(OUTPUT,SCREENDOTS,' lines');
  5706   1    1:1   203   IF LOWTIME > 0 THEN
  5707   1    1:2   209     WRITE(OUTPUT,', ',(LOWTIME+30) DIV 60,' secs, ',
  5708   1    1:2   251 	ROUND((3600/LOWTIME)*SCREENDOTS),' lines/min');
  5709   1    1:1   292   IF NOISY THEN
  5710   1    1:2   296     BEGIN
  5711   1    1:3   296       WRITELN(OUTPUT);
  5712   1    1:3   302       WRITE(OUTPUT,'Smallest available space = ',SMALLESTSPACE,' words');
  5713   1    1:2   364     END;
  5714   1    1:1   364   IC := 0;
  5715   1    1:1   367   FOR SEG := 0 TO MAXSEG DO
  5716   1    1:2   381     WITH SEGTABLE[SEG] DO
  5717   1    1:3   390       BEGIN GENWORD(DISKADDR); GENWORD(CODELENG) END;
  5718   1    1:1   409   FOR SEG := 0 TO MAXSEG DO
  5719   1    1:2   423     WITH SEGTABLE[SEG] DO
  5720   1    1:3   432       FOR LGTH := 1 TO 8 DO
  5721   1    1:4   447 	GENBYTE(ORD(SEGNAME[LGTH]));
  5722   1    1:1   474   FOR SEG := 0 TO MAXSEG DO GENWORD(SEGTABLE[SEG].SEGKIND);
  5723   1    1:1   504   FOR SEG := 0 TO MAXSEG DO GENWORD(SEGTABLE[SEG].TEXTADDR);
  5724   1    1:1   534   {.fs} { TODO: The comment is written to the wrong place. }
  5725   1    1:1   534   FOR LGTH := 1 TO 80 DO
  5726   1    1:2   549     IF COMMENT <> NIL THEN GENBYTE(ORD(COMMENT^[LGTH])) ELSE GENBYTE(0);
  5727   1    1:1   577   FOR LGTH := 1 TO 256 - 8*(MAXSEG + 1) - 40 DO GENWORD(0);
  5728   1    1:1   613   CURBLK := 0; CURBYTE := 0; WRITECODE(TRUE)
  5729   1    1:0   622 END (* PASCALCOMPILER *) ;
  5730   1    1:0   678 
  5731   0    1:0     0 BEGIN (* SYSTEM *)
  5732   0    1:0     0 END.
