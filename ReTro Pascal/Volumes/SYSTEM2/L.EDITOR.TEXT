     6   1    1:D     1 {.fs} {$L L.EDITOR.TEXT[*]} { LIST file helps debugging since it has all proc nos etc. }
     7   1    1:D     1 
     8   1    1:D     1 (*$S+*)
     9   1    1:D     1 (**********************************************************************)
    10   1    1:D     1 (*                                                                    *)
    11   1    1:D     1 (*    Screen Oriented Editor               Written: October  11, 1978 *)
    12   1    1:D     1 (*    ------ -------- ------               Update : December 10, 1978 *)
    13   1    1:D     1 (*                                                   _________        *)
    14   1    1:D     1 (*    By Richard S. Kaufmann,                       /         \       *)
    15   1    1:D     1 (*       IIS                                        | Version |       *)
    16   1    1:D     1 (*       University of California, San Diego        |   E.6f  |       *)
    17   1    1:D     1 (*       La Jolla CA 92093                          \_________/       *)
    18   1    1:D     1 (*                                                                    *)
    19   1    1:D     1 (*    Copyright (c) 1978, by The Regents of the University of         *)
    20   1    1:D     1 (*       California at San Diego                                      *)
    21   1    1:D     1 (*                                                                    *)
    22   1    1:D     1 (**********************************************************************)
    23   1    1:D     1 
    24   1    1:D     1 (* --- HEAD --- *)
    25   1    1:D     1 (*$U-*)
    26   0    1:D     1 CONST
    27   0    1:D     1   VIDLENG = 7;  (* Number of characters in a volume ID *)
    28   0    1:D     1   TIDLENG = 15;	(* Number of characters in a title ID *)
    29   0    1:D     1 
    30   0    1:D     1 TYPE
    31   0    1:D     1 
    32   0    1:D     1   DATEREC=PACKED RECORD
    33   0    1:D     1 	    MONTH: 0..12;
    34   0    1:D     1 	    DAY:   0..31;
    35   0    1:D     1 	    YEAR:  0..100
    36   0    1:D     1 	  END;
    37   0    1:D     1 
    38   0    1:D     1   VID = STRING[VIDLENG];
    39   0    1:D     1 
    40   0    1:D     1   TID = STRING[TIDLENG];
    41   0    1:D     1 
    42   0    1:D     1   INFOREC = RECORD
    43   0    1:D     1 	      TRASH1,TRASH2: INTEGER;
    44   0    1:D     1 	      ERRSYM,ERRBLK,ERRNUM: INTEGER;    (* Error com for EDIT *)
    45   0    1:D     1 	      TRASH3: ARRAY [0..2] OF INTEGER;
    46   0    1:D     1 	      GOTSYM,GOTCODE: BOOLEAN;
    47   0    1:D     1 	      WORKVID,SYMVID,CODEVID: VID;      (* Perm&Cur workfile volumes *)
    48   0    1:D     1 	      WORKTID,SYMTID,CODETID: TID       (* Perm&Cur workfile titles *)
    49   0    1:D     1 	    END (*INFOREC*) ;
    50   0    1:D     1 
    51   0    1:D     1   SYSCOMREC = RECORD
    52   0    1:D     1 		JUNK: ARRAY [0..6] OF INTEGER;
    53   0    1:D     1 		LASTMP: INTEGER;
    54   0    1:D     1 		EXPANSION: ARRAY [0..20] OF INTEGER;
    55   0    1:D     1 		MISCINFO: PACKED RECORD
    56   0    1:D     1 			    NOBREAK,STUPID,SLOWTERM,
    57   0    1:D     1 			    HASXYCRT,HASLCCRT,HAS8510A,HASCLOCK: BOOLEAN
    58   0    1:D     1 			  END;
    59   0    1:D     1 		CRTTYPE: INTEGER;
    60   0    1:D     1 		CRTCTRL: PACKED RECORD
    61   0    1:D     1 			   RLF,NDFS,ERASEEOL,ERASEEOS,HOME,ESCAPE: CHAR;
    62   0    1:D     1 			   BACKSPACE: CHAR;
    63   0    1:D     1 			   FILLCOUNT: 0..255;
    64   0    1:D     1 			   CLEARSCREEN,CLEARLINE: CHAR;
    65   0    1:D     1 			   PREFIXED: PACKED ARRAY [0..8] OF BOOLEAN
    66   0    1:D     1 			 END;
    67   0    1:D     1 		CRTINFO: PACKED RECORD
    68   0    1:D     1 			   WIDTH,HEIGHT: INTEGER;
    69   0    1:D     1 			   RIGHT,LEFT,DOWN,UP: CHAR;
    70   0    1:D     1 			   BADCH,CHARDEL,STOP,BREAK,FLUSH,EOF: CHAR;
    71   0    1:D     1 			   ALTMODE,LINEDEL: CHAR;
    72   0    1:D     1 			   BACKSPACE,ETX,PREFIX: CHAR;
    73   0    1:D     1 			   PREFIXED: PACKED ARRAY [0..13] OF BOOLEAN;
    74   0    1:D     1 			 END
    75   0    1:D     1 	      END (*SYSCOM*);
    76   0    1:D     1 
    77   0    1:D     1 VAR (* I.4 Globals as of 30-Jan-78 *)
    78   0    1:D     1   SYSCOM: ^SYSCOMREC;
    79   0    1:D     2   TRASHY: ARRAY [0..5] OF INTEGER;
    80   0    1:D     8   USERINFO: INFOREC;
    81   0    1:D    54   TRASHYY: ARRAY [0..4] OF INTEGER;
    82   0    1:D    59   SYVID,DKVID: VID;
    83   0    1:D    67   THEDATE: DATEREC;
    84   0    1:D    68 
    85   0    1:D    68 
    86   1    1:D     1 SEGMENT PROCEDURE EDITOR(XXX,YYY: INTEGER); 
    87   1    1:D     3 CONST
    88   1    1:D     3   (* Unless otherwise noted all constants are upper bounds
    89   1    1:D     3      from zero.					        *)
    90   1    1:D     3 
    91   1    1:D     3   MAXBUFSIZE=32767;
    92   1    1:D     3   MAXSW=84; (* Maximum allowable SCREENWIDTH *)
    93   1    1:D     3   MAXSTRING=127;
    94   1    1:D     3   MAXCHAR=1023;  (* The maximum number of characters on a line in the EBUF *)
    95   1    1:D     3   TIDLENG=15;  (* From SYSCOM *)
    96   1    1:D     3   CHARINBUF=2048;  (* For final version. Not used. *)
    97   1    1:D     3   MAXOFFSET=1023; (* Maximum offset in a page *)
    98   1    1:D     3   MAXPAGE=255; (* Ridiculous upper bound! *)
    99   1    1:D     3 
   100   1    1:D     3   (* The following ASCII characters are hard-wired in *)
   101   1    1:D     3   HT=9; LF=10; EOL=13; DLE=16; SP=32;
   102   1    1:D     3   DC1=17; BELL=7; RUBOUT=127; CR=13;
   103   1    1:D     3 
   104   1    1:D     3 
   105   1    1:D     3 TYPE
   106   1    1:D     3   PTRTYPE=0..MAXBUFSIZE;
   107   1    1:D     3   BUFRTYPE=PACKED ARRAY [0..0] OF CHAR;
   108   1    1:D     3   BLOCKTYPE=PACKED ARRAY [0..511] OF CHAR;
   109   1    1:D     3   ERRORTYPE=(FATAL,NONFATAL);
   110   1    1:D     3   OFFSET=0..MAXOFFSET;
   111   1    1:D     3   PAGE=0..MAXPAGE;
   112   1    1:D     3   NAME=PACKED ARRAY [0..7] OF CHAR;
   113   1    1:D     3   PTYPE=PACKED ARRAY [0..MAXSTRING] OF CHAR;
   114   1    1:D     3   COMMANDS=(ILLEGAL,ADJUSTC,COPYC,DELETEC,FINDC,INSERTC,JUMPC,LISTC,MACRODEFC,
   115   1    1:D     3 	    PARAC,QUITC,REPLACEC,SETC,VERIFYC,XECUTEC,ZAPC,REVERSEC,FORWARDC,UP,
   116   1    1:D     3 	    DOWN,LEFT,RIGHT,TAB,DIGIT,DUMPC,ADVANCE,SPACE,EQUALC,SLASHC);
   117   1    1:D     3   CTYPE=(FS,GOHOME,ETOEOL,ETOEOS,US);
   118   1    1:D     3   SCREENCOMMAND=(WHOME,ERASEEOS,ERASEEOL,CLEARLNE,CLEARSCN,UPCURSOR,
   119   1    1:D     3 		 DOWNCURSOR,LEFTCURSOR,RIGHTCURSOR);
   120   1    1:D     3   KEYCOMMAND=   (BACKSPACEKEY,DC1KEY,EOFKEY,ETXKEY,ESCAPEKEY,DELKEY,UPKEY,
   121   1    1:D     3 		 DOWNKEY,LEFTKEY,RIGHTKEY,NOTLEGAL);
   122   1    1:D     3 
   123   1    1:D     3   HEADER=    (* Page Zero layout changed 22-JUN-78 *)
   124   1    1:D     3     RECORD CASE BOOLEAN OF
   125   1    1:D     3       TRUE: (BUF: PACKED ARRAY[0..MAXOFFSET] OF CHAR);
   126   1    1:D     3       FALSE:(DEFINED:    BOOLEAN; (* New file nulls => false *)
   127   1    1:D     3 	     COUNT:      INTEGER;  (* The count of valid markers *)
   128   1    1:D     3 	     NAME:       ARRAY [0..9] OF PACKED ARRAY [0..7] OF CHAR;
   129   1    1:D     3 	     PAGEN:      PACKED ARRAY [0..9] OF PAGE;
   130   1    1:D     3 	     POFFSET:    PACKED ARRAY [0..9] OF OFFSET;
   131   1    1:D     3 	     AUTOINDENT: BOOLEAN; (* Environment stuff follows *)
   132   1    1:D     3 	     FILLING:    BOOLEAN;
   133   1    1:D     3 	     TOKDEF:     BOOLEAN;
   134   1    1:D     3 	     LMARGIN:    0..MAXSW;
   135   1    1:D     3 	     RMARGIN:    0..MAXSW;
   136   1    1:D     3 	     PARAMARGIN: 0..MAXSW;
   137   1    1:D     3 	     RUNOFFCH:   CHAR;
   138   1    1:D     3 	     CREATED:    DATEREC;
   139   1    1:D     3 	     LASTUSED:   DATEREC;
   140   1    1:D     3 	     FILLER:     PACKED ARRAY [0..891] OF CHAR)
   141   1    1:D     3     END;
   142   1    1:D     3 
   143   1    1:D     3 
   144   1    1:D     3 
   145   1    1:D     3 VAR
   146   1    1:D     3   CURSOR: 0..MAXBUFSIZE;
   147   1    1:D     4   BUFCOUNT: 0..MAXBUFSIZE;       (* Number of valid characters in the EBUF *)
   148   1    1:D     5   STUFFSTART: 0..MAXBUFSIZE;     (* GETLEADING            *)
   149   1    1:D     6   LINESTART: 0..MAXBUFSIZE;      (*            sets       *)
   150   1    1:D     7   BYTES,BLANKS: INTEGER;         (*                 these *)
   151   1    1:D     9   CH: CHAR;
   152   1    1:D    10   DIRECTION: CHAR;               (* '>' or '<' *)
   153   1    1:D    11   REPEATFACTOR: INTEGER;
   154   1    1:D    12   BUFSIZE: INTEGER;
   155   1    1:D    13   SCREENWIDTH: INTEGER;          (* Moved to var 26-Jan *)
   156   1    1:D    14   SCREENHEIGHT: INTEGER;         (*   "    "  "    "    *)
   157   1    1:D    15   COMMAND: COMMANDS;
   158   1    1:D    16   LASTPAT: 0..MAXBUFSIZE;
   159   1    1:D    17   EBUF: ^BUFRTYPE;
   160   1    1:D    18   FILLIT: STRING[11];
   161   1    1:D    24   KIND: ARRAY [CHAR] OF INTEGER; (* for token find *)
   162   1    1:D   280   LINE1PTR: 0..MAXBUFSIZE;
   163   1    1:D   281   MIDDLE: INTEGER;               (* Middle line on the screen *)
   164   1    1:D   282   NEEDPROMPT: BOOLEAN;
   165   1    1:D   283   ETX,BS,DEL,ESC,BSPCE: INTEGER;  (* Moved from CONST 30-Jan-78 BSPCE: 11/2/78*)
   166   1    1:D   288   ADJUSTPROMPT,INSERTPROMPT,DELETEPROMPT,COMPROMPT: STRING; 
   167   1    1:D   452   {Promptline  11/2/78 M. Bernard}
   168   1    1:D   452   TRASH: INTEGER;                (* Totally without redeeming social value *)
   169   1    1:D   453   TARGET: PTYPE;
   170   1    1:D   517   SUBSTRING: PTYPE;
   171   1    1:D   581   SLENGTH,TLENGTH: INTEGER;      (* Length of target and substring *)
   172   1    1:D   583   SDEFINED,TDEFINED: BOOLEAN;    (* Whether the strings are valid *)
   173   1    1:D   585   COPYLENGTH,COPYSTART: PTRTYPE; (* For Copyc *)
   174   1    1:D   587   COPYLINE,COPYOK: BOOLEAN;      (*    "      *)
   175   1    1:D   589   INFINITY: BOOLEAN;             (* for slashc *)
   176   1    1:D   590   THEFILE: FILE;
   177   1    1:D   630   TRANSLATE: ARRAY [CHAR] OF COMMANDS;
   178   1    1:D   886   PAGEZERO: HEADER;
   179   1    1:D  1398   MSG: STRING;
   180   1    1:D  1439   PROMPTLINE: STRING;
   181   1    1:D  1480   BLANKAREA: ARRAY [0..MAXSW] OF CHAR;
   182   1    1:D  1565   SAVETOP: STRING;               (* Dumb terminal patch - for BLANKCRT(1) *)
   183   1    1:D  1606   SCREEN: PACKED RECORD (* Screen Control Record *)
   184   1    1:D  1606 	    PREFIX: CHAR;
   185   1    1:D  1606 {.fs#	    HEIGHT,WIDTH: 0..255; }  { unused; using SCREENWIDTH/HEIGHT instead }
   186   1    1:D  1606 	    CANUPSCROLL,CANDOWNSCROLL,SLOW: BOOLEAN;
   187   1    1:D  1606 	    HASPREFIX: PACKED ARRAY [SCREENCOMMAND] OF BOOLEAN;
   188   1    1:D  1606 	    CH:        PACKED ARRAY [SCREENCOMMAND] OF CHAR
   189   1    1:D  1606 	  END;
   190   1    1:D  1613   KEYBRD: PACKED RECORD (* Keyboard Control Record *)
   191   1    1:D  1613 	    PREFIX: CHAR;
   192   1    1:D  1613 	    HASPREFIX: PACKED ARRAY [KEYCOMMAND] OF BOOLEAN;
   193   1    1:D  1613 	    CH:        PACKED ARRAY [KEYCOMMAND] OF CHAR
   194   1    1:D  1613 	  END;
   195   1    1:D  1621 
   196   3    1:0     0 SEGMENT PROCEDURE NUM2; BEGIN END;      SEGMENT PROCEDURE NUM3; BEGIN END;
   197   5    1:0     0 SEGMENT PROCEDURE NUM4; BEGIN END;      SEGMENT PROCEDURE NUM5; BEGIN END;
   198   7    1:0     0 SEGMENT PROCEDURE NUM6; BEGIN END;      SEGMENT PROCEDURE NUM7; BEGIN END;
   199   9    1:0     0 SEGMENT PROCEDURE NUM8; BEGIN END;      SEGMENT PROCEDURE NUM9; BEGIN END;
   200   9    1:0    12 
   201   9    1:0    12 (* Forward declared procedures.. all procedures are in MISC and UTIL *)
   202   9    1:0    12 
   203   1    2:D     1 PROCEDURE ERROR(S:STRING;HOWBAD:ERRORTYPE); FORWARD;
   204   1    3:D     1 PROCEDURE ERASETOEOL(X,LINE:INTEGER); FORWARD;
   205   1    4:D     3 FUNCTION  GETCH:CHAR; FORWARD;
   206   1    5:D     1 PROCEDURE CLEARSCREEN; FORWARD;
   207   1    6:D     1 PROCEDURE ERASEOS(X,LINE:INTEGER); FORWARD;
   208   1    7:D     1 PROCEDURE CLEARLINE(Y:INTEGER); FORWARD;
   209   1    8:D     3 FUNCTION  MAPTOCOMMAND(CH:CHAR): COMMANDS; FORWARD;
   210   1    9:D     3 FUNCTION  UCLC(CH:CHAR): CHAR; FORWARD;
   211   1   10:D     1 PROCEDURE PROMPT; FORWARD;
   212   1   11:D     1 PROCEDURE REDISPLAY; FORWARD;
   213   1   12:D     3 FUNCTION  MIN(A,B:INTEGER): INTEGER; FORWARD;
   214   1   13:D     3 FUNCTION  MAX(A,B:INTEGER): INTEGER; FORWARD;
   215   1   14:D     3 FUNCTION  SCREENHAS(WHAT: SCREENCOMMAND): BOOLEAN; FORWARD;
   216   1   15:D     3 FUNCTION  HASKEY(WHAT: KEYCOMMAND): BOOLEAN; FORWARD;
   217   1   16:D     1 PROCEDURE CONTROL(WHAT: SCREENCOMMAND); FORWARD;
   218   1   17:D     1 PROCEDURE PUTMSG; FORWARD;
   219   1   18:D     1 PROCEDURE HOME; FORWARD;
   220   1   19:D     1 PROCEDURE ERRWAIT; FORWARD;
   221   1   20:D     1 PROCEDURE BLANKCRT(Y: INTEGER); FORWARD;
   222   1   21:D     3 FUNCTION  LEADBLANKS(PTR:PTRTYPE;VAR BYTES: INTEGER): INTEGER; FORWARD;
   223   1   22:D     1 PROCEDURE CENTERCURSOR(VAR LINE: INTEGER; LINESUP: INTEGER; NEWSCREEN:BOOLEAN);
   224   1   22:D     4   FORWARD;
   225   1   23:D     1 PROCEDURE FINDXY(VAR INDENT,LINE: INTEGER); FORWARD;
   226   1   24:D     1 PROCEDURE SHOWCURSOR; FORWARD;
   227   1   25:D     3 FUNCTION  GETNUM: INTEGER; FORWARD;
   228   1   26:D     1 PROCEDURE GETLEADING; FORWARD;
   229   1   27:D     3 FUNCTION  OKTODEL(CURSOR,ANCHOR:PTRTYPE):BOOLEAN; FORWARD;
   230   1   28:D     1 PROCEDURE LINEOUT(VAR PTR:PTRTYPE; BYTES,BLANKS,LINE: INTEGER); FORWARD;
   231   1   29:D     1 PROCEDURE UPSCREEN(FIRSTLINE,WHOLESCREEN:BOOLEAN; LINE: INTEGER); FORWARD;
   232   1   30:D     1 PROCEDURE READJUST(CURSOR: PTRTYPE; DELTA: INTEGER); FORWARD;
   233   1   31:D     1 PROCEDURE THEFIXER(PARAPTR: PTRTYPE;RFAC: INTEGER;WHOLE: BOOLEAN); FORWARD;
   234   1   32:D     1 PROCEDURE GETNAME(MSG:STRING; VAR M:NAME); FORWARD;
   235   1   32:D    44 
   236   1   32:D    44 (* --- INIT      --- *)
   237  10    1:D     1 SEGMENT PROCEDURE INITIALIZE;
   238  10    1:D     1 LABEL 1;
   239  10    1:D     1 VAR 
   240  10    1:D     1   BLOCK: ^BLOCKTYPE;
   241  10    1:D     2   ONEWD: ^INTEGER;
   242  10    1:D     3   DONE,OVFLW: BOOLEAN;
   243  10    1:D     5   CH: CHAR;
   244  10    1:D     6   I,QUIT,GAP,BLKS,PAGE,NOTNULS: INTEGER;
   245  10    1:D    12   FILENAME: STRING;
   246  10    1:D    53   BUFFER: PACKED ARRAY [0..1023] OF CHAR;
   247  10    1:D   565 
   248  10    2:D     1 PROCEDURE MAP(CH:CHAR; C:COMMANDS);
   249  10    2:0     0 BEGIN
   250  10    2:1     0   TRANSLATE[CH]:=C;
   251  10    2:1     8   IF CH IN ['A'..'Z'] THEN TRANSLATE[CHR(32+ORD(CH))]:=C; (* LC TOO *)
   252  10    2:0    38 END;
   253  10    2:0    50 
   254  10    3:D     1 PROCEDURE DEFPROMPTS; (* DEFINES VARIABLE PROMPTLINES MAB 11/2/78*)
   255  10    3:0     0 BEGIN
   256  10    3:1     0   COMPROMPT:=
   257  10    3:1     3 ' Edit: A(djst C(py D(lete F(ind I(nsrt J(mp R(place Q(uit X(chng Z(ap  [E.6f]';
   258  10    3:1    85   INSERTPROMPT:=
   259  10    3:1    88   ' Insert: Text {<bs> a char,<del> a line}  [<etx> accepts, <esc> escapes]';
   260  10    3:1   165   DELETEPROMPT:=
   261  10    3:1   168   ' Delete: < > <Moving commmands> {<etx> to delete, <esc> to abort}';
   262  10    3:1   238   ADJUSTPROMPT:=
   263  10    3:1   241   ' Adjust: L(just R(just C(enter <left,right,up,down-arrows> {<etx> to leave}';
   264  10    3:1   321   IF (SCREENWIDTH+1)<LENGTH(COMPROMPT) THEN
   265  10    3:2   332   BEGIN
   266  10    3:3   332     INSERTPROMPT:=' Insrt: {<bs>,<del>} [<etx> accepts, <esc> aborts]';
   267  10    3:3   390     DELETEPROMPT:=' Delete: <vector keys> {<etx> deletes, <esc> aborts}';
   268  10    3:3   450     ADJUSTPROMPT:=' Adjst: L(ft R(ght C(ntr <vector keys> <etx> to leave';
   269  10    3:3   511     COMPROMPT:=' Edit: A, C, D, F, I, J, R, Q, X, Z  [E.6f]';
   270  10    3:2   562   END;
   271  10    3:0   562 END;
   272  10    3:0   576 
   273  10    4:D     1 PROCEDURE READFILE;
   274  10    4:0     0 BEGIN
   275  10    4:1     0   CLEARSCREEN;          (* Dumb terminal patch *)
   276  10    4:1     3   WRITELN('>Edit:');
   277  10    4:1    25   WRITE('Reading');
   278  10    4:1    42   IF BLOCKREAD(THEFILE,PAGEZERO,2)<>2 THEN ERROR('Reading file',FATAL);
   279  10    4:1    83   WRITE('.');
   280  10    4:1    91   PAGE:=1;
   281  10    4:1    95   DONE:=FALSE; OVFLW:=FALSE;
   282  10    4:1   103   WITH USERINFO DO
   283  10    4:2   103     WHILE NOT (DONE OR OVFLW) DO
   284  10    4:3   113       BEGIN
   285  10    4:4   113 	DONE:= BLOCKREAD(THEFILE,BUFFER,2)=0;
   286  10    4:4   136 	IF NOT DONE THEN
   287  10    4:5   142 	  BEGIN
   288  10    4:6   142 	    WRITE('.');
   289  10    4:6   150 	    NOTNULS:=SCAN(-1024,<>CHR(0),BUFFER[1023])+1024;
   290  10    4:6   172 {.fs#       OVFLW:=NOTNULS+BUFCOUNT>=BUFSIZE-10; }          { INTEGER overflow! }
   291  10    4:6   172 	    OVFLW:=BUFCOUNT>=BUFSIZE-NOTNULS-10;
   292  10    4:6   184 	    IF OVFLW THEN NOTNULS:=0;
   293  10    4:6   193 	    MOVELEFT(BUFFER[0],EBUF^[BUFCOUNT],NOTNULS);
   294  10    4:6   205 	    IF PAGE+PAGE=ERRBLK THEN CURSOR:=BUFCOUNT+ERRSYM; (* errblk>0 only *)
   295  10    4:6   225 	    BUFCOUNT:=BUFCOUNT+NOTNULS;
   296  10    4:6   232 	    PAGE:=PAGE+1;
   297  10    4:5   240 	  END;
   298  10    4:3   240       END;
   299  10    4:1   242   IF IORESULT<>0 THEN ERROR('Disk error',NONFATAL) ELSE
   300  10    4:2   267     IF NOT DONE THEN ERROR('Buffer overflow.',NONFATAL);
   301  10    4:0   296 END;
   302  10    4:0   312 
   303  10    5:D     1 PROCEDURE LOADFROMSYSCOM;
   304  10    5:D     1 (* A rather perverted procedure that takes the syscom^.crtcntrl record
   305  10    5:D     1    and loads it into the Screen Control Record and the syscom^.crtinfo
   306  10    5:D     1    record and loads it into the Keyboard Control Record *)
   307  10    5:0     0 BEGIN
   308  10    5:0     0 
   309  10    5:1     0   WITH SYSCOM^ DO
   310  10    5:2     5     BEGIN
   311  10    5:2     5 
   312  10    5:2     5       (* Miscellaneous stuff *)
   313  10    5:2     5 
   314  10    5:3     5       WITH SCREEN DO
   315  10    5:4     5 	BEGIN
   316  10    5:5     5 	  PREFIX:=CRTCTRL.ESCAPE;
   317  10    5:5    17 {.fs#	  HEIGHT:=CRTINFO.HEIGHT-1; } { unused; using SCREENHEIGHT instead }
   318  10    5:5    17 {.fs#	  WIDTH:=CRTINFO.WIDTH-1;   } { unused; using SCREENWIDTH instead }
   319  10    5:5    17 	  CANUPSCROLL:=TRUE; CANDOWNSCROLL:=FALSE;
   320  10    5:4    31         END;
   321  10    5:4    31 
   322  10    5:3    31       KEYBRD.PREFIX:=CRTINFO.PREFIX;
   323  10    5:3    40 
   324  10    5:3    40       (* The screen ... *)
   325  10    5:3    40 
   326  10    5:3    40       SCREEN.CH[WHOME]:=CRTCTRL.HOME;            
   327  10    5:3    51       SCREEN.HASPREFIX[WHOME]:=CRTCTRL.PREFIXED[4];
   328  10    5:3    67 
   329  10    5:3    67       SCREEN.CH[ERASEEOS]:=CRTCTRL.ERASEEOS;
   330  10    5:3    78       SCREEN.HASPREFIX[ERASEEOS]:=CRTCTRL.PREFIXED[3];
   331  10    5:3    94 
   332  10    5:3    94       SCREEN.CH[ERASEEOL]:=CRTCTRL.ERASEEOL;
   333  10    5:3   105       SCREEN.HASPREFIX[ERASEEOL]:=CRTCTRL.PREFIXED[2];
   334  10    5:3   121 
   335  10    5:3   121       SCREEN.CH[CLEARLNE]:=CRTCTRL.CLEARLINE;
   336  10    5:3   132       SCREEN.HASPREFIX[CLEARLNE]:=CRTCTRL.PREFIXED[7];
   337  10    5:3   148 
   338  10    5:3   148       SCREEN.CH[CLEARSCN]:=CRTCTRL.CLEARSCREEN;
   339  10    5:3   159       SCREEN.HASPREFIX[CLEARSCN]:=CRTCTRL.PREFIXED[6];
   340  10    5:3   175 
   341  10    5:3   175       SCREEN.CH[UPCURSOR]:=CRTCTRL.RLF;
   342  10    5:3   186       SCREEN.HASPREFIX[UPCURSOR]:=CRTCTRL.PREFIXED[0];
   343  10    5:3   202 
   344  10    5:3   202       SCREEN.CH[DOWNCURSOR]:=CHR(LF);
   345  10    5:3   208       SCREEN.HASPREFIX[DOWNCURSOR]:=FALSE;
   346  10    5:3   217 
   347  10    5:3   217       SCREEN.CH[LEFTCURSOR]:=CRTCTRL.BACKSPACE;
   348  10    5:3   228       SCREEN.HASPREFIX[LEFTCURSOR]:=CRTCTRL.PREFIXED[1];
   349  10    5:3   244 
   350  10    5:3   244       SCREEN.CH[RIGHTCURSOR]:=CRTCTRL.NDFS;
   351  10    5:3   255       SCREEN.HASPREFIX[RIGHTCURSOR]:=CRTCTRL.PREFIXED[8];
   352  10    5:3   271 
   353  10    5:3   271       (* ... and the keyboard *)
   354  10    5:3   271 
   355  10    5:3   271       KEYBRD.CH[BACKSPACEKEY]:=CRTINFO.BACKSPACE;
   356  10    5:3   279       KEYBRD.HASPREFIX[BACKSPACEKEY]:=CRTINFO.PREFIXED[12];
   357  10    5:3   295 
   358  10    5:3   295       KEYBRD.CH[DC1KEY]:=CHR(DC1); (* Not in record *)
   359  10    5:3   301       KEYBRD.HASPREFIX[DC1KEY]:=FALSE;
   360  10    5:3   310 
   361  10    5:3   310       KEYBRD.CH[EOFKEY]:=CRTINFO.EOF;
   362  10    5:3   321       KEYBRD.HASPREFIX[EOFKEY]:=CRTINFO.PREFIXED[9];
   363  10    5:3   337 
   364  10    5:3   337       KEYBRD.CH[ETXKEY]:=CRTINFO.ETX;
   365  10    5:3   348       KEYBRD.HASPREFIX[ETXKEY]:=CRTINFO.PREFIXED[13];
   366  10    5:3   364 
   367  10    5:3   364       KEYBRD.CH[ESCAPEKEY]:=CRTINFO.ALTMODE;
   368  10    5:3   375       KEYBRD.HASPREFIX[ESCAPEKEY]:=CRTINFO.PREFIXED[10];
   369  10    5:3   391 
   370  10    5:3   391       KEYBRD.CH[DELKEY]:=CRTINFO.LINEDEL;
   371  10    5:3   402       KEYBRD.HASPREFIX[DELKEY]:=CRTINFO.PREFIXED[11];
   372  10    5:3   418 
   373  10    5:3   418       KEYBRD.CH[UPKEY]:=CRTINFO.UP;
   374  10    5:3   429       KEYBRD.HASPREFIX[UPKEY]:=CRTINFO.PREFIXED[3];
   375  10    5:3   445 
   376  10    5:3   445       KEYBRD.CH[DOWNKEY]:=CRTINFO.DOWN;
   377  10    5:3   456       KEYBRD.HASPREFIX[DOWNKEY]:=CRTINFO.PREFIXED[2];
   378  10    5:3   472 
   379  10    5:3   472       KEYBRD.CH[LEFTKEY]:=CRTINFO.LEFT;
   380  10    5:3   483       KEYBRD.HASPREFIX[LEFTKEY]:=CRTINFO.PREFIXED[1];
   381  10    5:3   499 
   382  10    5:3   499       KEYBRD.CH[RIGHTKEY]:=CRTINFO.RIGHT;
   383  10    5:3   510       KEYBRD.HASPREFIX[RIGHTKEY]:=CRTINFO.PREFIXED[0];
   384  10    5:3   526 
   385  10    5:3   526       BSPCE:=ORD(CRTINFO.BACKSPACE);  {Went soft 11/2/78 M. Bernard}
   386  10    5:3   532 
   387  10    5:3   532       {Now test to see that the essential keys have been given a
   388  10    5:3   532        value other than null.  If not then assign them a default
   389  10    5:3   532        value.  Hopefully, this will end up an INTERP change--M. Bernard}
   390  10    5:3   532 
   391  10    5:3   532        IF BSPCE=0 THEN BSPCE:=8;
   392  10    5:3   543        IF KEYBRD.CH[ETXKEY]=CHR(0) THEN KEYBRD.CH[ETXKEY]:=CHR(3);
   393  10    5:3   558 
   394  10    5:3   558 
   395  10    5:2   558     END;
   396  10    5:0   558 END;
   397  10    5:0   570 
   398  10    6:D     1 PROCEDURE MAPSPECIAL(K:KEYCOMMANDS;C:COMMANDS);
   399  10    6:0     0 BEGIN
   400  10    6:1     0   IF NOT KEYBRD.HASPREFIX[K] THEN MAP(KEYBRD.CH[K],C);
   401  10    6:0    19 END;
   402  10    6:0    32 
   403  10    1:0     0 BEGIN
   404  10    1:1     0   WITH PAGEZERO DO
   405  10    1:2     0     BEGIN
   406  10    1:2     0 
   407  10    1:2     0       (* Load Screen and Keyboard Control Records from SYSCOM *)
   408  10    1:2     0 
   409  10    1:3     0       LOADFROMSYSCOM;
   410  10    1:3     2 
   411  10    1:3     2 
   412  10    1:3     2       (* Init the translate table *)
   413  10    1:3     2 
   414  10    1:3     2       FILLCHAR(TRANSLATE,SIZEOF(TRANSLATE),ILLEGAL);
   415  10    1:3    12       MAP('A',ADJUSTC);   MAP('C',COPYC);     MAP('D',DELETEC);
   416  10    1:3    24       MAP('F',FINDC);     MAP('I',INSERTC);   MAP('J',JUMPC);
   417  10    1:3    36       MAP('L',LISTC);     MAP('M',MACRODEFC); MAP('P',PARAC);
   418  10    1:3    48       MAP('Q',QUITC);     MAP('R',REPLACEC);  MAP('S',SETC);
   419  10    1:3    60       MAP('V',VERIFYC);   MAP('X',XECUTEC);   MAP('Z',ZAPC);
   420  10    1:3    72       MAP(',',REVERSEC);  MAP('>',FORWARDC);  MAP('.',FORWARDC);
   421  10    1:3    84       MAP('+',FORWARDC);  MAP('-',REVERSEC);  MAP('?',DUMPC);
   422  10    1:3    96       MAP('/',SLASHC);    MAP('=',EQUALC);    MAP('<',REVERSEC);
   423  10    1:3   108 
   424  10    1:3   108 
   425  10    1:3   108       (* Arrows *)
   426  10    1:3   108 
   427  10    1:3   108       (* NEXTCOMMAND and GETNUM handle VT-52 style vector keys *)
   428  10    1:3   108       WITH KEYBRD DO
   429  10    1:4   108 	BEGIN
   430  10    1:5   108 	  MAPSPECIAL(UPKEY,UP); MAPSPECIAL(DOWNKEY,DOWN);
   431  10    1:5   116 	  MAPSPECIAL(LEFTKEY,LEFT); MAPSPECIAL(RIGHTKEY,RIGHT);
   432  10    1:4   124 	END;
   433  10    1:3   124       MAP(CHR(EOL),ADVANCE); (* CR IS ADVANCE *)
   434  10    1:3   128       MAP(CHR(HT),TAB);
   435  10    1:3   132       MAP(CHR(SP),SPACE);
   436  10    1:3   136 
   437  10    1:3   136 
   438  10    1:3   136       (* Digits *)
   439  10    1:3   136 
   440  10    1:3   136       FOR CH:='0' TO '9' DO MAP(CH,DIGIT);
   441  10    1:3   161 
   442  10    1:3   161 
   443  10    1:3   161       (* Variable buffer sizing... added 17-Jan-78 *)
   444  10    1:3   161 
   445  10    1:3   161       QUIT:=10512+       (* Sizeof(editcore)-Sizeof(initialize) *)
   446  10    1:3   164 	    512;        (* Slop! *)
   447  10    1:3   170       MARK(EBUF);
   448  10    1:3   174       BLKS:=0;
   449  10    1:3   177       REPEAT
   450  10    1:4   177 	NEW(BLOCK);
   451  10    1:4   184 	BLKS:=BLKS+1;
   452  10    1:4   189 	GAP:=MEMAVAIL+MEMAVAIL
   453  10    1:3   191       UNTIL ((GAP>0) AND (GAP<QUIT)) OR (BLKS=63);
   454  10    1:3   209       BUFSIZE:=BLKS*512-1;
   455  10    1:3   218       NEW(ONEWD); ONEWD^:=0;  (* Sentinel for end of buffer - for M(unch *)
   456  10    1:3   226 
   457  10    1:3   226 
   458  10    1:3   226       (* Open the workfile *)
   459  10    1:3   226       
   460  10    1:3   226       (*Init FILLIT for writing nulls in front of all control ch's*)
   461  10    1:3   226       FILLCHAR(FILLIT,SIZEOF(FILLIT),0);
   462  10    1:3   233       IF SYSCOM^.CRTCTRL.FILLCOUNT<=11 THEN
   463  10    1:4   245 	FILLIT[0]:=CHR(SYSCOM^.CRTCTRL.FILLCOUNT)
   464  10    1:3   256       ELSE
   465  10    1:4   259 	FILLIT[0]:=CHR(11);
   466  10    1:3   264       FILLCHAR(EBUF^,BUFSIZE+1,CHR(0));
   467  10    1:3   273       EBUF^[0]:=CHR(EOL);
   468  10    1:3   278       BUFCOUNT:=1;
   469  10    1:3   281       CURSOR:=1;
   470  10    1:3   284       CLEARSCREEN;
   471  10    1:3   287       WRITELN('>Edit:');
   472  10    1:3   309       IF USERINFO.GOTSYM THEN
   473  10    1:4   314 	BEGIN
   474  10    1:5   314 	  RESET(THEFILE,CONCAT(USERINFO.SYMVID,':',USERINFO.SYMTID));
   475  10    1:5   360 	  IF IORESULT<>0 THEN ERROR('Workfile lost.',FATAL)
   476  10    1:4   384 	END
   477  10    1:3   387       ELSE
   478  10    1:4   389 	BEGIN
   479  10    1:5   389 	  MSG:=
   480  10    1:5   392        'No workfile is present. File? ( <ret> for no file <esc-ret> to exit ) ';
   481  10    1:5   467 	  REPEAT
   482  10    1:6   467 	    WRITELN(MSG);
   483  10    1:6   483 	    WRITE(': ');
   484  10    1:6   495 	    READLN(INPUT,FILENAME);
   485  10    1:6   510 	    IF LENGTH(FILENAME)=0 THEN
   486  10    1:7   518 	      BEGIN
   487  10    1:8   518 		FILLCHAR(PAGEZERO,SIZEOF(PAGEZERO),CHR(0)); GOTO 1;
   488  10    1:7   530 	      END;
   489  10    1:6   530 	    IF FILENAME[1]=SYSCOM^.CRTINFO.ALTMODE THEN EXIT(EDITOR);
   490  10    1:6   549 	    { To escape if entered by accident. MAB 12/8/78 }
   491  10    1:6   549 	    FOR I:=1 TO LENGTH(FILENAME) DO FILENAME[I]:=UCLC(FILENAME[I]);
   492  10    1:6   586 	    IF ((POS('.TEXT',FILENAME)<>LENGTH(FILENAME)-4) OR
   493  10    1:6   608 	       (LENGTH(FILENAME)<=4)) AND (FILENAME[LENGTH(FILENAME)]<>'.') THEN
   494  10    1:7   627 	      FILENAME:=CONCAT(FILENAME,'.TEXT');
   495  10    1:6   662 	    IF FILENAME[LENGTH(FILENAME)]='.' THEN 
   496  10    1:7   673 	      DELETE(FILENAME,LENGTH(FILENAME),1);
   497  10    1:6   683 	    OPENOLD(THEFILE,FILENAME);
   498  10    1:6   693 	    MSG:='Not present. File? ';
   499  10    1:5   720 	  UNTIL IORESULT=0;
   500  10    1:4   726 	END;
   501  10    1:4   726 
   502  10    1:4   726 
   503  10    1:4   726       (* Read in the file *)
   504  10    1:4   726 
   505  10    1:3   726       READFILE;
   506  10    1:3   728       1: IF (EBUF^[BUFCOUNT-1]<>CHR(EOL)) OR (BUFCOUNT=1) THEN
   507  10    1:4   742 	BEGIN
   508  10    1:5   742 	  EBUF^[BUFCOUNT]:=CHR(EOL);
   509  10    1:5   747 	  BUFCOUNT:=BUFCOUNT+1;
   510  10    1:4   752 	END;
   511  10    1:4   752 
   512  10    1:4   752 
   513  10    1:4   752       (* Initialize everything else! *)
   514  10    1:4   752 
   515  10    1:3   752       DIRECTION:='>';
   516  10    1:3   755       LASTPAT:=1; (* Init to the beginning of the buffer (for equalc) *)
   517  10    1:3   758       COPYOK:=FALSE;
   518  10    1:3   762       LINE1PTR:=1;
   519  10    1:3   766       (* These do not yet go through the Screen and Keyboard control
   520  10    1:3   766 	 records *)
   521  10    1:3   766       WITH SYSCOM^.CRTINFO DO
   522  10    1:4   774 	BEGIN
   523  10    1:5   774 	  ESC:=ORD(ALTMODE);
   524  10    1:5   785 	  BS:=ORD(CHARDEL);
   525  10    1:5   796 	  DEL:=ORD(LINEDEL);
   526  10    1:5   807 	  SCREENWIDTH:=WIDTH-1;
   527  10    1:5   815 {.fs}     IF SCREENWIDTH>MAXSW THEN SCREENWIDTH:=MAXSW; { risk of buffer overflow }
   528  10    1:5   823 	  SCREENHEIGHT:=HEIGHT-1;
   529  10    1:5   831 	  MIDDLE:=(SCREENHEIGHT DIV 2) + 1;
   530  10    1:4   839 	END;
   531  10    1:3   839       ETX:=ORD(KEYBRD.CH[ETXKEY]); {Changed from SYSCOM assignment 11/2/78 MAB}
   532  10    1:3   847       MAP(CHR(BS),LEFT);                     (* Map backspace key for now *)
   533  10    1:3   853       SYSCOM^.MISCINFO.NOBREAK := TRUE;
   534  10    1:3   862       {Including the command prompt line}
   535  10    1:3   862       DEFPROMPTS;
   536  10    1:3   864       SDEFINED:=FALSE; TDEFINED:=FALSE; (* No substring or target *)
   537  10    1:3   872       WITH PAGEZERO DO
   538  10    1:4   872 	IF NOT DEFINED THEN 
   539  10    1:5   878 	  BEGIN
   540  10    1:6   878 	    FILLCHAR(BUF,1024,CHR(0));
   541  10    1:6   888 	    CREATED:=THEDATE; LASTUSED:=THEDATE;
   542  10    1:6   904 	    TOKDEF:=TRUE; (* Default mode is T(oken *)
   543  10    1:6   908 	    FILLING:=FALSE; AUTOINDENT:=TRUE; RUNOFFCH:='^';
   544  10    1:6   920 	    LMARGIN:=0; PARAMARGIN:=5; RMARGIN:=SCREENWIDTH;
   545  10    1:6   932 	    DEFINED:=TRUE;
   546  10    1:5   936 	  END;
   547  10    1:2   936     END(* WITH *);
   548  10    1:2   936 
   549  10    1:2   936 
   550  10    1:2   936   (* Initialize the KIND array for token find *)
   551  10    1:2   936 
   552  10    1:1   936   FOR CH:=CHR(0) TO CHR(255) DO KIND[CH]:=ORD(CH);  (* Make them all unique *)
   553  10    1:1   966   FOR CH:='A' TO 'Z' DO KIND[CH]:=ORD('A');
   554  10    1:1   994   FOR CH:='a' TO 'z' DO KIND[CH]:=ORD('A');
   555  10    1:1  1022   FOR CH:='0' TO '9' DO KIND[CH]:=ORD('A');
   556  10    1:1  1050   KIND[CHR(EOL)]:=ORD(' '); KIND[CHR(HT)] :=ORD(' ');
   557  10    1:1  1064   FILLCHAR(BLANKAREA,SIZEOF(BLANKAREA),' ');
   558  10    1:1  1074   SAVETOP:='';
   559  10    1:1  1082 
   560  10    1:0  1082 END(* INITIALIZE *);
   561  10    1:0  1114 
   562  10    1:0  1114 (* --- OUT       --- *)
   563  11    1:D     3 SEGMENT FUNCTION OUT: BOOLEAN;
   564  11    1:D     3 LABEL 1,2;
   565  11    1:D     3 VAR
   566  11    1:D     3   SAVE: PTRTYPE;
   567  11    1:D     4   I: INTEGER;
   568  11    1:D     5   BUF: PACKED ARRAY [0..1023] OF CHAR;
   569  11    1:D   517   FN: STRING;
   570  11    1:0     0 BEGIN
   571  11    1:1     0   OUT:=FALSE;
   572  11    1:1     3   REPEAT
   573  11    1:2     3     CLEARSCREEN;     (* Dumb terminal patch *)
   574  11    1:2     6     SAVETOP:='>Quit:';
   575  11    1:2    20     WRITELN(SAVETOP);
   576  11    1:2    36     WRITELN('     U(pdate the workfile and leave');
   577  11    1:2    87     WRITELN('     E(xit without updating');
   578  11    1:2   130     WRITELN('     R(eturn to the editor without updating');
   579  11    1:2   189     WRITELN('     W(rite to a file name and return');
   580  11    1:2   242     CH:=UCLC(GETCH);
   581  11    1:1   254   UNTIL CH IN ['U','E','R','W'];
   582  11    1:1   274   IF CH='R' THEN GOTO 2;
   583  11    1:1   281   IF CH='E' THEN BEGIN OUT:=TRUE; CLEARSCREEN; GOTO 2 END;
   584  11    1:1   294   CLOSE(THEFILE);
   585  11    1:1   301   IF CH='W' THEN
   586  11    1:2   306     BEGIN
   587  11    1:3   306       SAVE:=CURSOR;
   588  11    1:3   309       BLANKCRT(1);
   589  11    1:3   313       WRITE('Name of output file (<cr> to return)  -->');
   590  11    1:3   364       READLN(FN);
   591  11    1:3   380       IF LENGTH(FN)=0 THEN GOTO 2;
   592  11    1:3   391       FOR I:=1 TO LENGTH(FN) DO FN[I]:=UCLC(FN[I]);
   593  11    1:3   431       IF ((POS('.TEXT',FN)<>LENGTH(FN)-4) OR (LENGTH(FN)<=4)) AND
   594  11    1:3   463 	 (FN[LENGTH(FN)]<>'.') THEN
   595  11    1:4   477 	FN:=CONCAT(FN,'.TEXT');
   596  11    1:3   514       IF FN[LENGTH(FN)]='.' THEN DELETE(FN,LENGTH(FN),1);
   597  11    1:2   539     END
   598  11    1:1   539   ELSE
   599  11    1:2   541     FN:='*SYSTEM.WRK.TEXT';
   600  11    1:1   565   BLANKCRT(1);
   601  11    1:1   569   WRITE('Writing');
   602  11    1:1   586   OPENNEW(THEFILE,FN);
   603  11    1:1   597   PAGEZERO.LASTUSED:=THEDATE;
   604  11    1:1   605   IF BLOCKWRITE(THEFILE,PAGEZERO,2) <> 2 THEN GOTO 1;
   605  11    1:1   629   WRITE('.');
   606  11    1:1   637   CURSOR:=1;
   607  11    1:1   640   WHILE CURSOR < BUFCOUNT-1023 DO
   608  11    1:2   649     BEGIN
   609  11    1:3   649       I:=SCAN(-1022,=CHR(EOL),EBUF^[CURSOR+1022]);
   610  11    1:3   667       MOVELEFT(EBUF^[CURSOR],BUF,1023+I);
   611  11    1:3   680       FILLCHAR(BUF[1023+I],ABS(I)+1,CHR(0));
   612  11    1:3   694       IF BLOCKWRITE(THEFILE,BUF,2) <> 2 THEN GOTO 1;
   613  11    1:3   717       CURSOR:=CURSOR+1023+I;
   614  11    1:3   726       WRITE('.');
   615  11    1:2   734     END;
   616  11    1:1   736   IF CURSOR<BUFCOUNT THEN
   617  11    1:2   741     BEGIN
   618  11    1:3   741       FILLCHAR(BUF,SIZEOF(BUF),CHR(0));
   619  11    1:3   750       MOVELEFT(EBUF^[CURSOR],BUF,BUFCOUNT-CURSOR);
   620  11    1:3   761       IF BLOCKWRITE(THEFILE,BUF,2) <> 2 THEN GOTO 1; WRITE('.')
   621  11    1:2   792     END;
   622  11    1:1   792   CLOSE(THEFILE,LOCK);
   623  11    1:1   799   WRITELN;
   624  11    1:1   805   WRITELN('Your file is ',BUFCOUNT,' bytes long.');
   625  11    1:1   864   IF CH='U' THEN
   626  11    1:2   869     WITH USERINFO DO
   627  11    1:3   869       BEGIN
   628  11    1:4   869 	SYMVID:=SYVID; SYMTID:='SYSTEM.WRK.TEXT'; GOTSYM:=TRUE;
   629  11    1:4   904 	OPENOLD(THEFILE,'*SYSTEM.WRK.CODE'); CLOSE(THEFILE,PURGE);
   630  11    1:4   938 	GOTCODE:=FALSE; CODETID:=''; OUT:=TRUE;
   631  11    1:3   953       END
   632  11    1:1   953     ELSE
   633  11    1:2   955       BEGIN
   634  11    1:3   955         WRITE('Do you want to E(xit from or R(eturn to the editor? ');
   635  11    1:3  1017 	REPEAT CH:=UCLC(GETCH) UNTIL CH IN ['E','R'];
   636  11    1:3  1048 	OUT:= CH='E';
   637  11    1:3  1053 	CURSOR:=SAVE; (* QW returns to the editor *)
   638  11    1:2  1056       END;
   639  11    1:1  1056   GOTO 2; (* SORRY ABOUT THAT EDSGER *)
   640  11    1:1  1058 1: ERROR('Writing out the file',NONFATAL);
   641  11    1:1  1085 2:END;
   642  11    1:1  1112 
   643  11    1:1  1112 (* --- COPYFILE  --- *)
   644  12    1:D     1 SEGMENT PROCEDURE COPYFILE;
   645  12    1:D     1 VAR
   646  12    1:D     1   STARTPAGE,STOPPAGE,STARTOFFSET,STOPOFFSET,
   647  12    1:D     1   LEFTPART,PAGE,NOTNULLS,THEREST,LMOVE: INTEGER;
   648  12    1:D    10   DONE,OVFLW: BOOLEAN;
   649  12    1:D    12   BUFR: PACKED ARRAY [0..1023] OF CHAR;
   650  12    1:D   524   STARTMARK,STOPMARK: PACKED ARRAY [0..7] OF CHAR;
   651  12    1:D   532   FN: STRING;
   652  12    1:D   573   F: FILE;
   653  12    1:D   613 
   654  12    2:D     1 PROCEDURE ERRMARKER;
   655  12    2:0     0 BEGIN
   656  12    2:1     0   ERROR('Improper marker specification.',NONFATAL);
   657  12    2:1    37   EXIT(COPYFILE)
   658  12    2:0    41 END;
   659  12    2:0    54 
   660  12    3:D     1 PROCEDURE UNSPLITBUF;
   661  12    3:D     1 (* Stich the buffer back together again. *)
   662  12    3:0     0 BEGIN
   663  12    3:1     0   MOVELEFT(EBUF^[THEREST],EBUF^[CURSOR],LMOVE);
   664  12    3:1    13   READJUST(LEFTPART+1,CURSOR-(LEFTPART+1));
   665  12    3:1    28   BUFCOUNT:=BUFCOUNT+CURSOR-(LEFTPART+1);
   666  12    3:1    39   CURSOR:=LEFTPART+1; (* Cursor points to the beginning of the file *)
   667  12    3:0    46 END;
   668  12    3:0    58 
   669  12    4:D     1 PROCEDURE READERR;
   670  12    4:0     0 BEGIN
   671  12    4:1     0   ERROR('Marker exceeds file bounds.',NONFATAL);
   672  12    4:1    34   UNSPLITBUFF;
   673  12    4:1    36   CENTERCURSOR(TRASH,MIDDLE,TRUE);
   674  12    4:1    46   EXIT(COPYFILE)
   675  12    4:0    50 END;
   676  12    4:0    62 
   677  12    5:D     1 PROCEDURE SPLITBUF;
   678  12    5:D     1 (* Split the buffer at the Cursor.  Therest points to the right part, Lmove
   679  12    5:D     1    is the length of the right part, Leftpart points to the end of the 'left
   680  12    5:D     1    part', and Cursor remains unchanged. *)
   681  12    5:0     0 BEGIN
   682  12    5:1     0   THEREST:=BUFSIZE-(BUFCOUNT-CURSOR);
   683  12    5:1     8   LMOVE:=BUFCOUNT-CURSOR+1;
   684  12    5:1    16   LEFTPART:=CURSOR-1;
   685  12    5:1    22   MOVERIGHT(EBUF^[CURSOR],EBUF^[THEREST],LMOVE)
   686  12    5:0    35 END;
   687  12    5:0    48 
   688  12    6:D     1 PROCEDURE PARSEFN;
   689  12    6:D     1 VAR I,LPTR,RPTR,COMMA: INTEGER;
   690  12    6:D     5     MARK: STRING;
   691  12    6:0     0 BEGIN
   692  12    6:1     0   LPTR:=POS('[',FN);
   693  12    6:1    15   IF LPTR=0 THEN
   694  12    6:2    20     BEGIN (* whole file *)
   695  12    6:3    20       STARTMARK:='        ';
   696  12    6:3    37       STOPMARK:= '        '
   697  12    6:2    41     END
   698  12    6:1    54   ELSE
   699  12    6:2    56     BEGIN
   700  12    6:3    56       RPTR:=POS(']',FN);
   701  12    6:3    71       IF (RPTR=0) OR (RPTR<LPTR) OR (RPTR<>LENGTH(FN)) THEN ERRMARKER;
   702  12    6:3    91       MARK:=COPY(FN,LPTR+1,RPTR-LPTR-1); (* stuff between the brackets *)
   703  12    6:3   114       FN:=COPY(FN,1,LPTR-1);
   704  12    6:3   135       COMMA:=POS(',',MARK);
   705  12    6:3   148       IF COMMA=0 THEN ERRMARKER;
   706  12    6:3   155       I:=LENGTH(MARK)-COMMA; (* second marker ptr *)
   707  12    6:3   163       MOVELEFT(MARK[1],STARTMARK,MIN(8,COMMA-1));
   708  12    6:3   182       FILLCHAR(STARTMARK[COMMA-1],MAX(0,8-(COMMA-1)),' ');
   709  12    6:3   203       MOVELEFT(MARK[COMMA+1],STOPMARK,MIN(I,8));
   710  12    6:3   222       FILLCHAR(STOPMARK[I],MAX(0,8-I),' ')
   711  12    6:2   239     END;
   712  12    6:1   239   FOR I:=0 TO 7 DO STARTMARK[I]:=UCLC(STARTMARK[I]);
   713  12    6:1   275   FOR I:=0 TO 7 DO STOPMARK [I]:=UCLC(STOPMARK[I]);
   714  12    6:1   311   FOR I:=1 TO LENGTH(FN) DO FN[I]:=UCLC(FN[I]);
   715  12    6:1   352   IF ((POS('.TEXT',FN)<>LENGTH(FN)-4) OR 
   716  12    6:1   378      (LENGTH(FN)<=4)) AND (FN[LENGTH(FN)]<>'.') THEN
   717  12    6:2   403     FN:=CONCAT(FN,'.TEXT');
   718  12    6:1   438   IF FN[LENGTH(FN)]='.' THEN DELETE(FN,LENGTH(FN),1);
   719  12    6:0   467 END;
   720  12    6:0   488 
   721  12    7:D     1 PROCEDURE STUFFIT(START,STOP:INTEGER);
   722  12    7:D     3 (* Put the contents of BUFR into EBUF.  OVFLW is set to true when there is
   723  12    7:D     3    no more room in the buffer. *)
   724  12    7:D     3 VAR AMOUNT: INTEGER;
   725  12    7:0     0 BEGIN
   726  12    7:1     0   IF START<=STOP THEN
   727  12    7:2     5     BEGIN
   728  12    7:3     5       AMOUNT:=STOP-START+1;
   729  12    7:3    12       IF CURSOR+AMOUNT+250(*slop*)>=THEREST THEN
   730  12    7:4    25         BEGIN
   731  12    7:5    25 	  ERROR('Buffer overflow.',NONFATAL);
   732  12    7:5    48 	  UNSPLITBUFF;
   733  12    7:5    50 	  CENTERCURSOR(TRASH,MIDDLE,TRUE);
   734  12    7:5    60 	  EXIT(COPYFILE)
   735  12    7:4    64 	END
   736  12    7:3    64       ELSE
   737  12    7:4    66 	BEGIN
   738  12    7:5    66 	  MOVELEFT(BUFR[START],EBUF^[CURSOR],AMOUNT);
   739  12    7:5    76 	  CURSOR:=CURSOR+AMOUNT
   740  12    7:4    77 	END
   741  12    7:2    81     END
   742  12    7:0    81 END;
   743  12    7:0    94 
   744  12    8:D     1 PROCEDURE GETNEXT;
   745  12    8:0     0 BEGIN
   746  12    8:0     0 {.fs# DONE:=BLOCKREAD(F,BUFR,2,PAGE+PAGE)<>2; } { char dev may return 1 or 2 }
   747  12    8:1     0   DONE:=BLOCKREAD(F,BUFR,2,PAGE+PAGE)=0;
   748  12    8:1    27   WRITE('.');
   749  12    8:1    35   IF NOT DONE THEN NOTNULLS:=SCAN(-1024,<>CHR(0),BUFR[1023])+1024
   750  12    8:1    56   ELSE NOTNULLS:=0;
   751  12    8:1    69   PAGE:=PAGE+1;
   752  12    8:0    77 END;
   753  12    8:0    90 
   754  12    9:D     1 PROCEDURE CHKOVFLW;
   755  12    9:0     0 BEGIN
   756  12    9:1     0   IF (STOPOFFSET>=NOTNULLS) AND (STOPPAGE<PAGE) THEN
   757  12    9:2    17     BEGIN
   758  12    9:3    17       STOPPAGE:=STOPPAGE+1;
   759  12    9:3    25       STOPOFFSET:=STOPOFFSET-NOTNULLS;
   760  12    9:2    35     END;
   761  12    9:0    35 END;
   762  12    9:0    48 
   763  12   10:D     1 PROCEDURE FINDMARKERS;
   764  12   10:D     1 (* Given STARTMARK and STOPMARK find out their page numbers and offsets *)
   765  12   10:D     1 VAR
   766  12   10:D     1   PZ: HEADER;
   767  12   10:D   513 
   768  12   11:D     1   PROCEDURE SEARCH(MNAME:NAME;VAR OFF,PNUM: INTEGER);
   769  12   11:D     8   VAR
   770  12   11:D     8     I: INTEGER;
   771  12   11:0     0   BEGIN
   772  12   11:1     0     I:=0;
   773  12   11:1     8     WHILE (I<PZ.COUNT) AND (MNAME<>PZ.NAME[I]) DO I:=I+1;
   774  12   11:1    34     IF MNAME<>PZ.NAME[I] THEN
   775  12   11:2    47       BEGIN
   776  12   11:3    47 	ERROR('Marker not there.',NONFATAL);
   777  12   11:3    71 	UNSPLITBUFF;
   778  12   11:3    73 	EXIT(COPYFILE)
   779  12   11:2    77       END;
   780  12   11:1    77     OFF:=PZ.POFFSET[I];
   781  12   11:1    86     PNUM:=PZ.PAGEN[I];
   782  12   11:1    93     IF PNUM=0 THEN
   783  12   11:2    99       BEGIN OFF:=OFF-1; PNUM:=1 END; (* Kludge to maintain compatibility *)
   784  12   11:0   108   END;
   785  12   11:0   122 
   786  12   10:0     0 BEGIN(* findmarkers *)
   787  12   10:1     0   STARTPAGE:=1;    STARTOFFSET:=0;   (* default values *)
   788  12   10:1     8   STOPPAGE:=32767; STOPOFFSET:=32767;
   789  12   10:1    20   IF (STARTMARK<>'        ') OR (STOPMARK<>'        ') THEN
   790  12   10:2    59     BEGIN
   791  12   10:3    59       IF BLOCKREAD(F,PZ,2,0)<>2 THEN READERR;
   792  12   10:3    80       IF STARTMARK<>'        ' THEN SEARCH(STARTMARK,STARTOFFSET,STARTPAGE);
   793  12   10:3   112       IF STOPMARK<>'        ' THEN SEARCH(STOPMARK,STOPOFFSET,STOPPAGE)
   794  12   10:2   142     END
   795  12   10:0   144 END;
   796  12   10:0   156 
   797  12    1:0     0 BEGIN
   798  12    1:1     0   PROMPTLINE:=' Copy: From what file[marker,marker]? ';
   799  12    1:1    59   REPEAT
   800  12    1:2    59     PROMPT;
   801  12    1:2    62     READLN(FN);
   802  12    1:2    78     IF LENGTH(FN)=0 THEN EXIT(COPYFILE);
   803  12    1:2    91     PARSEFN;
   804  12    1:2    93     RESET(F,FN);
   805  12    1:2   104     PROMPTLINE:=' Copy: File not present. Filename? ';
   806  12    1:1   147   UNTIL IORESULT=0;
   807  12    1:1   153   PROMPTLINE:=' Copy'; PROMPT;
   808  12    1:1   169   SPLITBUF;
   809  12    1:1   171   FINDMARKERS;
   810  12    1:1   173   PAGE:=STARTPAGE;
   811  12    1:1   176   GETNEXT;
   812  12    1:1   178   WHILE (STARTOFFSET>=NOTNULLS) AND NOT DONE DO
   813  12    1:2   186     BEGIN
   814  12    1:3   186       CHKOVFLW;
   815  12    1:3   188       STARTOFFSET:=STARTOFFSET-NOTNULLS;
   816  12    1:3   193       GETNEXT;
   817  12    1:2   195     END;
   818  12    1:1   197   IF (STOPPAGE<PAGE) AND (STOPOFFSET<NOTNULLS) THEN
   819  12    1:2   206     STUFFIT(STARTOFFSET,MIN(NOTNULLS-1,STOPOFFSET-1))
   820  12    1:1   218   ELSE
   821  12    1:2   222     STUFFIT(STARTOFFSET,NOTNULLS-1);
   822  12    1:1   228   WHILE ((STOPPAGE>=PAGE) OR (STOPOFFSET>=NOTNULLS)) AND NOT DONE DO
   823  12    1:2   240     BEGIN
   824  12    1:3   240       CHKOVFLW;
   825  12    1:3   242       GETNEXT;
   826  12    1:3   244       IF (STOPPAGE<PAGE) AND (STOPOFFSET<NOTNULLS) THEN
   827  12    1:4   253 	STUFFIT(0,MIN(NOTNULLS-1,STOPOFFSET-1))
   828  12    1:3   265       ELSE
   829  12    1:4   269 	STUFFIT(0,NOTNULLS-1)
   830  12    1:2   273     END;
   831  12    1:1   277   IF IORESULT<>0 THEN ERROR('Disk Error.',NONFATAL);
   832  12    1:1   301   UNSPLITBUF;
   833  12    1:1   303   CENTERCURSOR(TRASH,MIDDLE,TRUE);
   834  12    1:1   313   CLOSE(F);
   835  12    1:0   320 END;
   836  12    1:0   346 
   837  12    1:0   346 (* --- ENVIRON   --- *)
   838  13    1:D     1 SEGMENT PROCEDURE ENVIRONMENT;
   839  13    1:D     1 VAR
   840  13    1:D     1   I: INTEGER;
   841  13    1:D     2 
   842  13    2:D     1   PROCEDURE ERASE10;
   843  13    2:D     1   VAR I: INTEGER;
   844  13    2:0     0   BEGIN
   845  13    2:1     0     WRITE(' ':10);
   846  13    2:1     8     FOR I:=1 TO 10 DO WRITE(CHR(BS));
   847  13    2:0    36   END;
   848  13    2:0    50 
   849  13    3:D     1   PROCEDURE BOOL(B:BOOLEAN);
   850  13    3:0     0   BEGIN
   851  13    3:1     0     IF B THEN WRITE('True') ELSE WRITE('False');
   852  13    3:1    34     WRITELN
   853  13    3:0    34   END;
   854  13    3:0    52 
   855  13    4:D     3   FUNCTION GETBOOL: BOOLEAN;
   856  13    4:D     3   VAR CH: CHAR;
   857  13    4:0     0   BEGIN
   858  13    4:1     0     ERASE10; CH:=UCLC(GETCH);
   859  13    4:1    14     WHILE NOT (CH IN ['T','F']) DO
   860  13    4:2    35       BEGIN
   861  13    4:3    35 	WRITE('T or F');
   862  13    4:3    51 	FOR TRASH:=0 TO 5 DO WRITE(CHR(BS));
   863  13    4:3    85 	CH:=UCLC(GETCH)
   864  13    4:2    90       END;
   865  13    4:1    99     IF CH='T' THEN
   866  13    4:2   104       BEGIN
   867  13    4:3   104 	WRITE('True  ');
   868  13    4:3   120 	GETBOOL:=TRUE
   869  13    4:2   120       END
   870  13    4:1   123     ELSE
   871  13    4:2   125       BEGIN
   872  13    4:3   125 	WRITE('False ');
   873  13    4:3   141 	GETBOOL:=FALSE
   874  13    4:2   141       END;
   875  13    4:0   144   END;
   876  13    4:0   160 
   877  13    5:D     3   FUNCTION GETINT: INTEGER;
   878  13    5:D     3   VAR
   879  13    5:D     3     CH:CHAR;
   880  13    5:D     4     N: INTEGER;
   881  13    5:0     0   BEGIN
   882  13    5:1     0     ERASE10;
   883  13    5:1     2     N:=0;
   884  13    5:1     5     REPEAT
   885  13    5:2     5       REPEAT
   886  13    5:3     5 	CH:=GETCH;
   887  13    5:3    12 	IF NOT (CH IN ['0'..'9',CHR(SP),CHR(CR)]) 
   888  13    5:3    31 	  THEN WRITE('#',CHR(BELL),CHR(BS));
   889  13    5:2    60       UNTIL CH IN ['0'..'9',CHR(SP),CHR(CR)];
   890  13    5:2    81       IF CH IN ['0'..'9'] THEN
   891  13    5:3    96 	BEGIN
   892  13    5:4    96 	  WRITE(CH);
   893  13    5:4   104 	  IF N<1000 THEN N:=N*10+ORD(CH)-ORD('0')
   894  13    5:3   117 	END;
   895  13    5:1   120     UNTIL CH IN [CHR(SP),CHR(CR)];
   896  13    5:1   129     GETINT:=N; WRITE('  ')
   897  13    5:0   144   END;
   898  13    5:0   160 
   899  13    1:0     0 BEGIN
   900  13    1:1     0   WITH PAGEZERO DO
   901  13    1:2     0     BEGIN
   902  13    1:3     0       CLEARSCREEN;
   903  13    1:3     3       PROMPTLINE:= ' Environment: {options} <etx> or <sp> to leave'; 
   904  13    1:3    57       PROMPT; NEEDPROMPT:=TRUE;
   905  13    1:3    64       WRITELN;
   906  13    1:3    70       WRITE(       '    A(uto indent  '); BOOL(AUTOINDENT);
   907  13    1:3   103       WRITE(       '    F(illing      '); BOOL(FILLING);
   908  13    1:3   136       WRITE(       '    L(eft margin  '); WRITELN(LMARGIN);
   909  13    1:3   180       WRITE(       '    R(ight margin '); WRITELN(RMARGIN);
   910  13    1:3   224       WRITE(       '    P(ara margin  '); WRITELN(PARAMARGIN);
   911  13    1:3   268       WRITE(       '    C(ommand ch   '); WRITELN(RUNOFFCH);
   912  13    1:3   312       WRITE(       '    T(oken def    '); BOOL(TOKDEF);
   913  13    1:3   345       WRITELN;
   914  13    1:3   351       WRITELN('    ',BUFCOUNT,' bytes used, ',BUFSIZE-BUFCOUNT+1,' available.');
   915  13    1:3   435       WRITELN; 
   916  13    1:3   441       IF SDEFINED OR TDEFINED THEN
   917  13    1:4   450 	BEGIN
   918  13    1:5   450 	  WRITELN('    Patterns:');
   919  13    1:5   479 	  IF TDEFINED THEN WRITE('      <target>= ''',TARGET:TLENGTH,'''');
   920  13    1:5   534 	  IF SDEFINED THEN WRITE(', <subst>=  ''',SUBSTRING:SLENGTH,'''');
   921  13    1:5   585 	  WRITELN; WRITELN;
   922  13    1:4   597         END;
   923  13    1:3   597       IF COUNT>0 THEN WRITELN('    Markers:');
   924  13    1:3   632       WRITE('  ');
   925  13    1:3   644       FOR I:=0 TO COUNT-1 DO
   926  13    1:4   659         BEGIN WRITE(' ':6,NAME[I]);
   927  13    1:5   681 	  IF (I+4) MOD 3=0 THEN BEGIN WRITELN; WRITE('  ') END
   928  13    1:4   708 	END;
   929  13    1:3   715       WRITELN;
   930  13    1:3   721       WRITELN;
   931  13    1:3   727       WRITELN('    Date Created: ',CREATED.MONTH,'-',CREATED.DAY,'-',
   932  13    1:3   797 				  CREATED.YEAR,'   Last Used: ',
   933  13    1:3   834 				  LASTUSED.MONTH,'-',LASTUSED.DAY,'-',
   934  13    1:3   876 				  LASTUSED.YEAR);
   935  13    1:3   895       GOTOXY(LENGTH(PROMPTLINE),0);
   936  13    1:3   904       REPEAT
   937  13    1:4   904 	CH:=UCLC(GETCH);
   938  13    1:4   916 	IF NOT (CH IN ['A','C','F','L','P','R','T',' ',CHR(ETX),CHR(CR)]) THEN
   939  13    1:5   944 	  BEGIN ERROR('Not option',NONFATAL); PROMPT; END
   940  13    1:4   964 	ELSE
   941  13    1:5   966 	  CASE CH OF
   942  13    1:5   969 	   'A': BEGIN GOTOXY(18,1); AUTOINDENT:=GETBOOL END;
   943  13    1:5   983 	   'F': BEGIN GOTOXY(18,2); FILLING:=GETBOOL END;
   944  13    1:5   997 	   'L': BEGIN GOTOXY(18,3); LMARGIN:=GETINT END;
   945  13    1:5  1011 	   'R': BEGIN GOTOXY(18,4); RMARGIN:=GETINT END;
   946  13    1:5  1025 	   'P': BEGIN GOTOXY(18,5); PARAMARGIN:=GETINT END;
   947  13    1:5  1039 	   'C': BEGIN GOTOXY(18,6); READ(RUNOFFCH) END;
   948  13    1:5  1055 	   'T': BEGIN GOTOXY(18,7); TOKDEF:=GETBOOL END
   949  13    1:5  1067 	  END;
   950  13    1:4  1116 	GOTOXY(LENGTH(PROMPTLINE),0);
   951  13    1:3  1125       UNTIL CH IN [' ',CHR(ETX),CHR(CR)];
   952  13    1:3  1147       REDISPLAY;
   953  13    1:2  1150     END;
   954  13    1:0  1150 END;
   955  13    1:0  1172 
   956  13    1:0  1172 (* --- PUTSYNTAX --- *)
   957  14    1:D     1 SEGMENT PROCEDURE PUTSYNTAX;
   958  14    1:D     1 VAR
   959  14    1:D     1   D0,D1,D2,BLK,PTR,COLON: INTEGER;
   960  14    1:D     7   T,C:PACKED ARRAY [0..2] OF CHAR;
   961  14    1:D    11   BUF:PACKED ARRAY [0..1023] OF CHAR;
   962  14    1:D   523   F: FILE;
   963  14    1:D   563 
   964  14    2:D     1 PROCEDURE PUTNUM;
   965  14    2:0     0 BEGIN
   966  14    2:1     0   MSG:='Syntax Error #'; PUTMSG;
   967  14    2:1    25   WRITE(USERINFO.ERRNUM,'. Type <sp>');
   968  14    2:0    56 END;
   969  14    2:0    68 
   970  14    1:0     0 BEGIN (* putsyntax *)
   971  14    1:1     0   WITH USERINFO DO
   972  14    1:2    13     BEGIN
   973  14    1:3    13       OPENOLD(F,'*SYSTEM.SYNTAX');
   974  14    1:3    38       IF IORESULT<>0 THEN PUTNUM
   975  14    1:3    44       ELSE
   976  14    1:4    48 	BEGIN
   977  14    1:5    48 	  IF ERRNUM<=104 THEN BLK:=2
   978  14    1:5    55 	  ELSE
   979  14    1:6    60 	    IF ERRNUM<=126 THEN BLK:=4
   980  14    1:6    67 	    ELSE
   981  14    1:7    72 	      IF ERRNUM<=151 THEN BLK:=6
   982  14    1:7    81 	      ELSE
   983  14    1:8    86 		IF ERRNUM<=185 THEN BLK:=8
   984  14    1:8    95 		ELSE 
   985  14    1:9   100 		 IF ERRNUM<=302 THEN BLK:=10
   986  14    1:9   109 		 ELSE BLK:=12;
   987  14    1:5   117 	  IF BLOCKREAD(F,BUF,2,BLK)<>2 THEN PUTNUM
   988  14    1:5   135 	  ELSE
   989  14    1:6   139 	    BEGIN
   990  14    1:7   139 	      IF BUF[0]=CHR(DLE) THEN PTR:=2 ELSE PTR:=0;
   991  14    1:7   155 	      D0:=ERRNUM DIV 100; (* convert error number to characters *)
   992  14    1:7   162 	      D1:=(ERRNUM-D0*100) DIV 10;
   993  14    1:7   173 	      D2:=ERRNUM MOD 10;
   994  14    1:7   180 	      T[0]:=CHR(D0+ORD('0')); T[1]:=CHR(D1+ORD('0'));
   995  14    1:7   194 	      T[2]:=CHR(D2+ORD('0'));
   996  14    1:7   201 	      REPEAT
   997  14    1:8   201 		FILLCHAR(C,3,'0');
   998  14    1:8   208 		COLON:=SCAN(MAXCHAR,=':',BUF[PTR]);
   999  14    1:8   221 		MOVELEFT(BUF[PTR],C[3-COLON],COLON);
  1000  14    1:8   232 		COLON:=COLON+PTR;
  1001  14    1:8   237 		PTR:=SCAN(MAXCHAR,=CHR(EOL),BUF[PTR])+PTR+3
  1002  14    1:7   250 	      UNTIL (T=C) OR (BUF[PTR]=CHR(0));
  1003  14    1:7   270 	      IF (T<>C) AND (BUF[PTR]=CHR(0)) THEN PUTNUM
  1004  14    1:7   286 	      ELSE
  1005  14    1:8   290 		BEGIN
  1006  14    1:9   290 		  MOVELEFT(BUF[COLON+1],MSG[1],(PTR-COLON)-4);
  1007  14    1:9   306 		  MSG[0]:=CHR(MIN(68,(PTR-COLON)-4)); (* R- required *)
  1008  14    1:9   322 		  HOME; CLEARLINE(0); WRITE(MSG,'.  Type <sp>');
  1009  14    1:8   361 		END
  1010  14    1:6   361 	    END
  1011  14    1:4   361 	  END(* if ioresult<>0 *);
  1012  14    1:3   361 	SHOWCURSOR;
  1013  14    1:3   364 	REPEAT UNTIL GETCH=' ';
  1014  14    1:3   373 	ERRBLK:=0; ERRSYM:=0; ERRNUM:=0; (*  Only yell once!!! *)
  1015  14    1:2   385       END(* with userinfo *)
  1016  14    1:0   385 END(* putsyntax *);
  1017  14    1:0   412 
  1018  14    1:0   412 (* --- COMMAND   --- *)
  1019  15    1:D     1 SEGMENT PROCEDURE EDITCORE;
  1020  15    1:D     1 
  1021  15    1:D     1 (* Core procedures.  Execute these commands until either a set environment
  1022  15    1:D     1    comes along or a quit command. *)
  1023  15    1:D     1 
  1024  15    1:D     1 
  1025  15    1:D     1 
  1026  15    2:D     1 PROCEDURE NEXTCOMMAND; FORWARD;
  1027  15    2:D     1 
  1028  15    3:D     1 PROCEDURE FIXDIRECTION;
  1029  15    3:0     0 BEGIN
  1030  15    3:1     0   IF COMMAND=FORWARDC THEN DIRECTION:='>' ELSE DIRECTION:='<';
  1031  15    3:1    13   HOME; WRITE(DIRECTION); (* Update prompt line *)
  1032  15    3:1    24   SHOWCURSOR; NEXTCOMMAND
  1033  15    3:0    27 END;
  1034  15    3:0    42 
  1035  15    4:D     1 PROCEDURE COPY;
  1036  15    4:0     0 BEGIN
  1037  15    4:1     0   PROMPTLINE:=' Copy: B(uffer  F(rom file  <esc>';
  1038  15    4:1    41   PROMPT; NEEDPROMPT:=TRUE;
  1039  15    4:1    48   REPEAT
  1040  15    4:2    48     CH:=UCLC(GETCH);
  1041  15    4:1    60   UNTIL CH IN ['B','F',CHR(ESC)];
  1042  15    4:1    83   IF CH='B' THEN
  1043  15    4:2    88     BEGIN
  1044  15    4:3    88       IF NOT COPYOK OR ((BUFCOUNT+COPYLENGTH+10>COPYSTART)
  1045  15    4:3   103 			AND (COPYSTART>=BUFCOUNT))
  1046  15    4:3   109 	THEN ERROR('Invalid copy.',NONFATAL)
  1047  15    4:3   129 	ELSE
  1048  15    4:4   134 	  IF BUFCOUNT+COPYLENGTH>=BUFSIZE THEN ERROR('No room',NONFATAL)
  1049  15    4:4   154 	  ELSE
  1050  15    4:5   159 	    BEGIN
  1051  15    4:6   159 	      IF COPYLINE THEN
  1052  15    4:7   164 		BEGIN
  1053  15    4:8   164 		  GETLEADING;
  1054  15    4:8   167 		  CURSOR:=LINESTART
  1055  15    4:7   167 		END;
  1056  15    4:6   170 	      MOVERIGHT(EBUF^[CURSOR],EBUF^[CURSOR+COPYLENGTH],BUFCOUNT-CURSOR+1);
  1057  15    4:6   187 	      IF (COPYSTART>=CURSOR) AND (COPYSTART<BUFCOUNT) THEN
  1058  15    4:7   200 		MOVELEFT(EBUF^[COPYSTART+COPYLENGTH],EBUF^[CURSOR],COPYLENGTH)
  1059  15    4:6   217 	      ELSE
  1060  15    4:7   219 		MOVELEFT(EBUF^[COPYSTART],EBUF^[CURSOR],COPYLENGTH);
  1061  15    4:6   232 	      BUFCOUNT:=BUFCOUNT+COPYLENGTH;
  1062  15    4:6   239 	      READJUST(CURSOR,COPYLENGTH);
  1063  15    4:6   246 	      GETLEADING;
  1064  15    4:6   249 	      CURSOR:=MAX(CURSOR,STUFFSTART);
  1065  15    4:6   258 	      CENTERCURSOR(TRASH,MIDDLE,TRUE)
  1066  15    4:5   265 	    END;
  1067  15    4:2   268     END (* CH='B' *)
  1068  15    4:1   268   ELSE
  1069  15    4:2   270     IF CH='F' THEN EXIT(EDITCORE);
  1070  15    4:1   279   SHOWCURSOR;
  1071  15    4:1   282   NEXTCOMMAND;
  1072  15    4:0   284 END(*COPY*);
  1073  15    4:0   302 
  1074  15    5:D     1 PROCEDURE DUMP;
  1075  15    5:0     0 BEGIN
  1076  15    5:1     0   NEXTCOMMAND;
  1077  15    5:0     2 END(* DUMP *);
  1078  15    5:0    14 
  1079  15    6:D     1 PROCEDURE FIND; FORWARD;
  1080  15    6:D     1 
  1081  15    7:D     1 PROCEDURE INSERTIT; FORWARD;
  1082  15    7:D     1 
  1083  15    8:D     1 PROCEDURE JUMP;
  1084  15    8:D     1 VAR CH: CHAR;
  1085  15    8:D     2 
  1086  15    9:D     1 PROCEDURE JUMPMARKER;
  1087  15    9:D     1 VAR
  1088  15    9:D     1   I: INTEGER;
  1089  15    9:D     2   MNAME: PACKED ARRAY [0..7] OF CHAR;
  1090  15    9:0     0 BEGIN
  1091  15    9:1     0   WITH PAGEZERO DO
  1092  15    9:2     0     BEGIN
  1093  15    9:3     0       GETNAME('Jump to',MNAME);
  1094  15    9:3    15       IF MNAME<>'        ' THEN
  1095  15    9:4    33 	BEGIN
  1096  15    9:5    33 	  I:=0;
  1097  15    9:5    36 	  WHILE (I<COUNT) AND (MNAME<>NAME[I]) DO I:=I+1;
  1098  15    9:5    62 	  IF MNAME<>NAME[I] THEN
  1099  15    9:6    75 	    ERROR('Not there.',NONFATAL)
  1100  15    9:5    89 	  ELSE
  1101  15    9:6    94 	    BEGIN
  1102  15    9:7    94 	      CURSOR:=POFFSET[I];
  1103  15    9:7   103 	      GETLEADING;
  1104  15    9:7   106 	      CURSOR:=MAX(CURSOR,STUFFSTART);
  1105  15    9:7   115 	      CENTERCURSOR(TRASH,MIDDLE,FALSE)
  1106  15    9:6   122 	    END;
  1107  15    9:4   125         END;
  1108  15    9:2   125     END;
  1109  15    9:0   125 END; (* jumpmarker *)
  1110  15    9:0   140 
  1111  15    8:0     0 BEGIN (* jump *)
  1112  15    8:1     0   PROMPTLINE:=' JUMP: B(eginning E(nd M(arker <esc>';
  1113  15    8:1    44   PROMPT;
  1114  15    8:1    47   NEEDPROMPT:=TRUE;  (* Need to redisplay EDIT: promptline! *)
  1115  15    8:1    51   REPEAT
  1116  15    8:2    51     CH:=UCLC(GETCH);
  1117  15    8:2    63     IF CH='B' THEN
  1118  15    8:3    68       BEGIN 
  1119  15    8:4    68 	CURSOR:=1;
  1120  15    8:4    71 	GETLEADING;
  1121  15    8:4    74 	CURSOR:=STUFFSTART;
  1122  15    8:4    77 	CENTERCURSOR(TRASH,1,FALSE)
  1123  15    8:3    82       END
  1124  15    8:2    85     ELSE
  1125  15    8:3    87       IF CH='E' THEN
  1126  15    8:4    92 	BEGIN
  1127  15    8:5    92 	  CURSOR:=BUFCOUNT-1;
  1128  15    8:5    97 	  CENTERCURSOR(TRASH,SCREENHEIGHT-1,FALSE);
  1129  15    8:4   107 	END
  1130  15    8:3   107       ELSE
  1131  15    8:4   109 	IF CH='M' THEN JUMPMARKER
  1132  15    8:4   114 	ELSE IF CH<>CHR(ESC) THEN ERRWAIT;
  1133  15    8:1   128   UNTIL (CH IN ['B','E','M',CHR(ESC)]);
  1134  15    8:1   151   NEXTCOMMAND;
  1135  15    8:0   153 END;
  1136  15    8:0   168 
  1137  15   10:D     1 PROCEDURE DEFMACRO;
  1138  15   10:0     0 BEGIN
  1139  15   10:1     0   WITH PAGEZERO DO IF FILLING AND NOT AUTOINDENT THEN
  1140  15   10:3    10     BEGIN
  1141  15   10:4    10       BLANKCRT(1);
  1142  15   10:4    14       THEFIXER(CURSOR,REPEATFACTOR,TRUE);
  1143  15   10:4    20       CENTERCURSOR(TRASH,MIDDLE,TRUE);
  1144  15   10:3    30     END
  1145  15   10:2    30   ELSE ERROR('Inappropriate environment',NONFATAL);
  1146  15   10:1    64   COPYOK:=FALSE;
  1147  15   10:1    68   SHOWCURSOR;
  1148  15   10:1    71   NEXTCOMMAND;
  1149  15   10:0    73 END;
  1150  15   10:0    86 
  1151  15   11:D     1 PROCEDURE SETMARKER;
  1152  15   11:D     1 LABEL 1;
  1153  15   11:D     1 VAR
  1154  15   11:D     1   I,SLOT: INTEGER;
  1155  15   11:D     3   MNAME: PACKED ARRAY [0..7] OF CHAR;
  1156  15   11:0     0 BEGIN
  1157  15   11:1     0   WITH PAGEZERO DO
  1158  15   11:2     0     BEGIN
  1159  15   11:3     0       NEEDPROMPT:=TRUE;
  1160  15   11:3     4       COUNT:=MIN(10,COUNT);
  1161  15   11:3    16       IF COUNT=10 THEN
  1162  15   11:4    23 	BEGIN
  1163  15   11:5    23 	  BLANKCRT(1);
  1164  15   11:5    27 	  FOR I:=0 TO COUNT-1 DO
  1165  15   11:6    42 	    WRITELN(I,') ',NAME[I]);
  1166  15   11:5    89 	  MSG:='Marker ovflw.  Which one to replace?';
  1167  15   11:5   133 	  PUTMSG; CH:=GETCH;
  1168  15   11:5   143 	  CENTERCURSOR(TRASH,MIDDLE,TRUE);
  1169  15   11:5   153 	  IF NOT (CH IN ['0'..'9']) THEN GOTO 1;
  1170  15   11:5   171 	  SLOT:=ORD(CH)-ORD('0')
  1171  15   11:4   173 	END
  1172  15   11:3   176       ELSE
  1173  15   11:4   178 	SLOT:=COUNT;
  1174  15   11:3   183       GETNAME('Set',MNAME);
  1175  15   11:3   194       IF MNAME<>'        ' THEN
  1176  15   11:4   212 	BEGIN
  1177  15   11:5   212 	  FOR I:=0 TO COUNT-1 DO
  1178  15   11:6   227 	    IF NAME[I]=MNAME THEN SLOT:=I;
  1179  15   11:5   250 	  NAME[SLOT]:=MNAME;
  1180  15   11:5   260 	  POFFSET[SLOT]:=CURSOR;
  1181  15   11:5   268 	  IF SLOT=COUNT THEN COUNT:=COUNT+1
  1182  15   11:4   278 	END;
  1183  15   11:2   283     END;
  1184  15   11:1   283 1:END;
  1185  15   11:1   302 
  1186  15   12:D     1 PROCEDURE SETSTUFF;
  1187  15   12:D     1 VAR CH: CHAR;
  1188  15   12:0     0 BEGIN
  1189  15   12:1     0   PROMPTLINE:=' Set: E(nvironment M(arker <esc>';
  1190  15   12:1    40   PROMPT; NEEDPROMPT:=TRUE;
  1191  15   12:1    47   REPEAT
  1192  15   12:2    47     CH:=UCLC(GETCH);
  1193  15   12:2    59     IF CH='E' THEN EXIT(EDITCORE)
  1194  15   12:2    68     ELSE
  1195  15   12:3    70       IF CH='M' THEN SETMARKER
  1196  15   12:3    75       ELSE IF CH<>CHR(ESC) THEN ERRWAIT;
  1197  15   12:1    89   UNTIL CH IN ['E','M',CHR(ESC)];
  1198  15   12:1   111   SHOWCURSOR;
  1199  15   12:1   114   NEXTCOMMAND;
  1200  15   12:0   116 END(* SETSTUFF *);
  1201  15   12:0   130 
  1202  15   13:D     1 PROCEDURE VERIFY;
  1203  15   13:0     0 BEGIN
  1204  15   13:1     0   CENTERCURSOR(TRASH,MIDDLE,TRUE);
  1205  15   13:1    10   SHOWCURSOR;
  1206  15   13:1    13   NEXTCOMMAND
  1207  15   13:0    13 END (* VERIFY *);
  1208  15   13:0    28 
  1209  15   14:D     1 PROCEDURE XMACRO;
  1210  15   14:D     1 VAR
  1211  15   14:D     1   SAVEC,I: INTEGER;
  1212  15   14:D     3   SAVE:PACKED ARRAY [0..MAXSTRING] OF CHAR;
  1213  15   14:0     0 BEGIN
  1214  15   14:1     0   PROMPTLINE:=' eXchange: TEXT {<bs> a char} [<esc> escapes; <etx> accepts]';
  1215  15   14:1    68   PROMPT; NEEDPROMPT:=TRUE;
  1216  15   14:1    75   SHOWCURSOR;
  1217  15   14:1    78   SAVEC:=CURSOR;
  1218  15   14:1    81   I:=0;
  1219  15   14:1    84   REPEAT
  1220  15   14:2    84     CH:=GETCH;
  1221  15   14:2    91     IF MAPTOCOMMAND(CH)=LEFT THEN
  1222  15   14:3   101       BEGIN
  1223  15   14:4   101 	IF (CURSOR>SAVEC) THEN
  1224  15   14:5   106 	  BEGIN
  1225  15   14:6   106 	    I:=I-1; CURSOR:=CURSOR-1; (* Decrement both ptrs *)
  1226  15   14:6   116 	    EBUF^[CURSOR]:=SAVE[I]; (* Restore buffer *)
  1227  15   14:6   124 	    WRITE(CHR(BS),EBUF^[CURSOR],CHR(BS));
  1228  15   14:5   155 	  END
  1229  15   14:3   155       END
  1230  15   14:2   155     ELSE
  1231  15   14:3   157       IF CH=CHR(EOL) THEN BEGIN ERRWAIT; SHOWCURSOR END
  1232  15   14:3   168       ELSE
  1233  15   14:4   170 	IF NOT (CH IN [CHR(ETX),CHR(ESC)]) AND (EBUF^[CURSOR]<>CHR(EOL)) THEN
  1234  15   14:5   191 	  BEGIN
  1235  15   14:6   191 	    IF NOT (CH IN [' '..'~']) THEN CH:='?';
  1236  15   14:6   218 	    SAVE[I]:=EBUF^[CURSOR];
  1237  15   14:6   226 	    EBUF^[CURSOR]:=CH;
  1238  15   14:6   231 	    I:=I+1; CURSOR:=CURSOR+1;
  1239  15   14:6   241 	    WRITE(CH)
  1240  15   14:5   249 	  END;
  1241  15   14:1   249   UNTIL CH IN [CHR(ETX),CHR(ESC)];
  1242  15   14:1   262   IF CH=CHR(ESC) THEN
  1243  15   14:2   269     BEGIN
  1244  15   14:3   269       CURSOR:=SAVEC;
  1245  15   14:3   272       MOVELEFT(SAVE[0],EBUF^[CURSOR],I);
  1246  15   14:3   281       SHOWCURSOR; WRITE(SAVE:I); SHOWCURSOR
  1247  15   14:2   296     END;
  1248  15   14:1   299   NEXTCOMMAND;
  1249  15   14:0   301 END (* XMACRO *);
  1250  15   14:0   316 
  1251  15   15:D     1 PROCEDURE ZAPIT;
  1252  15   15:0     0 BEGIN
  1253  15   15:1     0   IF ABS(LASTPAT-CURSOR)>80 THEN 
  1254  15   15:2     8     BEGIN
  1255  15   15:3     8       PROMPTLINE:=
  1256  15   15:3    11 ' WARNING! You are about to zap more than 80 chars, do you wish to zap? (y/n)';
  1257  15   15:3    92       PROMPT;
  1258  15   15:3    95       NEEDPROMPT:=TRUE;
  1259  15   15:3    99       IF UCLC(GETCH)<>'Y' THEN
  1260  15   15:4   113 	BEGIN
  1261  15   15:5   113 	  SHOWCURSOR;
  1262  15   15:5   116 	  NEXTCOMMAND;
  1263  15   15:5   118 	  EXIT(ZAPIT)
  1264  15   15:4   122 	END;
  1265  15   15:2   122     END;
  1266  15   15:1   122   IF OKTODEL(MIN(CURSOR,LASTPAT),MAX(CURSOR,LASTPAT)) THEN
  1267  15   15:2   143     BEGIN
  1268  15   15:3   143       COPYLINE:=FALSE;
  1269  15   15:3   147       READJUST(MIN(CURSOR,LASTPAT),-ABS(CURSOR-LASTPAT));
  1270  15   15:3   162       IF CURSOR>LASTPAT THEN
  1271  15   15:4   167 	MOVELEFT(EBUF^[CURSOR],EBUF^[LASTPAT],BUFCOUNT-CURSOR)
  1272  15   15:3   178       ELSE
  1273  15   15:4   180 	MOVELEFT(EBUF^[LASTPAT],EBUF^[CURSOR],BUFCOUNT-LASTPAT);
  1274  15   15:3   191       BUFCOUNT:=BUFCOUNT-ABS(CURSOR-LASTPAT);
  1275  15   15:3   199       CURSOR:=LASTPAT;
  1276  15   15:3   202       CENTERCURSOR(TRASH,MIDDLE,TRUE);
  1277  15   15:2   212     END;
  1278  15   15:1   212   SHOWCURSOR;
  1279  15   15:1   215   NEXTCOMMAND;
  1280  15   15:0   217 END;
  1281  15   15:0   230 
  1282  15   15:0   230 (* --- INSERTIT  --- *)
  1283  15    7:D     1 PROCEDURE INSERTIT;
  1284  15    7:D     1 CONST
  1285  15    7:D     1   FUDGEFACTOR=10;
  1286  15    7:D     1 VAR
  1287  15    7:D     1   THEREST,LEFTPART,SAVEBUFCOUNT: PTRTYPE;
  1288  15    7:D     4   CLEARED,WARNED,OK,NOTEXTYET,EXITPROMPT,FIRSTLINE: BOOLEAN;
  1289  15    7:D    10   SPACES,LMOVE,X,LINE,EOLDIST,RJUST: INTEGER;
  1290  15    7:D    16   CONTEXT: PACKED ARRAY [0..MAXSTRING] OF CHAR;
  1291  15    7:D    80 
  1292  15   16:D     1 PROCEDURE SLAMRIGHT;
  1293  15   16:D     1 (* Move (slam) the portion of the EBUF^ to the right of (and including)
  1294  15   16:D     1    the cursor so that the last NUL in the file (EBUF^[BUFCOUNT]) is now at
  1295  15   16:D     1    EBUF^[BUFSIZE].  THEREST points to the beginning of the right-justified
  1296  15   16:D     1    text. *)
  1297  15   16:0     0 BEGIN
  1298  15   16:1     0   GETLEADING;
  1299  15   16:1     3   THEREST:=BUFSIZE-(BUFCOUNT-CURSOR);
  1300  15   16:1    11   LMOVE:=BUFCOUNT-CURSOR+1;
  1301  15   16:1    19   MOVERIGHT(EBUF^[CURSOR],EBUF^[THEREST],LMOVE);
  1302  15   16:1    32   GETLEADING; (* Set blanks *)
  1303  15   16:1    35   IF THEREST-CURSOR<MAXSTRING THEN
  1304  15   16:2    44     BEGIN
  1305  15   16:3    44       ERROR('No room to insert.',NONFATAL);
  1306  15   16:3    69       SHOWCURSOR;
  1307  15   16:3    72       NEXTCOMMAND;
  1308  15   16:3    74       EXIT(INSERTIT)
  1309  15   16:2    78     END;
  1310  15   16:2    78   (* Optional indentation *)
  1311  15   16:1    78   EBUF^[THEREST-2]:=CHR(DLE); EBUF^[THEREST-1]:=CHR(BLANKS+32);
  1312  15   16:0    98 END;
  1313  15   16:0   110 
  1314  15   17:D     1 PROCEDURE WRAPUP;
  1315  15   17:D     1 (* Given the new value of the cursor (one past the last valid character
  1316  15   17:D     1    inserted into the buffer), put back together the two halves of the 
  1317  15   17:D     1    buffer.  Then, to polish it off, update the screen so that the rest of
  1318  15   17:D     1    the editor can cope *)
  1319  15   17:D     1 VAR PTR: PTRTYPE;
  1320  15   17:D     2     LNGTH: INTEGER;
  1321  15   17:0     0 BEGIN
  1322  15   17:1     0   WITH PAGEZERO DO 
  1323  15   17:2     0     IF NOTEXTYET AND (NOT FIRSTLINE) AND 
  1324  15   17:2     8        ((NOT FILLING) OR AUTOINDENT) AND (CH<>CHR(ESC))
  1325  15   17:2    22     THEN (* We want the blanks before THEREST *)
  1326  15   17:3    25       BEGIN
  1327  15   17:4    25 	BUFCOUNT:=BUFCOUNT+2;
  1328  15   17:4    30 	THEREST:=THEREST-2; LMOVE:=LMOVE+2;
  1329  15   17:4    46 	CURSOR:=SCAN(-MAXCHAR,=CHR(EOL),EBUF^[CURSOR-1])+CURSOR;
  1330  15   17:3    64       END;
  1331  15   17:1    64   MOVELEFT(EBUF^[THEREST],EBUF^[CURSOR],LMOVE);
  1332  15   17:1    77   READJUST(LEFTPART+1,CURSOR-(LEFTPART+1));
  1333  15   17:1    92   BUFCOUNT:=BUFCOUNT+CURSOR-(LEFTPART+1); 
  1334  15   17:1   103   WITH PAGEZERO DO
  1335  15   17:2   103     IF FILLING AND NOT AUTOINDENT AND (CH=CHR(ETX)) THEN
  1336  15   17:3   119       BEGIN THEFIXER(CURSOR,1,FALSE); FIRSTLINE:=FALSE; FINDXY(X,LINE) END;
  1337  15   17:1   138   UPSCREEN(FIRSTLINE,EXITPROMPT OR (CH=CHR(ESC)),LINE);
  1338  15   17:1   156   GETLEADING;
  1339  15   17:1   159   CURSOR:=MAX(CURSOR,STUFFSTART);
  1340  15   17:1   168   LASTPAT:=LEFTPART+1;
  1341  15   17:1   175   COPYOK:=TRUE; COPYSTART:=LASTPAT; COPYLENGTH:=CURSOR-LASTPAT;
  1342  15   17:1   189   NEXTCOMMAND
  1343  15   17:0   189 END;
  1344  15   17:0   204 
  1345  15   18:D     3 FUNCTION CHECK(VALUE:INTEGER): BOOLEAN;
  1346  15   18:D     4   (* VALUE is the potential value of the cursor.  If it is not in legal
  1347  15   18:D     4      range then CHECK is false.  This function also warns the user if
  1348  15   18:D     4      s/he is getting too close to overflowing the buffer *)
  1349  15   18:0     0 BEGIN
  1350  15   18:1     0   CHECK:=TRUE;
  1351  15   18:1     3   IF VALUE<=LEFTPART THEN
  1352  15   18:2    10     BEGIN
  1353  15   18:3    10       OK:=FALSE;  CHECK:=FALSE;
  1354  15   18:3    17       ERROR('No insertion to back over.',NONFATAL); PROMPT;
  1355  15   18:3    53       GOTOXY(X,LINE)
  1356  15   18:2    62     END
  1357  15   18:1    62   ELSE
  1358  15   18:2    64     IF VALUE>=THEREST-MAXCHAR THEN
  1359  15   18:3    75       BEGIN
  1360  15   18:4    75 	IF NOT WARNED THEN
  1361  15   18:5    81 	  BEGIN
  1362  15   18:6    81 	    ERROR('Please finish up the insertion',NONFATAL); PROMPT;
  1363  15   18:6   121 	    GOTOXY(X,LINE);
  1364  15   18:6   130 	    WARNED:=TRUE
  1365  15   18:5   130 	  END;
  1366  15   18:4   134 	IF VALUE>THEREST-FUDGEFACTOR THEN
  1367  15   18:5   143 	  BEGIN
  1368  15   18:6   143 	    ERROR('Buffer Overflow!!!!',NONFATAL);
  1369  15   18:6   169 	    WRAPUP;
  1370  15   18:6   171 	    EXIT(INSERTIT);
  1371  15   18:5   175 	  END
  1372  15   18:3   175       END
  1373  15   18:0   175 END;
  1374  15   18:0   188 
  1375  15   19:D     1 PROCEDURE SPACEOVER;
  1376  15   19:D     1 (* This procedure handles spaces and tabs inserted into the buffer *)
  1377  15   19:0     0 BEGIN
  1378  15   19:1     0   IF CH=CHR(HT) THEN SPACES:=8-X+ORD(ODD(X) AND ODD(248)) ELSE SPACES:=1;
  1379  15   19:1    27   IF CHECK(CURSOR+SPACES) THEN
  1380  15   19:2    38     BEGIN
  1381  15   19:3    38       FILLCHAR(EBUF^[CURSOR],SPACES,' ');
  1382  15   19:3    47       CURSOR:=CURSOR+SPACES
  1383  15   19:2    48     END
  1384  15   19:0    54 END;
  1385  15   19:0    66 
  1386  15   20:D     1 PROCEDURE FIXUP; FORWARD;
  1387  15   20:D     1 
  1388  15   21:D     1 PROCEDURE ENDLINE;
  1389  15   21:D     1 (* First, if there was no text inserted on the current line, then convert
  1390  15   21:D     1    all of the spaces to blank compression codes.  Then insert an <EOL> into
  1391  15   21:D     1    the buffer followed by the appropriate number of spaces for the
  1392  15   21:D     1    indentation. *)
  1393  15   21:0     0 BEGIN
  1394  15   21:1     0   WITH PAGEZERO DO
  1395  15   21:2     0     BEGIN
  1396  15   21:3     0       IF NOTEXTYET THEN FIXUP;
  1397  15   21:3     7       EBUF^[CURSOR]:=CHR(EOL);
  1398  15   21:3    12       IF AUTOINDENT THEN GETLEADING
  1399  15   21:3    17       ELSE
  1400  15   21:4    22 	IF FILLING THEN
  1401  15   21:5    27 	  BEGIN
  1402  15   21:6    27 	    GETLEADING;
  1403  15   21:6    30 	    IF EBUF^[STUFFSTART]=CHR(EOL) THEN (* Empty line *)
  1404  15   21:7    38 	      BLANKS:=PARAMARGIN
  1405  15   21:6    38 	    ELSE BLANKS:=LMARGIN
  1406  15   21:5    45 	  END
  1407  15   21:4    50 	ELSE BLANKS:=0; 
  1408  15   21:3    55       IF CHECK(CURSOR+BLANKS+1) THEN
  1409  15   21:4    66 	BEGIN
  1410  15   21:5    66 	  FILLCHAR(EBUF^[CURSOR+1],BLANKS,' ');
  1411  15   21:5    75 	  CURSOR:=CURSOR+BLANKS+1
  1412  15   21:4    78 	END;
  1413  15   21:3    82       NOTEXTYET:=TRUE;
  1414  15   21:2    86     END;
  1415  15   21:0    86 END;
  1416  15   21:0    98 
  1417  15   22:D     1 PROCEDURE BACKUP;
  1418  15   22:D     1 (* If the CH is a backspace then decrement cursor by 1.  If this would
  1419  15   22:D     1    result in backing over an <EOL> or a blank compression code, then fall
  1420  15   22:D     1    into the code for a <DEL> (also changing the CH to <DEL> for communication
  1421  15   22:D     1    to the outer block)  *)
  1422  15   22:D     1 VAR PTR: PTRTYPE;
  1423  15   22:0     0 BEGIN
  1424  15   22:1     0   IF CH=CHR(DC1) THEN
  1425  15   22:2     5     BEGIN GETLEADING; IF CHECK(LINESTART) THEN CURSOR:=LINESTART END
  1426  15   22:1    18   ELSE
  1427  15   22:2    20     IF (CH=CHR(BS)) AND
  1428  15   22:2    25        NOT( (EBUF^[CURSOR-2]=CHR(DLE)) OR (EBUF^[CURSOR-1]=CHR(EOL)) ) THEN
  1429  15   22:3    46       BEGIN
  1430  15   22:4    46 	IF CURSOR<LEFTPART+2 THEN OK:=FALSE ELSE CURSOR:=CURSOR-1;
  1431  15   22:3    66       END
  1432  15   22:2    66     ELSE
  1433  15   22:3    68       BEGIN (* A <DEL> or equivalent *)
  1434  15   22:4    68 	CH:=CHR(DEL); (* Tell the CRT driver that the line has changed *)
  1435  15   22:4    73 	GETLEADING;
  1436  15   22:4    76 	IF CHECK(LINESTART-1) THEN CURSOR:=LINESTART-1;
  1437  15   22:4    90 	NOTEXTYET:=FALSE; (* thank you shawn! *)
  1438  15   22:3    94       END
  1439  15   22:0    94 END;
  1440  15   22:0   106 
  1441  15   20:D     1 PROCEDURE FIXUP;
  1442  15   20:D     1 (* Convert the indentation spaces into blank compression codes, and move
  1443  15   20:D     1    the current line around accordingly *)
  1444  15   20:0     0 BEGIN
  1445  15   20:0     0   (* First compress the current line *)
  1446  15   20:1     0   EBUF^[CURSOR]:=CHR(EOL); (* Fool Getleading *)
  1447  15   20:1     5   GETLEADING;
  1448  15   20:1     8   IF BYTES >= 2 THEN (* OK to put in <DLE> # as it stands *)
  1449  15   20:2    13     MOVELEFT(EBUF^[STUFFSTART],EBUF^[LINESTART+2],CURSOR-STUFFSTART)
  1450  15   20:1    26   ELSE
  1451  15   20:2    28     IF CHECK(CURSOR+2-BYTES) THEN
  1452  15   20:3    39       MOVERIGHT(EBUF^[STUFFSTART],EBUF^[STUFFSTART+2-BYTES],CURSOR-STUFFSTART)
  1453  15   20:2    54     ELSE BEGIN OK:=FALSE; EXIT(FIXUP) END;
  1454  15   20:1    64   CURSOR:=CURSOR-(BYTES-2);
  1455  15   20:1    71   EBUF^[LINESTART]:=CHR(DLE); EBUF^[LINESTART+1]:=CHR(32+BLANKS);
  1456  15   20:0    85 END;
  1457  15   20:0    98 
  1458  15   23:D     1 PROCEDURE INSERTCH;
  1459  15   23:D     1   (* This procedure inserts a single character into the buffer. It also
  1460  15   23:D     1      handles all of the control codes (EOL,BS,DEL) and buffer over- and
  1461  15   23:D     1      under- flow conditions.  INSERTCH is called by the CRT handler *)
  1462  15   23:0     0 BEGIN
  1463  15   23:1     0   REPEAT
  1464  15   23:2     0   OK:=TRUE; (* No errors that invalidate the current character have occured *)
  1465  15   23:2     4   CH:=GETCH;
  1466  15   23:2    11   IF MAPTOCOMMAND(CH)=LEFT THEN CH:=CHR(BS);
  1467  15   23:2    26   IF ORD(CH) IN [SP,HT,EOL,BS,DEL,ETX,ESC,DC1] THEN
  1468  15   23:3    59     BEGIN
  1469  15   23:3    59       (* <etx> and <esc> are handled in the body of insertit *)
  1470  15   23:4    59       IF ORD(CH) IN [SP,HT] THEN SPACEOVER
  1471  15   23:4    72       ELSE
  1472  15   23:5    76 	IF ORD(CH)=EOL THEN ENDLINE
  1473  15   23:5    81 	ELSE
  1474  15   23:6    85 	  IF ORD(CH) IN [DC1,BS,DEL] THEN BACKUP;
  1475  15   23:3   109     END
  1476  15   23:2   109   ELSE
  1477  15   23:3   111     BEGIN (* A character to insert! *)
  1478  15   23:4   111       IF (CH<'!') OR (CH>'~') THEN CH:='?'; (* No non-printing characters *)
  1479  15   23:4   123       IF NOTEXTYET THEN FIXUP;
  1480  15   23:4   130       IF CHECK(CURSOR+1) AND OK THEN
  1481  15   23:5   143 	BEGIN
  1482  15   23:6   143 	  NOTEXTYET:=FALSE;
  1483  15   23:6   147 	  EBUF^[CURSOR]:=CH;
  1484  15   23:6   152 	  CURSOR:=CURSOR+1
  1485  15   23:5   153 	END;
  1486  15   23:3   157     END;
  1487  15   23:1   157  UNTIL OK;
  1488  15   23:0   162 END;
  1489  15   23:0   176 
  1490  15   24:D     1 PROCEDURE POPDOWN;
  1491  15   24:D     1 (* Displays CONTEXT, doing an implied scrollup if nec. *)
  1492  15   24:0     0 BEGIN
  1493  15   24:1     0   IF CLEARED THEN ERASETOEOL(X,LINE)
  1494  15   24:1    11   ELSE BEGIN CLEARED:=TRUE; ERASEOS(X,LINE) END;
  1495  15   24:1    29   GOTOXY(RJUST,LINE);
  1496  15   24:1    38   ERASETOEOL(RJUST,LINE);
  1497  15   24:1    47   WRITE(CHR(LF));
  1498  15   24:1    55   IF LINE=SCREENHEIGHT THEN BEGIN EXITPROMPT:=TRUE; LINE:=SCREENHEIGHT-1 END;
  1499  15   24:1    72   WRITE(CONTEXT:EOLDIST);
  1500  15   24:1    87   FIRSTLINE:=FALSE; (* Says that the whole screen has been affected. *)
  1501  15   24:0    91 END;
  1502  15   24:0   104 
  1503  15   25:D     1 PROCEDURE WRITESP(CH:CHAR;HOWMANY:INTEGER);
  1504  15   25:0     0 BEGIN
  1505  15   25:1     0   IF X+HOWMANY<=SCREENWIDTH THEN WRITE(CH:HOWMANY);
  1506  15   25:1    17   IF X+HOWMANY>=SCREENWIDTH THEN
  1507  15   25:2    26     BEGIN
  1508  15   25:3    26       GOTOXY(SCREENWIDTH,LINE);
  1509  15   25:3    33       IF X+HOWMANY>SCREENWIDTH THEN
  1510  15   25:4    42 	BEGIN WRITE('!'); GOTOXY(SCREENWIDTH,LINE) END
  1511  15   25:2    57     END;
  1512  15   25:1    57   X:=MIN(SCREENWIDTH,X+HOWMANY)
  1513  15   25:0    63 END;
  1514  15   25:0    84 
  1515  15   26:D     1 PROCEDURE CLEANSCREEN;
  1516  15   26:D     1 (* Code to, if possible, only erase the line, otherwise clear
  1517  15   26:D     1    the screen.  Then call popdown *)
  1518  15   26:0     0 BEGIN
  1519  15   26:1     0   FIRSTLINE:=FALSE;
  1520  15   26:1     4   IF CLEARED THEN
  1521  15   26:2     9     BEGIN
  1522  15   26:3     9       IF X<SCREENWIDTH THEN ERASETOEOL(X,LINE)
  1523  15   26:2    22     END
  1524  15   26:1    25   ELSE
  1525  15   26:2    27     BEGIN
  1526  15   26:3    27       CLEARED:=TRUE; ERASEOS(X,LINE);
  1527  15   26:2    40     END;
  1528  15   26:1    40   LINE:=LINE+1;
  1529  15   26:1    48   IF LINE>SCREENHEIGHT THEN
  1530  15   26:2    55     BEGIN
  1531  15   26:3    55       LINE:=LINE-1;
  1532  15   26:3    63       WRITELN;
  1533  15   26:3    69       EXITPROMPT:=TRUE
  1534  15   26:2    69     END;
  1535  15   26:1    73   IF EOLDIST<>0 THEN POPDOWN
  1536  15   26:0    80 END;
  1537  15   26:0    94 
  1538  15   27:D     1 PROCEDURE POPOV;
  1539  15   27:D     1 (* When in filling mode, this procedure is called when a line is overflowed
  1540  15   27:D     1    (X >= rightmargin).  The word is scanned off and "popped" down to the 
  1541  15   27:D     1    next line. *)
  1542  15   27:D     1 VAR
  1543  15   27:D     1   WLENGTH: INTEGER;
  1544  15   27:D     2   SAVE,PTR: PTRTYPE;
  1545  15   27:D     4   WORD: PACKED ARRAY [0..MAXSW] OF CHAR;
  1546  15   27:0     0 BEGIN
  1547  15   27:1     0   IF NOTEXTYET THEN FIXUP;
  1548  15   27:1     7   PTR:=MAX(SCAN(-MAXCHAR,='-',EBUF^[CURSOR-1]),
  1549  15   27:1    21 	   SCAN(-MAXCHAR,=' ',EBUF^[CURSOR-1]))+CURSOR;
  1550  15   27:1    44   WLENGTH:=CURSOR-PTR;
  1551  15   27:1    49   WITH PAGEZERO DO IF WLENGTH>=RMARGIN-LMARGIN THEN
  1552  15   27:3    60     BEGIN
  1553  15   27:4    60       WRITESP(CH,1);
  1554  15   27:4    64       EXIT(POPOV)
  1555  15   27:3    68     END;
  1556  15   27:1    68   IF CH='-' THEN WRITE('-');
  1557  15   27:1    81   GOTOXY(X-WLENGTH+1,LINE);
  1558  15   27:1    94   ERASETOEOL(X-WLENGTH+1,LINE);
  1559  15   27:1   107   MOVERIGHT(EBUF^[PTR],EBUF^[PTR+3],WLENGTH);
  1560  15   27:1   118   MOVELEFT(EBUF^[PTR+3],WORD,WLENGTH);
  1561  15   27:1   129   CURSOR:=CURSOR+3;
  1562  15   27:1   134   EBUF^[PTR]:=CHR(EOL);
  1563  15   27:1   139   EBUF^[PTR+1]:=CHR(DLE);
  1564  15   27:1   146   WITH PAGEZERO DO IF AUTOINDENT THEN
  1565  15   27:3   151     BEGIN
  1566  15   27:4   151       SAVE:=CURSOR; (* Set blanks to the indentation of the line above *)
  1567  15   27:4   154       CURSOR:=PTR;
  1568  15   27:4   157       GETLEADING;
  1569  15   27:4   160       CURSOR:=SAVE
  1570  15   27:3   160     END
  1571  15   27:2   163   ELSE
  1572  15   27:3   165     BLANKS:=LMARGIN;
  1573  15   27:1   170   EBUF^[PTR+2]:=CHR(BLANKS+32);
  1574  15   27:1   179   CLEANSCREEN;
  1575  15   27:1   181   X:=BLANKS;
  1576  15   27:1   185   GOTOXY(X,LINE); WRITE(WORD:WLENGTH);
  1577  15   27:1   204   X:=X+WLENGTH;
  1578  15   27:1   212   NOTEXTYET:=FALSE
  1579  15   27:0   212 END;
  1580  15   27:0   228 
  1581  15    7:0     0 BEGIN (* INSERT *)
  1582  15    7:1     0   CLEARED:=FALSE;
  1583  15    7:1     3   EOLDIST:=SCAN(MAXCHAR,=CHR(EOL),EBUF^[CURSOR]);
  1584  15    7:1    16   MOVELEFT(EBUF^[CURSOR],CONTEXT[0],EOLDIST);
  1585  15    7:1    25   RJUST:=SCREENWIDTH-EOLDIST;
  1586  15    7:1    30   SLAMRIGHT;
  1587  15    7:1    32   SAVEBUFCOUNT:=BUFCOUNT;
  1588  15    7:1    35   PROMPTLINE:=INSERTPROMPT;
  1589  15    7:1    43   PROMPT;
  1590  15    7:1    46   EXITPROMPT:=FALSE;  NEEDPROMPT:=TRUE;
  1591  15    7:1    53   LEFTPART:=CURSOR-1;
  1592  15    7:1    58   NOTEXTYET:=FALSE;
  1593  15    7:1    61   FINDXY(X,LINE);  GOTOXY(X,LINE);
  1594  15    7:1    73   ERASETOEOL(X,LINE);
  1595  15    7:1    78   FIRSTLINE:=TRUE;
  1596  15    7:1    81   IF EOLDIST<>0 THEN (* A context needs to be displayed *)
  1597  15    7:2    86     IF RJUST>X THEN (* and it will fit on the current line ... *)
  1598  15    7:3    91       BEGIN
  1599  15    7:4    91 	GOTOXY(RJUST,LINE); WRITE(CONTEXT:EOLDIST); GOTOXY(X,LINE)
  1600  15    7:3   113       END
  1601  15    7:2   113     ELSE (* and it won't fit on the current line *)
  1602  15    7:3   115       BEGIN 
  1603  15    7:4   115 	FIRSTLINE:=FALSE;
  1604  15    7:4   118 	ERASEOS(X,LINE);(* Clear the screen *)
  1605  15    7:4   123 	WRITELN;
  1606  15    7:4   129 	IF LINE=SCREENHEIGHT THEN
  1607  15    7:5   134 	  BEGIN LINE:=SCREENHEIGHT-1; EXITPROMPT:=TRUE END;
  1608  15    7:4   142 	GOTOXY(RJUST,LINE+1); WRITE(CONTEXT:EOLDIST); GOTOXY(X,LINE)
  1609  15    7:3   166       END;
  1610  15    7:1   166   REPEAT
  1611  15    7:2   166     INSERTCH;
  1612  15    7:2   168     IF NOT (ORD(CH) IN [EOL,ETX,ESC,DEL,DC1]) THEN
  1613  15    7:3   196       BEGIN
  1614  15    7:4   196 	IF TRANSLATE[CH]=LEFT THEN
  1615  15    7:5   207 	  BEGIN IF X<=SCREENWIDTH THEN WRITE(CHR(BS),' ',CHR(BS)); X:=X-1 END
  1616  15    7:4   245 	ELSE
  1617  15    7:5   247 	  IF CH=CHR(HT) THEN WRITESP(' ',SPACES)
  1618  15    7:5   254 	  ELSE
  1619  15    7:6   258 	    IF PAGEZERO.FILLING AND (X+1>=PAGEZERO.RMARGIN) THEN POPOV
  1620  15    7:6   271 	    ELSE WRITESP(CH,1);
  1621  15    7:4   279 	IF NOT PAGEZERO.FILLING AND (X=SCREENWIDTH-8) AND (CH<>CHR(BS))
  1622  15    7:4   294 	  THEN WRITE(CHR(BELL));
  1623  15    7:4   305 	IF (EOLDIST<>0) AND
  1624  15    7:4   308 	   (X>=RJUST) AND FIRSTLINE THEN  (*ran into context *)
  1625  15    7:5   316 	  BEGIN
  1626  15    7:6   316 	    POPDOWN;
  1627  15    7:6   318 	    GOTOXY(X,LINE)
  1628  15    7:5   323 	  END;
  1629  15    7:3   323       END
  1630  15    7:2   323     ELSE (* ch in [eol,etx,esc,del,dc1] *)
  1631  15    7:3   325       BEGIN
  1632  15    7:4   325 	IF CH=CHR(EOL) THEN
  1633  15    7:5   330 	  BEGIN
  1634  15    7:6   330 	    CLEANSCREEN;
  1635  15    7:6   332 	    X:=BLANKS;
  1636  15    7:6   335 	    GOTOXY(X,LINE);
  1637  15    7:5   340 	  END
  1638  15    7:4   340 	ELSE
  1639  15    7:5   342 	  IF CH=CHR(DEL) THEN
  1640  15    7:6   349 	    BEGIN
  1641  15    7:7   349 	      IF LINE<=1 THEN  (* Rubbed out all of what was on the screen *)
  1642  15    7:8   354 		BEGIN
  1643  15    7:9   354 		  BUFCOUNT:=CURSOR+1;
  1644  15    7:9   359 		  EBUF^[CURSOR]:=CHR(EOL);
  1645  15    7:9   364 		  CENTERCURSOR(LINE,MIDDLE,TRUE);
  1646  15    7:9   373 		  IF EOLDIST<>0 THEN POPDOWN;
  1647  15    7:9   380 		  IF EXITPROMPT THEN BEGIN PROMPT; EXITPROMPT:=FALSE END
  1648  15    7:8   389 		END
  1649  15    7:7   389 	      ELSE
  1650  15    7:8   391 		BEGIN GOTOXY(0,LINE); CLEARED:=FALSE;
  1651  15    7:9   399 		      ERASETOEOL(0,LINE); LINE:=LINE-1 END;
  1652  15    7:7   409 	      GETLEADING;
  1653  15    7:7   412 	      X:=BLANKS-BYTES+CURSOR-LINESTART;
  1654  15    7:7   421 	      GOTOXY(X,LINE)
  1655  15    7:6   426 	    END
  1656  15    7:5   426 	  ELSE
  1657  15    7:6   428 	    IF CH=CHR(DC1) THEN
  1658  15    7:7   433 	      BEGIN
  1659  15    7:8   433 		X:=0; GOTOXY(X,LINE); ERASETOEOL(X,LINE)
  1660  15    7:7   443 	      END;
  1661  15    7:3   446       END;
  1662  15    7:1   446   UNTIL CH IN [CHR(ETX),CHR(ESC)];
  1663  15    7:1   459   IF CH=CHR(ESC) THEN CURSOR:=LEFTPART+1;
  1664  15    7:1   471   BUFCOUNT:=SAVEBUFCOUNT;
  1665  15    7:1   474   WRAPUP;
  1666  15    7:0   476 END;
  1667  15    7:0   492 
  1668  15    7:0   492 (* --- MOVEIT    --- *)
  1669  15   28:D     1 PROCEDURE MOVEIT;
  1670  15   28:D     1 VAR
  1671  15   28:D     1   SCROLLMARK,X,LINE,I: INTEGER;
  1672  15   28:D     5   EXITPROMPT: BOOLEAN; (* Prompt after leaving Moveit! *)
  1673  15   28:D     6   OLDLINE,OLDX: INTEGER;
  1674  15   28:D     8   NEWDIST,DIST: INTEGER;
  1675  15   28:D    10   DOFFSCREEN,ATEND,INREPLACE,INDELETE: BOOLEAN;
  1676  15   28:D    14   PTR,ANCHOR,OLDCURSOR: PTRTYPE;
  1677  15   28:D    17 
  1678  15   29:D     1 PROCEDURE SCROLLUP(BOTTOMLINE:PTRTYPE; HOWMANY: INTEGER); 
  1679  15   29:D     3 (* bottomline is the "linestart" of the line to be scrolled up *)
  1680  15   29:D     3 VAR
  1681  15   29:D     3   PTR: PTRTYPE;
  1682  15   29:D     4   I: INTEGER;
  1683  15   29:0     0 BEGIN
  1684  15   29:0     0   (* DISPLAY THE NEXT LINE ON THE BOTTOM OF THE SCREEN *)
  1685  15   29:1     0   I:=0;
  1686  15   29:1     3   PTR:=SCAN(MAXCHAR,=CHR(EOL),EBUF^[LINE1PTR])+LINE1PTR+1;
  1687  15   29:1    24   WHILE (I<HOWMANY) AND (PTR<BUFCOUNT) DO
  1688  15   29:2    33     BEGIN
  1689  15   29:3    33       LINE1PTR:=PTR; PTR:=SCAN(MAXCHAR,=CHR(EOL),EBUF^[PTR])+PTR+1;
  1690  15   29:3    54       I:=I+1
  1691  15   29:2    55     END;
  1692  15   29:1    61   I:=0;
  1693  15   29:1    64   GOTOXY(0,SCREENHEIGHT);
  1694  15   29:1    69   REPEAT
  1695  15   29:2    69     I:=I+1;
  1696  15   29:2    74     BLANKS:=LEADBLANKS(BOTTOMLINE,BYTES);
  1697  15   29:2    84     WRITE(CHR(LF));
  1698  15   29:2    92     LINEOUT(BOTTOMLINE,BYTES,BLANKS,SCREENHEIGHT);
  1699  15   29:2   100     LINE:=LINE-1;
  1700  15   29:1   108   UNTIL (I>=HOWMANY) OR (BOTTOMLINE>=BUFCOUNT-1);
  1701  15   29:1   119   EXITPROMPT:=TRUE;
  1702  15   29:0   123 END(* SCROLLUP *);
  1703  15   29:0   140 
  1704  15   30:D     1 PROCEDURE CLEAR(X1,Y1,X2,Y2: INTEGER); FORWARD;
  1705  15   30:D     5 
  1706  15   31:D     1 PROCEDURE CENTER;
  1707  15   31:0     0 BEGIN
  1708  15   31:1     0   IF INDELETE THEN
  1709  15   31:2     5     BEGIN
  1710  15   31:3     5       IF LINE>=SCREENHEIGHT THEN
  1711  15   31:4    12 	BEGIN
  1712  15   31:5    12 	  CENTERCURSOR(LINE,2,TRUE);
  1713  15   31:5    20 	  IF ABS(CURSOR-ANCHOR) > ABS(DIST) THEN CLEAR(0,1,MAX(X-1,0),LINE)
  1714  15   31:4    49 	END
  1715  15   31:3    51       ELSE
  1716  15   31:4    53 	BEGIN
  1717  15   31:5    53 	  CENTERCURSOR(LINE,SCREENHEIGHT-1,TRUE);
  1718  15   31:5    63 	  GOTOXY(X,LINE);
  1719  15   31:5    72 	  IF ABS(CURSOR-ANCHOR) > ABS(DIST) THEN WRITE(CHR(11))
  1720  15   31:4    93 	END;
  1721  15   31:3    93       DOFFSCREEN:=TRUE;
  1722  15   31:2    97     END
  1723  15   31:1    97   ELSE
  1724  15   31:2    99     IF (COMMAND=PARAC) AND ((DIRECTION='<') OR (LINE MOD SCREENHEIGHT=OLDLINE))
  1725  15   31:2   115       THEN CENTERCURSOR(LINE,OLDLINE,TRUE)
  1726  15   31:2   125       ELSE CENTERCURSOR(LINE,MIDDLE,TRUE);
  1727  15   31:1   140   IF EXITPROMPT AND (COMMAND<>QUITC) THEN
  1728  15   31:2   149     BEGIN
  1729  15   31:3   149       PROMPT; EXITPROMPT:=FALSE
  1730  15   31:2   152     END;
  1731  15   31:1   156   OLDLINE:=LINE; OLDX:=X;
  1732  15   31:0   168 END;
  1733  15   31:0   180 
  1734  15   32:D     1 PROCEDURE UPMOVE;
  1735  15   32:D     1 VAR I:INTEGER;
  1736  15   32:0     0 BEGIN
  1737  15   32:1     0   I:=1;
  1738  15   32:1     3   GETLEADING;
  1739  15   32:1     6   (* FIND THE LINE FIRST *)
  1740  15   32:1     6   WHILE (I<=REPEATFACTOR) AND (LINESTART>1) DO
  1741  15   32:2    15     BEGIN
  1742  15   32:3    15       CURSOR:=LINESTART-1; (* LAST CHAR OF LINE ABOVE *)
  1743  15   32:3    20       GETLEADING;
  1744  15   32:3    23       LINE:=LINE-1;  I:=I+1;
  1745  15   32:2    36     END;
  1746  15   32:2    38   (* If possible set the cursor at the same x coord we came from.  Otherwise,
  1747  15   32:2    38      set it either to the beginning of the buffer, the beginning of text
  1748  15   32:2    38      on that line, or the end of the text on that line *)
  1749  15   32:1    38   CURSOR:=
  1750  15   32:1    38 	   MAX(1,     (* The beginning of the buffer *)
  1751  15   32:1    39 	       MAX(STUFFSTART,  (* The beginning of the text *)
  1752  15   32:1    40 		   MIN(X-BLANKS+BYTES+LINESTART, (* same col *)
  1753  15   32:1    49 		       SCAN(MAXCHAR,=CHR(EOL),EBUF^[CURSOR])+CURSOR (* eol *)
  1754  15   32:1    60 		      )
  1755  15   32:1    62 		   )
  1756  15   32:1    67 	       );
  1757  15   32:1    79   IF LINE<1 THEN CENTER;
  1758  15   32:0    88 END(* UPALINE *);
  1759  15   32:0   102 
  1760  15   33:D     1 PROCEDURE DOWNMOVE;
  1761  15   33:D     1 VAR 
  1762  15   33:D     1   I: INTEGER;
  1763  15   33:D     2   NEXTEOL: PTRTYPE;
  1764  15   33:0     0 BEGIN
  1765  15   33:1     0   I:=1;
  1766  15   33:1     3   NEXTEOL:=SCAN(MAXCHAR,=CHR(EOL),EBUF^[CURSOR])+CURSOR;
  1767  15   33:1    18   WHILE (NEXTEOL<BUFCOUNT-1) AND (I<=REPEATFACTOR) DO
  1768  15   33:2    29     BEGIN
  1769  15   33:3    29       CURSOR:=NEXTEOL+1;
  1770  15   33:3    34       NEXTEOL:=SCAN(MAXCHAR,=CHR(EOL),EBUF^[CURSOR])+CURSOR;
  1771  15   33:3    49       IF NEXTEOL<BUFCOUNT THEN
  1772  15   33:4    54 	BEGIN
  1773  15   33:5    54 	  LINE:=LINE+1;
  1774  15   33:5    62 	  I:=I+1;
  1775  15   33:5    67 	  IF LINE=SCREENHEIGHT+1 THEN
  1776  15   33:6    76 	    BEGIN
  1777  15   33:7    76 	      SCROLLMARK:=CURSOR;
  1778  15   33:6    80 	    END;
  1779  15   33:4    80 	END;
  1780  15   33:2    80     END;
  1781  15   33:1    82   IF LINE>SCREENHEIGHT THEN
  1782  15   33:2    89     IF (LINE-SCREENHEIGHT>=SCREENHEIGHT) OR (INDELETE) THEN
  1783  15   33:3   102       CENTER
  1784  15   33:2   102     ELSE
  1785  15   33:3   106       SCROLLUP(SCROLLMARK,LINE-SCREENHEIGHT);
  1786  15   33:1   116   GETLEADING;
  1787  15   33:1   119   (* If possible set the cursor at the same x coord we came from.  Otherwise,
  1788  15   33:1   119      set it either to the end of the buffer, the beginning of text
  1789  15   33:1   119      on that line, or the end of the text on that line *)
  1790  15   33:1   119   CURSOR:=MIN(BUFCOUNT-1,      (* End of the buffer *)
  1791  15   33:1   122 		 MAX(STUFFSTART,    (* Not in the indentation *)
  1792  15   33:1   123 		     MIN(X-BLANKS+BYTES+LINESTART (* Where it wants to be *)
  1793  15   33:1   130 			,SCAN(MAXCHAR,=CHR(EOL),EBUF^[CURSOR])+CURSOR 
  1794  15   33:1   143 			)
  1795  15   33:1   145 		     )
  1796  15   33:1   150 	      );
  1797  15   33:0   162 END(* DOWNMOVE *);
  1798  15   33:0   176 
  1799  15   34:D     1 PROCEDURE LEFTMOVE;
  1800  15   34:0     0 BEGIN
  1801  15   34:1     0   GETLEADING; (* SET LINESTART AND STUFFSTART *)
  1802  15   34:1     3   WHILE (STUFFSTART>CURSOR-REPEATFACTOR) AND (CURSOR>REPEATFACTOR) DO
  1803  15   34:2    14     BEGIN
  1804  15   34:3    14       REPEATFACTOR:=REPEATFACTOR-(CURSOR-STUFFSTART+1); (* CHARS MOVED OVER *)
  1805  15   34:3    23       IF EBUF^[CURSOR]=CHR(EOL) THEN CURSOR:=CURSOR-1;
  1806  15   34:3    36       CURSOR:=MAX(SCAN(-MAXCHAR,=CHR(EOL),EBUF^[CURSOR])+CURSOR,1);
  1807  15   34:3    58       LINE:=LINE-1;
  1808  15   34:3    66       GETLEADING; (* RESET LINESTART AND STUFFSTART *)
  1809  15   34:2    69     END;
  1810  15   34:1    71   CURSOR:=MAX(STUFFSTART,MAX(CURSOR-REPEATFACTOR,1));
  1811  15   34:1    88   IF LINE<1 THEN CENTER;
  1812  15   34:1    97   FINDXY(X,LINE);
  1813  15   34:0   106 END (* LEFTMOVE *);
  1814  15   34:0   120 
  1815  15   35:D     1 PROCEDURE RIGHTMOVE;
  1816  15   35:D     1 VAR
  1817  15   35:D     1   EOLPTR: PTRTYPE;
  1818  15   35:0     0 BEGIN
  1819  15   35:1     0   EOLPTR:=SCAN(MAXCHAR,=CHR(EOL),EBUF^[CURSOR])+CURSOR;
  1820  15   35:1    15   WHILE (EOLPTR<CURSOR+REPEATFACTOR) AND (EOLPTR<BUFCOUNT-1) DO
  1821  15   35:2    28     BEGIN
  1822  15   35:3    28       REPEATFACTOR:=REPEATFACTOR-(EOLPTR-CURSOR+1);
  1823  15   35:3    37       CURSOR:=EOLPTR+1; (* BEGINNING OF THE LINE BELOW *)
  1824  15   35:3    42       GETLEADING;
  1825  15   35:3    45       CURSOR:=STUFFSTART;
  1826  15   35:3    48       LINE:=LINE+1;
  1827  15   35:3    56       IF LINE=SCREENHEIGHT+1 THEN SCROLLMARK:=LINESTART;
  1828  15   35:3    69       EOLPTR:=SCAN(MAXCHAR,=CHR(EOL),EBUF^[CURSOR])+CURSOR
  1829  15   35:2    80     END;
  1830  15   35:1    86   IF LINE>SCREENHEIGHT THEN
  1831  15   35:2    93     IF (LINE-SCREENHEIGHT>=SCREENHEIGHT) OR (INDELETE) THEN
  1832  15   35:3   106       CENTER
  1833  15   35:2   106     ELSE
  1834  15   35:3   110       SCROLLUP(SCROLLMARK,LINE-SCREENHEIGHT);
  1835  15   35:1   120   CURSOR:=MIN(BUFCOUNT-1,CURSOR+REPEATFACTOR);
  1836  15   35:1   133   FINDXY(X,LINE);
  1837  15   35:0   142 END(* RIGHTMOVE *);
  1838  15   35:0   156 
  1839  15   36:D     1 PROCEDURE LINEMOVE(REPEATFACTOR: INTEGER);
  1840  15   36:D     2 VAR I: INTEGER;
  1841  15   36:0     0 BEGIN
  1842  15   36:1     0   I:=1;
  1843  15   36:1     3   IF DIRECTION='<' THEN
  1844  15   36:2     8     BEGIN
  1845  15   36:3     8       WHILE (I<=REPEATFACTOR) AND (CURSOR>1) DO 
  1846  15   36:4    17 	BEGIN
  1847  15   36:5    17 	  IF EBUF^[CURSOR]=CHR(EOL) THEN CURSOR:=CURSOR-1; (* NULL LINE CASE *)
  1848  15   36:5    30 	  CURSOR:=SCAN(-MAXCHAR,=CHR(EOL),EBUF^[CURSOR])+CURSOR; (* 1 UP *)
  1849  15   36:5    46 	  IF CURSOR>=1 THEN BEGIN LINE:=LINE-1; I:=I+1 END;
  1850  15   36:4    64 	END;
  1851  15   36:3    66       CURSOR:=MAX(1,CURSOR); (* BACK INTO REALITY *)
  1852  15   36:3    75       ATEND:= (CURSOR=1);
  1853  15   36:3    81       IF LINE<1 THEN CENTER
  1854  15   36:2    88     END
  1855  15   36:1    90   ELSE
  1856  15   36:2    92     BEGIN (* DIRECTION='>' *)
  1857  15   36:3    92       WHILE (I<=REPEATFACTOR) AND (CURSOR<BUFCOUNT-1) DO
  1858  15   36:4   103 	BEGIN
  1859  15   36:5   103 	  CURSOR:=SCAN(MAXCHAR,=CHR(EOL),EBUF^[CURSOR])+CURSOR+1; (*1 DOWN *)
  1860  15   36:5   120 	  IF CURSOR<BUFCOUNT THEN
  1861  15   36:6   125 	    BEGIN
  1862  15   36:7   125 	      I:=I+1; LINE:=LINE+1;
  1863  15   36:7   138 	      IF LINE=SCREENHEIGHT+1 THEN SCROLLMARK:=CURSOR;
  1864  15   36:6   151 	    END
  1865  15   36:4   151 	END;
  1866  15   36:3   153       ATEND:= (CURSOR>=BUFCOUNT-1);
  1867  15   36:3   161       IF LINE>SCREENHEIGHT THEN
  1868  15   36:4   168 	IF (LINE-SCREENHEIGHT>=SCREENHEIGHT) OR (COMMAND=PARAC)
  1869  15   36:4   178 	   OR INREPLACE OR INDELETE
  1870  15   36:4   183 	  THEN 
  1871  15   36:5   189 	    CENTER
  1872  15   36:4   189 	  ELSE SCROLLUP(SCROLLMARK,LINE-SCREENHEIGHT);
  1873  15   36:3   203       CURSOR:=MIN(CURSOR,BUFCOUNT-1)
  1874  15   36:2   207     END;
  1875  15   36:1   214   GETLEADING;
  1876  15   36:1   217   CURSOR:=STUFFSTART; (* FORCED TO BEGINNING OF STUFF *)
  1877  15   36:1   220   X:=BLANKS;
  1878  15   36:0   224 END(* LINEMOVE *);
  1879  15   36:0   240 
  1880  15   37:D     1 PROCEDURE JUMPBEGIN;
  1881  15   37:0     0 BEGIN
  1882  15   37:1     0   CURSOR:=1; CENTERCURSOR(TRASH,1,FALSE)
  1883  15   37:0     8 END;
  1884  15   37:0    24 
  1885  15   38:D     1 PROCEDURE JUMPEND;
  1886  15   38:0     0 BEGIN
  1887  15   38:1     0   CURSOR:=BUFCOUNT-1; CENTERCURSOR(TRASH,SCREENHEIGHT,FALSE)
  1888  15   38:0    10 END;
  1889  15   38:0    26 
  1890  15   39:D     1 PROCEDURE ADJUSTING;
  1891  15   39:D     1 LABEL 1;
  1892  15   39:D     1 TYPE
  1893  15   39:D     1   MODES=(RELATIVE,LEFTJ,RIGHTJ,CENTER);
  1894  15   39:D     1 VAR
  1895  15   39:D     1   LLENGTH,TDELTA,I: INTEGER;
  1896  15   39:D     4   SAVEDIR: CHAR;
  1897  15   39:D     5   MODE: MODES;
  1898  15   39:D     6 
  1899  15   40:D     1 PROCEDURE DOIT(DELTA:INTEGER);
  1900  15   40:D     2 VAR
  1901  15   40:D     2   EOLDIST: INTEGER;
  1902  15   40:D     3   T: PACKED ARRAY [0..MAXSTRING] OF CHAR;
  1903  15   40:0     0 BEGIN
  1904  15   40:1     0   GETLEADING; (* Set linestart, stuffstart, and blanks *)
  1905  15   40:1     3   IF BLANKS+DELTA<0 THEN DELTA:=-BLANKS;
  1906  15   40:1    14   IF (EBUF^[LINESTART]=CHR(DLE)) AND (STUFFSTART-LINESTART=2) THEN
  1907  15   40:2    28     X:=ORD(EBUF^[LINESTART+1])+DELTA-32
  1908  15   40:1    36   ELSE
  1909  15   40:2    43     BEGIN
  1910  15   40:3    43       IF STUFFSTART-LINESTART>2 THEN
  1911  15   40:4    50 	MOVELEFT(EBUF^[STUFFSTART],EBUF^[LINESTART+2],BUFCOUNT-STUFFSTART)
  1912  15   40:3    63       ELSE
  1913  15   40:4    65 	BEGIN
  1914  15   40:5    65 	  IF BUFCOUNT>BUFSIZE-100 THEN
  1915  15   40:6    72 	    BEGIN
  1916  15   40:7    72 	      ERROR('Buffer overflow',NONFATAL);
  1917  15   40:7    94 	      EXIT(ADJUSTING)
  1918  15   40:6    98 	    END
  1919  15   40:5    98 	  ELSE
  1920  15   40:6   100 	    MOVERIGHT(EBUF^[STUFFSTART],EBUF^[LINESTART+2],BUFCOUNT-STUFFSTART);
  1921  15   40:4   113 	END;
  1922  15   40:3   113       IF LINESTART+2<>STUFFSTART THEN
  1923  15   40:4   120 	BEGIN
  1924  15   40:5   120 	  READJUST(LINESTART,LINESTART+2-STUFFSTART);
  1925  15   40:5   129 	  BUFCOUNT:=BUFCOUNT+LINESTART+2-STUFFSTART;
  1926  15   40:4   138         END;
  1927  15   40:3   138       EBUF^[LINESTART]:=CHR(DLE);
  1928  15   40:3   143       X:=BLANKS+DELTA;
  1929  15   40:2   149     END;
  1930  15   40:1   149   EBUF^[LINESTART+1]:=CHR(X+32);
  1931  15   40:1   160   CURSOR:=LINESTART+2; GETLEADING;
  1932  15   40:1   168   GOTOXY(0,LINE); ERASETOEOL(0,LINE); (* erase the line *)
  1933  15   40:1   182   LINEOUT(LINESTART,BYTES,BLANKS,LINE); GOTOXY(X,LINE);
  1934  15   40:0   201 END(* DOIT *);
  1935  15   40:0   214 
  1936  15   39:0     0 BEGIN (* adjusting *)
  1937  15   39:1     0   WITH PAGEZERO DO
  1938  15   39:2     0     BEGIN
  1939  15   39:3     0       SAVEDIR:=DIRECTION; EXITPROMPT:=FALSE; INDELETE:=FALSE; LASTPAT:=CURSOR;
  1940  15   39:3    14       INREPLACE:=TRUE;
  1941  15   39:3    18       PROMPTLINE:=ADJUSTPROMPT;
  1942  15   39:3    26       PROMPT; NEEDPROMPT:=TRUE;
  1943  15   39:3    33       MODE:=RELATIVE;
  1944  15   39:3    36       SHOWCURSOR;
  1945  15   39:3    39       FINDXY(X,LINE);
  1946  15   39:3    48       TDELTA:=0;
  1947  15   39:3    51       REPEAT
  1948  15   39:4    51 	CH:=GETCH;
  1949  15   39:4    58 	COMMAND:=MAPTOCOMMAND(CH);
  1950  15   39:4    66 	INFINITY:=FALSE;
  1951  15   39:4    70 	IF COMMAND=SLASHC THEN
  1952  15   39:5    75 	  BEGIN
  1953  15   39:6    75 	    REPEATFACTOR:=1; INFINITY:=TRUE; CH:=GETCH; COMMAND:=TRANSLATE[CH]
  1954  15   39:5    95 	  END
  1955  15   39:4    98 	ELSE
  1956  15   39:5   100 	  IF COMMAND=DIGIT THEN REPEATFACTOR:=GETNUM ELSE REPEATFACTOR:=1;
  1957  15   39:4   117 	IF COMMAND IN [UP,DOWN] THEN
  1958  15   39:5   128 	  BEGIN
  1959  15   39:6   128 	    IF COMMAND=UP THEN DIRECTION:='<' ELSE DIRECTION:='>';
  1960  15   39:6   141 	    I:=1;
  1961  15   39:6   144 	    ATEND:=FALSE;
  1962  15   39:6   148 	    WHILE NOT ATEND AND ((I<=REPEATFACTOR) OR INFINITY) DO
  1963  15   39:7   162 	      BEGIN
  1964  15   39:8   162 		I:=I+1;
  1965  15   39:8   167 		LINEMOVE(1);
  1966  15   39:8   170 		IF NOT ATEND THEN
  1967  15   39:9   176 		  BEGIN
  1968  15   39:0   176 		    IF MODE=RELATIVE THEN DOIT(TDELTA)
  1969  15   39:0   182 		    ELSE
  1970  15   39:1   186 		      BEGIN
  1971  15   39:2   186 			LLENGTH:=SCAN(MAXCHAR,=CHR(EOL),EBUF^[STUFFSTART]);
  1972  15   39:2   199 			CASE MODE OF
  1973  15   39:2   202 			  LEFTJ:  DOIT(LMARGIN-BLANKS);
  1974  15   39:2   211 			  RIGHTJ: DOIT((RMARGIN-LLENGTH+1)-BLANKS);
  1975  15   39:2   224 			  CENTER:
  1976  15   39:3   224 			  DOIT(((RMARGIN-LMARGIN+1)-LLENGTH) DIV 2-BLANKS+LMARGIN)
  1977  15   39:2   243 			END (* case *)
  1978  15   39:1   260 		      END (* else *)
  1979  15   39:9   260 		  END; (* if not atend *)
  1980  15   39:7   260 	      END (* while ... *)
  1981  15   39:5   260 	  END
  1982  15   39:4   262 	ELSE
  1983  15   39:5   264 	  IF COMMAND=LEFT THEN
  1984  15   39:6   269 	    BEGIN
  1985  15   39:7   269 	      DOIT(-REPEATFACTOR); TDELTA:=TDELTA-REPEATFACTOR; MODE:=RELATIVE
  1986  15   39:6   278 	    END
  1987  15   39:5   281 	  ELSE
  1988  15   39:6   283 	    IF COMMAND=RIGHT THEN
  1989  15   39:7   288 	      BEGIN
  1990  15   39:8   288 		DOIT(REPEATFACTOR); TDELTA:=TDELTA+REPEATFACTOR; MODE:=RELATIVE
  1991  15   39:7   296 	      END
  1992  15   39:6   299 	    ELSE
  1993  15   39:7   301 	      IF COMMAND IN [LISTC,REPLACEC,COPYC] THEN
  1994  15   39:8   309 		BEGIN
  1995  15   39:9   309 		  GETLEADING;
  1996  15   39:9   312 		  LLENGTH:=SCAN(MAXCHAR,=CHR(EOL),EBUF^[STUFFSTART]);
  1997  15   39:9   325 		  IF COMMAND=LISTC THEN
  1998  15   39:0   330 		    BEGIN MODE:=LEFTJ; DOIT(LMARGIN-BLANKS) END
  1999  15   39:9   340 		  ELSE
  2000  15   39:0   342 		    IF COMMAND=REPLACEC THEN
  2001  15   39:1   347 		      BEGIN MODE:=RIGHTJ; DOIT((RMARGIN-LLENGTH+1)-BLANKS) END
  2002  15   39:0   361 		    ELSE (* COMMAND=COPYC *)
  2003  15   39:1   363 		      BEGIN
  2004  15   39:2   363 			MODE:=CENTER;
  2005  15   39:2   366 			DOIT(((RMARGIN-LMARGIN+1)-LLENGTH) DIV 2-BLANKS+LMARGIN)
  2006  15   39:1   385 		      END
  2007  15   39:8   387 		END
  2008  15   39:7   387 	      ELSE
  2009  15   39:8   389 	    IF CH<>CHR(ETX) THEN BEGIN ERRWAIT; SHOWCURSOR END;
  2010  15   39:4   402       1: UNTIL CH=CHR(ETX);
  2011  15   39:3   409       DIRECTION:=SAVEDIR;
  2012  15   39:2   412     END;
  2013  15   39:0   412 END;
  2014  15   39:0   432 
  2015  15   41:D     3 FUNCTION TABBY: INTEGER;
  2016  15   41:0     0 BEGIN
  2017  15   41:1     0   IF REPEATFACTOR > 0 THEN
  2018  15   41:2     5     IF DIRECTION = '>' THEN
  2019  15   41:3    10       TABBY:=8*(REPEATFACTOR-1)+  8-X+ORD(ODD(X) AND ODD(248))
  2020  15   41:2    28     ELSE
  2021  15   41:3    33       BEGIN
  2022  15   41:4    33 	IF X=0 THEN TABBY:=REPEATFACTOR*8
  2023  15   41:4    41 	ELSE TABBY:=8*(REPEATFACTOR-1)+X-ORD(ODD(X-1) AND ODD(248))
  2024  15   41:3    65       END
  2025  15   41:1    68   ELSE TABBY:=0
  2026  15   41:0    70 END;
  2027  15   41:0    86 
  2028  15   42:D     1 PROCEDURE MOVING;
  2029  15   42:D     1 VAR
  2030  15   42:D     1   SAVEX: INTEGER;
  2031  15   42:0     0 BEGIN
  2032  15   42:1     0   INDELETE:=FALSE;
  2033  15   42:1     4   INREPLACE:=FALSE;
  2034  15   42:1     8   EXITPROMPT:=FALSE;
  2035  15   42:1    12   IF INFINITY THEN
  2036  15   42:2    17     BEGIN
  2037  15   42:3    17       CASE COMMAND OF
  2038  15   42:3    20 	UP,LEFT: JUMPBEGIN;
  2039  15   42:3    24 	DOWN,RIGHT: JUMPEND;
  2040  15   42:3    28 	SPACE,ADVANCE,TAB: IF DIRECTION='<' THEN JUMPBEGIN ELSE JUMPEND
  2041  15   42:3    37       END;
  2042  15   42:3    66       NEEDPROMPT:=TRUE;
  2043  15   42:3    70       NEXTCOMMAND;
  2044  15   42:3    72       EXIT(MOVEIT)
  2045  15   42:2    76     END;
  2046  15   42:1    76   FINDXY(X,LINE);
  2047  15   42:1    85   REPEAT
  2048  15   42:2    85     OLDX:=X; OLDLINE:=LINE;
  2049  15   42:2    97     CASE COMMAND OF
  2050  15   42:2   100       LEFT: LEFTMOVE;
  2051  15   42:2   104       RIGHT: RIGHTMOVE;
  2052  15   42:2   108       SPACE: IF DIRECTION='<' THEN LEFTMOVE ELSE RIGHTMOVE;
  2053  15   42:2   121       UP: UPMOVE;
  2054  15   42:2   125       DOWN: DOWNMOVE;
  2055  15   42:2   129       ADVANCE: LINEMOVE(REPEATFACTOR);
  2056  15   42:2   134       PARAC: 
  2057  15   42:3   134 	IF REPEATFACTOR>1000 THEN ERROR('Too many',NONFATAL)
  2058  15   42:3   153 	ELSE LINEMOVE(SCREENHEIGHT*REPEATFACTOR);
  2059  15   42:2   165       TAB: BEGIN
  2060  15   42:4   165 	     IF REPEATFACTOR >= 4096 THEN
  2061  15   42:5   172 	       ERROR('Integer Overflow',NONFATAL)
  2062  15   42:4   192 	     ELSE
  2063  15   42:5   197 	       BEGIN
  2064  15   42:6   197 		 REPEATFACTOR:=TABBY;
  2065  15   42:6   203 		 IF DIRECTION='<' THEN LEFTMOVE ELSE RIGHTMOVE;
  2066  15   42:6   214 		 SAVEX:=X+1;
  2067  15   42:6   221 		 WHILE (X<>SAVEX) AND (X MOD 8<>0) DO
  2068  15   42:7   236 		   BEGIN
  2069  15   42:8   236 		     SAVEX:=X; REPEATFACTOR:=1;
  2070  15   42:8   244 		     IF DIRECTION='>' THEN RIGHTMOVE ELSE LEFTMOVE
  2071  15   42:7   253 	           END
  2072  15   42:5   255 	       END
  2073  15   42:3   257 	   END
  2074  15   42:2   257     END;
  2075  15   42:2   302     IF EXITPROMPT OR (COMMAND=PARAC) THEN GOTOXY(X,LINE)
  2076  15   42:2   320     ELSE
  2077  15   42:3   322       IF LINE=OLDLINE THEN 
  2078  15   42:4   331       BEGIN
  2079  15   42:5   331 	IF X=OLDX+1 THEN
  2080  15   42:6   342 	  GOTOXY(X,LINE) {Kludge for HAZELTINE terminals that used DLEs}
  2081  15   42:5   351 	ELSE
  2082  15   42:6   353 	  IF X=OLDX-1 THEN WRITE(CHR(BS))
  2083  15   42:6   374 	  ELSE GOTOXY(X,LINE)
  2084  15   42:4   385       END
  2085  15   42:3   385       ELSE
  2086  15   42:4   387 	IF X=OLDX THEN
  2087  15   42:5   396 	  BEGIN
  2088  15   42:6   396 	    IF LINE=OLDLINE+1 THEN WRITE(CHR(LF))
  2089  15   42:6   415 	    ELSE IF LINE=OLDLINE-1 THEN CONTROL(UPCURSOR)
  2090  15   42:7   429 	    ELSE GOTOXY(X,LINE);
  2091  15   42:5   443 	  END
  2092  15   42:4   443 	ELSE
  2093  15   42:5   445 	  GOTOXY(X,LINE);
  2094  15   42:2   454     REPEATFACTOR:=1;
  2095  15   42:2   457     NEXTCOMMAND
  2096  15   42:1   457   UNTIL NOT (COMMAND IN [UP,DOWN,LEFT,RIGHT,ADVANCE,SPACE,TAB]);
  2097  15   42:1   471   IF EXITPROMPT THEN PROMPT;
  2098  15   42:1   479   SHOWCURSOR;
  2099  15   42:0   482 END (* MOVING *);
  2100  15   42:0   504 
  2101  15   43:D     1 PROCEDURE PUTITBACK(C1,C2: PTRTYPE);
  2102  15   43:D     3 VAR
  2103  15   43:D     3   PTR: PTRTYPE;
  2104  15   43:D     4   INDENT,LOFF: INTEGER;
  2105  15   43:0     0 BEGIN
  2106  15   43:1     0   PTR:=C1;
  2107  15   43:1     3   WHILE PTR<=C2 DO
  2108  15   43:2     8     BEGIN
  2109  15   43:3     8       IF EBUF^[PTR]=CHR(EOL) THEN
  2110  15   43:4    16 	BEGIN
  2111  15   43:5    16 	  PTR:=PTR+1; WRITELN;
  2112  15   43:5    27 	  INDENT:=LEADBLANKS(PTR,LOFF);
  2113  15   43:5    37 	  IF (PTR<C2) AND (INDENT>0) THEN
  2114  15   43:6    46 	    WRITE(' ':INDENT);
  2115  15   43:5    54 	  PTR:=PTR+LOFF
  2116  15   43:4    55 	END
  2117  15   43:3    59       ELSE
  2118  15   43:4    61 	BEGIN WRITE(EBUF^[PTR]); PTR:=PTR+1 END;
  2119  15   43:2    77     END;
  2120  15   43:0    79 END;
  2121  15   43:0    94 
  2122  15   30:D     1 PROCEDURE CLEAR(*X1,Y1,X2,Y2: INTEGER*);
  2123  15   30:D     5 (* Screen co-ordinate (X1,Y1) is assumed to be before (X2,Y2).  This
  2124  15   30:D     5    procedure takes these co-ordinates and clears (writes blanks) over
  2125  15   30:D     5    the screen between them (inclusive)  *)
  2126  15   30:D     5 VAR XX,I: INTEGER;
  2127  15   30:0     0 BEGIN
  2128  15   30:1     0   GOTOXY(X1,Y1);
  2129  15   30:1     5   XX:=X1;
  2130  15   30:1     8   FOR I:=Y1 TO Y2-1 DO BEGIN IF I<>0 THEN ERASETOEOL(XX,I); XX:=0; WRITELN END;
  2131  15   30:1    47   IF Y1<>Y2 THEN FOR I:=0 TO X2 DO WRITE(' ')
  2132  15   30:1    71   ELSE FOR I:=X1 TO X2 DO WRITE(' ')
  2133  15   30:0    99 END;
  2134  15   30:0   124 
  2135  15   44:D     1 PROCEDURE RESOLVESCREEN;
  2136  15   44:D     1 VAR
  2137  15   44:D     1   X1,X2,Y1,Y2,SAVE: INTEGER;
  2138  15   44:D     6   C1,C2: PTRTYPE;
  2139  15   44:0     0 BEGIN
  2140  15   44:1     0   X1:=X;    Y1:=LINE;
  2141  15   44:1    10   X2:=OLDX; Y2:=OLDLINE;
  2142  15   44:1    20   IF NEWDIST>DIST THEN
  2143  15   44:2    29     BEGIN C1:=CURSOR-1; C2:=OLDCURSOR; X1:=X1-1 END
  2144  15   44:1    44   ELSE
  2145  15   44:2    46     IF NEWDIST<DIST THEN
  2146  15   44:3    55       BEGIN C2:=OLDCURSOR-1; C1:=CURSOR; X2:=X2-1 END
  2147  15   44:2    70     ELSE
  2148  15   44:3    72       EXIT(RESOLVESCREEN);
  2149  15   44:1    76   IF (Y1>Y2) OR ((Y1=Y2) AND (X1>X2)) THEN
  2150  15   44:2    89     BEGIN
  2151  15   44:3    89       SAVE:=C1; C1:=C2; C2:=SAVE;
  2152  15   44:3    98       SAVE:=Y1; Y1:=Y2; Y2:=SAVE;
  2153  15   44:3   107       SAVE:=X1; X1:=X2; X2:=SAVE
  2154  15   44:2   113     END;
  2155  15   44:1   116   IF ABS(NEWDIST)>ABS(DIST) THEN
  2156  15   44:2   127     CLEAR(X1,Y1,X2,Y2)
  2157  15   44:1   131   ELSE
  2158  15   44:2   135     BEGIN
  2159  15   44:3   135       GOTOXY(X1,Y1);
  2160  15   44:3   140       PUTITBACK(C1,C2)
  2161  15   44:2   142     END;
  2162  15   44:1   144   GOTOXY(X,LINE)
  2163  15   44:0   153 END;
  2164  15   44:0   166 
  2165  15   45:D     1 PROCEDURE DELETING;
  2166  15   45:D     1 LABEL 1;
  2167  15   45:D     1 VAR
  2168  15   45:D     1   ATBOL,ANCHOR,SAVE: PTRTYPE;
  2169  15   45:D     4   OK,ATBOT,NOMOVE: BOOLEAN;
  2170  15   45:D     7   STARTLINE: INTEGER;
  2171  15   45:D     8 
  2172  15   45:0     0 BEGIN
  2173  15   45:1     0   DOFFSCREEN:=FALSE; INDELETE:=TRUE; INREPLACE:=FALSE; EXITPROMPT:=FALSE;
  2174  15   45:1    16   ANCHOR:=CURSOR; NEWDIST:=0;
  2175  15   45:1    23   GETLEADING; ATBOL:=LINESTART; ATBOT:=(CURSOR=STUFFSTART);
  2176  15   45:1    34   PROMPTLINE:=DELETEPROMPT;
  2177  15   45:1    42   PROMPT; NEEDPROMPT:=TRUE;
  2178  15   45:1    49   SHOWCURSOR;
  2179  15   45:1    52   FINDXY(X,LINE);
  2180  15   45:1    61   STARTLINE:=LINE;
  2181  15   45:1    66   REPEAT
  2182  15   45:2    66     OLDCURSOR:=CURSOR;
  2183  15   45:2    70     DIST:=NEWDIST;
  2184  15   45:2    76     OLDX:=X; OLDLINE:=LINE;
  2185  15   45:2    88     CH:=GETCH;
  2186  15   45:2    95     COMMAND:=TRANSLATE[CH];
  2187  15   45:2   104     IF COMMAND=DIGIT THEN REPEATFACTOR:=GETNUM ELSE REPEATFACTOR:=1;
  2188  15   45:2   121     IF COMMAND IN [REVERSEC..DIGIT,ADVANCE,SPACE] THEN
  2189  15   45:3   132       BEGIN
  2190  15   45:4   132 	CASE COMMAND OF
  2191  15   45:4   135 	  LEFT: LEFTMOVE;
  2192  15   45:4   139 	  RIGHT: RIGHTMOVE;
  2193  15   45:4   143 	  SPACE: IF DIRECTION='<' THEN LEFTMOVE ELSE RIGHTMOVE;
  2194  15   45:4   156 	  UP: UPMOVE;
  2195  15   45:4   160 	  DOWN: DOWNMOVE;
  2196  15   45:4   164 	  ADVANCE: LINEMOVE(REPEATFACTOR);
  2197  15   45:4   169 	  REVERSEC,FORWARDC:
  2198  15   45:5   169 	    BEGIN
  2199  15   45:6   169 	      IF COMMAND=REVERSEC THEN
  2200  15   45:7   174 		DIRECTION:='<'
  2201  15   45:6   174 	      ELSE
  2202  15   45:7   179 		DIRECTION:='>';
  2203  15   45:6   182 	      GOTOXY(0,0); WRITE(DIRECTION); GOTOXY(X,LINE)
  2204  15   45:5   204 	    END;
  2205  15   45:4   206 	  TAB:
  2206  15   45:5   206 	    BEGIN
  2207  15   45:6   206 	      IF REPEATFACTOR>=4096 THEN ERROR('Integer Ovflw',NONFATAL)
  2208  15   45:6   230 	      ELSE
  2209  15   45:7   235 		BEGIN
  2210  15   45:8   235 		  REPEATFACTOR:=TABBY;
  2211  15   45:8   241 		  IF DIRECTION='<' THEN LEFTMOVE ELSE RIGHTMOVE
  2212  15   45:7   250 		END
  2213  15   45:5   252 	    END
  2214  15   45:4   252 	END;
  2215  15   45:4   284 	NEWDIST:=CURSOR-ANCHOR;
  2216  15   45:4   290 	RESOLVESCREEN;
  2217  15   45:3   292       END
  2218  15   45:2   292     ELSE
  2219  15   45:3   294       IF (CH<>CHR(ESC)) AND (CH<>CHR(ETX)) THEN 
  2220  15   45:4   307 	BEGIN ERRWAIT; GOTOXY(X,LINE) END
  2221  15   45:1   319   UNTIL (CH IN [CHR(ETX),CHR(ESC)]);
  2222  15   45:1   332   IF CH=CHR(ETX) THEN 
  2223  15   45:2   339     BEGIN
  2224  15   45:3   339       GETLEADING; (* Indentation fixup *)
  2225  15   45:3   342       IF ATBOT AND (CURSOR=STUFFSTART) THEN
  2226  15   45:4   349 	BEGIN CURSOR:=LINESTART; SAVE:=ANCHOR; ANCHOR:=ATBOL END;
  2227  15   45:3   358       IF OKTODEL(CURSOR,ANCHOR) THEN
  2228  15   45:4   367 	BEGIN
  2229  15   45:5   367 	  READJUST(MIN(CURSOR,ANCHOR),-ABS(CURSOR-ANCHOR));
  2230  15   45:5   382 	  COPYLINE:=(CURSOR=LINESTART) AND ATBOT;
  2231  15   45:5   390 	  IF ANCHOR<CURSOR THEN 
  2232  15   45:6   395 	    MOVELEFT(EBUF^[CURSOR],EBUF^[ANCHOR],BUFCOUNT-CURSOR)
  2233  15   45:5   406 	  ELSE
  2234  15   45:6   408 	    MOVELEFT(EBUF^[ANCHOR],EBUF^[CURSOR],BUFCOUNT-ANCHOR);
  2235  15   45:5   419 	  BUFCOUNT:=BUFCOUNT-ABS(CURSOR-ANCHOR);
  2236  15   45:5   427 	  CURSOR:=MIN(CURSOR,ANCHOR);
  2237  15   45:5   436 	  GETLEADING; CURSOR:=MAX(STUFFSTART,CURSOR)
  2238  15   45:4   441 	END
  2239  15   45:3   448       ELSE
  2240  15   45:4   450 	CURSOR:=SAVE
  2241  15   45:2   450     END
  2242  15   45:1   453   ELSE
  2243  15   45:2   455     BEGIN
  2244  15   45:3   455       COPYLINE:=FALSE; COPYOK:=TRUE;
  2245  15   45:3   463       COPYSTART:=MIN(CURSOR,ANCHOR);
  2246  15   45:3   473       COPYLENGTH:=ABS(CURSOR-ANCHOR);
  2247  15   45:3   480       CURSOR:=ANCHOR;
  2248  15   45:2   483     END;
  2249  15   45:1   483   1:INDELETE:=FALSE;
  2250  15   45:1   487   OK:=(LINE=STARTLINE) AND NOT DOFFSCREEN;
  2251  15   45:1   499   UPSCREEN(OK,NOT OK,LINE);
  2252  15   45:1   508   NEXTCOMMAND;
  2253  15   45:0   510 END;
  2254  15   45:0   528 
  2255  15   28:0     0 BEGIN
  2256  15   28:1     0   IF COMMAND=DELETEC THEN
  2257  15   28:2     5     DELETING
  2258  15   28:1     5   ELSE
  2259  15   28:2     9     IF COMMAND=ADJUSTC THEN
  2260  15   28:3    14       BEGIN ADJUSTING; NEXTCOMMAND END
  2261  15   28:2    18     ELSE MOVING;
  2262  15   28:0    22 END;
  2263  15   28:0    34 
  2264  15   28:0    34 (* --- FIND      --- *)
  2265  15    6:D     1 PROCEDURE FIND;
  2266  15    6:D     1 VAR
  2267  15    6:D     1   THERE,FOUND,LASTPATTERN: BOOLEAN;
  2268  15    6:D     4   TRASH,COULDBE,PLENGTH,START,STOP,NEXTSTART: INTEGER;
  2269  15    6:D    10   NEXT,PTR: PTRTYPE;
  2270  15    6:D    12   MODE: (LITERAL,TOKEN);
  2271  15    6:D    13   I: INTEGER;
  2272  15    6:D    14   DELIMITER: CHAR;
  2273  15    6:D    15   JUSTIN: BOOLEAN;
  2274  15    6:D    16   POSSIBLE,PAT: PTYPE;
  2275  15    6:D   144   USEOLD,VERIFY: BOOLEAN;
  2276  15    6:D   146 
  2277  15   46:D     1 PROCEDURE NEXTCH;
  2278  15   46:0     0 BEGIN
  2279  15   46:1     0   CH:=GETCH;
  2280  15   46:1     7   IF CH=CHR(ESC) THEN
  2281  15   46:2    14       BEGIN
  2282  15   46:3    14 	IF NOT JUSTIN THEN REDISPLAY;
  2283  15   46:3    23 	SHOWCURSOR; NEXTCOMMAND;
  2284  15   46:3    28 	EXIT(FIND);
  2285  15   46:2    32       END;
  2286  15   46:1    32   IF (CH=CHR(EOL)) AND JUSTIN THEN
  2287  15   46:2    41     BEGIN
  2288  15   46:3    41       JUSTIN:=FALSE;
  2289  15   46:3    45       BLANKCRT(1)
  2290  15   46:2    46     END
  2291  15   46:1    49   ELSE
  2292  15   46:2    51     WRITE(CH);
  2293  15   46:0    59 END;
  2294  15   46:0    72 
  2295  15   47:D     1 PROCEDURE SKIP;
  2296  15   47:0     0 BEGIN
  2297  15   47:1     0   WHILE CH IN [CHR(SP),CHR(HT),CHR(EOL)] DO NEXTCH
  2298  15   47:0    12 END;
  2299  15   47:0    30 
  2300  15   48:D     1 PROCEDURE OPTIONS;
  2301  15   48:0     0 BEGIN
  2302  15   48:1     0   REPEAT
  2303  15   48:2     0     CH:=UCLC(CH);
  2304  15   48:2     8     IF CH='L' THEN
  2305  15   48:3    13       BEGIN MODE:=LITERAL; NEXTCH END
  2306  15   48:2    19     ELSE
  2307  15   48:3    21       IF CH='V' THEN 
  2308  15   48:4    26 	BEGIN VERIFY:=TRUE; NEXTCH END
  2309  15   48:3    33       ELSE
  2310  15   48:4    35 	IF CH='T' THEN
  2311  15   48:5    40 	  BEGIN MODE:=TOKEN; NEXTCH END;
  2312  15   48:2    46     CH:=UCLC(CH);
  2313  15   48:1    54   UNTIL NOT ((CH='V') OR (CH='T') OR (CH='L'));
  2314  15   48:1    68   SKIP;
  2315  15   48:1    70   IF (CH='S') OR (CH='s') THEN USEOLD:=TRUE;
  2316  15   48:0    84 END;
  2317  15   48:0    98 
  2318  15   49:D     1 PROCEDURE PARSESTRING(VAR PATTERN: PTYPE; VAR PLENGTH: INTEGER);
  2319  15   49:D     3 VAR I,J: INTEGER;
  2320  15   49:0     0 BEGIN
  2321  15   49:1     0   SKIP;
  2322  15   49:1     2   IF CH IN ['A'..'Z','a'..'z','0'..'9',CHR(BS)] THEN
  2323  15   49:2    31     BEGIN
  2324  15   49:3    31       ERROR('Invalid delimiter.',NONFATAL);
  2325  15   49:3    56       IF NOT JUSTIN THEN REDISPLAY;
  2326  15   49:3    65       NEXTCOMMAND;
  2327  15   49:3    67       EXIT(FIND);
  2328  15   49:2    71     END;
  2329  15   49:1    71   DELIMITER:=CH;
  2330  15   49:1    75   I:=0;
  2331  15   49:1    78   REPEAT
  2332  15   49:2    78     NEXTCH;
  2333  15   49:2    80     IF CH=CHR(BS) THEN
  2334  15   49:3    87       BEGIN
  2335  15   49:4    87 	IF (PATTERN[I]<>CHR(EOL)) AND (I>0) THEN (* Don't go overboard! *)
  2336  15   49:5    98 	  BEGIN
  2337  15   49:6    98 	    WRITE(' ',CHR(BS));
  2338  15   49:6   116 	    I:=I-1
  2339  15   49:5   117 	  END
  2340  15   49:4   121 	ELSE CONTROL(RIGHTCURSOR); (* Make up for the <BS> NEXTCH wrote out *)
  2341  15   49:3   127       END
  2342  15   49:2   127     ELSE
  2343  15   49:3   129       BEGIN
  2344  15   49:4   129 	PATTERN[I]:=CH;
  2345  15   49:4   133 	I:=I+1
  2346  15   49:3   134       END;
  2347  15   49:1   138   UNTIL (CH=DELIMITER) OR (I>=MAXSTRING);
  2348  15   49:1   149   IF I>=MAXCHAR THEN
  2349  15   49:2   156     BEGIN 
  2350  15   49:3   156       ERROR('Your pattern is too long',NONFATAL);
  2351  15   49:3   187       IF NOT JUSTIN THEN REDISPLAY;
  2352  15   49:3   196       NEXTCOMMAND; EXIT(FIND)
  2353  15   49:2   202     END;
  2354  15   49:1   202   PLENGTH:=I-1;
  2355  15   49:0   207 END (* PARSESTRING *);
  2356  15   49:0   222 
  2357  15   50:D     3 FUNCTION OK(PTR: PTRTYPE): BOOLEAN;
  2358  15   50:D     4 (* Compare PAT against the buffer *)
  2359  15   50:D     4 VAR I: INTEGER;
  2360  15   50:0     0 BEGIN
  2361  15   50:1     0   I:=0;
  2362  15   50:1     3   WHILE (I<PLENGTH) AND (EBUF^[PTR+I]=PAT[I]) DO I:=I+1;
  2363  15   50:1    30   OK:= I=PLENGTH;
  2364  15   50:0    37 END;
  2365  15   50:0    52 
  2366  15   51:D     1 PROCEDURE SKIPKIND3(VAR CURSOR: PTRTYPE); 
  2367  15   51:0     0 BEGIN
  2368  15   51:0     0   (* Skip over kind3 characters in the ebuf.  Update the cursor
  2369  15   51:0     0      to the first non-kind3 character                           *)
  2370  15   51:1     0   WHILE EBUF^[CURSOR] IN [CHR(SP),CHR(HT),CHR(DLE),CHR(EOL)] DO
  2371  15   51:2    19     IF EBUF^[CURSOR]=CHR(DLE) THEN CURSOR:=CURSOR+2
  2372  15   51:2    31     ELSE CURSOR:=CURSOR+1;
  2373  15   51:0    44 END;
  2374  15   51:0    58 
  2375  15   52:D     1 PROCEDURE SCANBACKWARD;
  2376  15   52:D     1 LABEL 1;
  2377  15   52:D     1 VAR
  2378  15   52:D     1   LOC: PTRTYPE;
  2379  15   52:D     2   CHTHERE: BOOLEAN;
  2380  15   52:0     0 BEGIN
  2381  15   52:1     0   CHTHERE:=TRUE;
  2382  15   52:1     3   THERE:=FALSE;
  2383  15   52:1     7   FILLCHAR(PAT[0],SIZEOF(PAT),' ');
  2384  15   52:1    17   MOVELEFT(TARGET[START],PAT[0],PLENGTH);
  2385  15   52:1    32   WHILE CHTHERE AND NOT THERE DO 
  2386  15   52:2    40     BEGIN
  2387  15   52:3    40       1: IF PTR>=PLENGTH THEN (* Possibly there *)
  2388  15   52:4    49 	LOC:=SCAN(-PTR,=PAT[0],EBUF^[PTR])
  2389  15   52:3    67       ELSE
  2390  15   52:4    71 	LOC:=-PTR;
  2391  15   52:3    77       IF LOC=-PTR THEN (* Not there! *)
  2392  15   52:4    85 	BEGIN
  2393  15   52:5    85 	  CHTHERE:=FALSE; THERE:=FALSE
  2394  15   52:4    88 	END
  2395  15   52:3    92       ELSE
  2396  15   52:4    94 	BEGIN
  2397  15   52:5    94 	  PTR:=PTR+LOC; NEXT:=PTR-1;
  2398  15   52:5   110 	  IF EBUF^[PTR-1]=CHR(DLE) THEN BEGIN PTR:=NEXT; GOTO 1 END;
  2399  15   52:5   130 	  IF OK(PTR) THEN THERE:=TRUE ELSE PTR:=NEXT
  2400  15   52:4   145 	END
  2401  15   52:2   151     END;
  2402  15   52:0   153 END;
  2403  15   52:0   170 
  2404  15   53:D     1 PROCEDURE SCANFORWARD;
  2405  15   53:D     1 LABEL 1;
  2406  15   53:D     1 VAR
  2407  15   53:D     1   MAXSCAN,LOC: INTEGER;
  2408  15   53:D     3   CHTHERE: BOOLEAN;
  2409  15   53:0     0 BEGIN
  2410  15   53:1     0   CHTHERE:=TRUE;
  2411  15   53:1     3   THERE:=FALSE;
  2412  15   53:1     7   FILLCHAR(PAT[0],SIZEOF(PAT),' ');
  2413  15   53:1    17   MOVELEFT(TARGET[START],PAT[0],PLENGTH);
  2414  15   53:1    32   WHILE CHTHERE AND NOT THERE DO
  2415  15   53:2    40    BEGIN
  2416  15   53:3    40     1: MAXSCAN:=(BUFCOUNT-PLENGTH)-PTR+1;
  2417  15   53:3    53     IF MAXSCAN>0 THEN (* still stuff to scan *)
  2418  15   53:4    58       LOC:=SCAN(MAXSCAN,=PAT[0],EBUF^[PTR])
  2419  15   53:3    73     ELSE
  2420  15   53:4    77       LOC:=MAXSCAN; (* Dummy up 'not found' condition *)
  2421  15   53:3    80     IF LOC=MAXSCAN THEN
  2422  15   53:4    85       BEGIN CHTHERE:=FALSE; THERE:=FALSE END
  2423  15   53:3    92     ELSE
  2424  15   53:4    94       BEGIN
  2425  15   53:5    94 	PTR:=LOC+PTR; NEXT:=PTR+1;
  2426  15   53:5   110 	IF EBUF^[PTR-1]=CHR(DLE) THEN BEGIN PTR:=NEXT; GOTO 1 END;
  2427  15   53:5   130 	IF OK(PTR) THEN THERE:=TRUE ELSE PTR:=NEXT
  2428  15   53:4   145       END
  2429  15   53:2   151    END;
  2430  15   53:0   153 END;
  2431  15   53:0   170 
  2432  15   54:D     1 PROCEDURE GOFORIT;
  2433  15   54:D     1 
  2434  15   55:D     1 PROCEDURE NEXTLINE;
  2435  15   55:D     1 (* Given NEXTSTART, calculate the START and STOP for the next line *)
  2436  15   55:0     0 BEGIN
  2437  15   55:1     0   LASTPATTERN:=FALSE;
  2438  15   55:1     4   START:=NEXTSTART;
  2439  15   55:1    10   STOP:=MIN(TLENGTH-1,START+SCAN(TLENGTH-START,=CHR(EOL),TARGET[START]));
  2440  15   55:1    45   IF STOP=TLENGTH-1 THEN BEGIN STOP:=MAX(STOP,0); LASTPATTERN:=TRUE END;
  2441  15   55:1    72   NEXTSTART:=STOP+1;
  2442  15   55:0    80 END;
  2443  15   55:0    92 
  2444  15   56:D     1 PROCEDURE NEXTTOKEN;
  2445  15   56:D     1 (* Given NEXTSTART, calculate START and STOP *)
  2446  15   56:0     0 BEGIN
  2447  15   56:1     0   LASTPATTERN:=FALSE;
  2448  15   56:1     4   START:=NEXTSTART;
  2449  15   56:1    10   (* Skip over leading kind3 characters *)
  2450  15   56:1    10   WHILE (TARGET[START] IN [CHR(SP),CHR(EOL),CHR(HT)]) AND (START<TLENGTH-1) DO
  2451  15   56:2    38     START:=START+1;
  2452  15   56:1    48   STOP:=START;
  2453  15   56:1    54   (* Get the next token *)
  2454  15   56:1    54   WHILE (KIND[TARGET[START]]=KIND[TARGET[STOP+1]]) AND (STOP<TLENGTH-1) DO
  2455  15   56:2    93     STOP:=STOP+1;
  2456  15   56:1   103   STOP:=MIN(STOP,TLENGTH-1);
  2457  15   56:1   119   (* To accurately test for the last token, scan off the trailing kind3
  2458  15   56:1   119      characters *)
  2459  15   56:1   119   NEXTSTART:=STOP+1;
  2460  15   56:1   127   WHILE (TARGET[NEXTSTART] IN [CHR(EOL),CHR(SP),CHR(HT)]) AND
  2461  15   56:1   143 	(NEXTSTART<TLENGTH) DO NEXTSTART:=NEXTSTART+1;
  2462  15   56:1   163   IF NEXTSTART=TLENGTH THEN BEGIN STOP:=MAX(STOP,0); LASTPATTERN:=TRUE END;
  2463  15   56:0   188 END;
  2464  15   56:0   206 
  2465  15   54:0     0 BEGIN(* goforit *)
  2466  15   54:1     0   FOUND:=FALSE;
  2467  15   54:1     4   NEXT:=PTR;
  2468  15   54:1    10   REPEAT
  2469  15   54:2    10     PTR:=NEXT; (* Set to next place to scan for *)
  2470  15   54:2    16     NEXTSTART:=0;  (* Fool NEXTLINE into giving us START and STOP for line 1 *)
  2471  15   54:2    20     IF MODE=LITERAL THEN NEXTLINE ELSE NEXTTOKEN;
  2472  15   54:2    33     PLENGTH:=STOP-START+1;
  2473  15   54:2    45     IF DIRECTION='>' THEN SCANFORWARD ELSE SCANBACKWARD;
  2474  15   54:2    56     IF THERE THEN
  2475  15   54:3    61       BEGIN
  2476  15   54:4    61 	COULDBE:=PTR;
  2477  15   54:4    67 	FOUND:=TRUE;
  2478  15   54:4    71 	WHILE (NOT LASTPATTERN) AND FOUND DO
  2479  15   54:5    81 	  BEGIN
  2480  15   54:6    81 	    IF MODE=LITERAL THEN NEXTLINE ELSE NEXTTOKEN;
  2481  15   54:6    94 	    PTR:=PTR+PLENGTH;
  2482  15   54:6   104 	    SKIPKIND3(PTR); (* Go past the junk on the next line *)
  2483  15   54:6   109 	    PLENGTH:=STOP-START+1; (* For the new line *)
  2484  15   54:6   121 	    FILLCHAR(PAT[0],SIZEOF(PAT),' ');
  2485  15   54:6   131 	    MOVELEFT(TARGET[START],PAT[0],PLENGTH);
  2486  15   54:6   146 	    IF PTR+PLENGTH > BUFCOUNT THEN
  2487  15   54:7   157 	      FOUND:=FALSE
  2488  15   54:6   157 	    ELSE
  2489  15   54:7   163 	      IF NOT OK(PTR) THEN FOUND:=FALSE;
  2490  15   54:5   177 	  END;
  2491  15   54:3   179       END;
  2492  15   54:3   179     (* In token mode make sure the first and last characters
  2493  15   54:3   179        of the target are on 'token boundaries' *)
  2494  15   54:2   179     IF MODE=TOKEN THEN IF KIND[PAT[0]]=ORD('A') THEN IF FOUND THEN
  2495  15   54:5   205       BEGIN
  2496  15   54:6   205 	IF ((COULDBE>2) AND (EBUF^[COULDBE-2]<>CHR(DLE))) OR
  2497  15   54:6   221 	   (COULDBE<=2) THEN (* whew! *)
  2498  15   54:7   229 	  IF KIND[EBUF^[COULDBE]]=KIND[EBUF^[COULDBE-1]] THEN
  2499  15   54:8   256 	    FOUND:=FALSE; (* False find... don't count it. *)
  2500  15   54:6   260 	IF (PTR+PLENGTH<=BUFCOUNT-1) AND 
  2501  15   54:6   271 	   (KIND[EBUF^[PTR+PLENGTH-1]]=KIND[EBUF^[PTR+PLENGTH]]) THEN
  2502  15   54:7   307 	  FOUND:=FALSE; (* Another false find *)
  2503  15   54:5   311      END;
  2504  15   54:1   311   UNTIL FOUND OR NOT THERE;
  2505  15   54:0   321 END(* goforit *);
  2506  15   54:0   338 
  2507  15   57:D     1 PROCEDURE PUTPROMPT(LEFT,RIGHT:STRING; REPEATFACTOR:INTEGER; LORT:BOOLEAN);
  2508  15   57:0     0 BEGIN
  2509  15   57:1     0   PROMPTLINE:=LEFT; PROMPT;
  2510  15   57:1    20   WRITE('[');
  2511  15   57:1    28   IF INFINITY THEN WRITE('/') ELSE WRITE(REPEATFACTOR);
  2512  15   57:1    51   WRITE(']: ');
  2513  15   57:1    64   IF LORT THEN IF MODE=TOKEN THEN WRITE('L(it') ELSE WRITE('T(ok');
  2514  15   57:1   104   WRITE(RIGHT)
  2515  15   57:0   113 END;
  2516  15   57:0   126 
  2517  15   58:D     1 PROCEDURE REPLACEIT;
  2518  15   58:D     1 LABEL 1;
  2519  15   58:0     0 BEGIN
  2520  15   58:1     0   IF VERIFY THEN
  2521  15   58:2     6     BEGIN
  2522  15   58:3     6       CENTERCURSOR(TRASH,MIDDLE,NOT JUSTIN);
  2523  15   58:3    19       PUTPROMPT(' Replace','<esc> aborts, ''R'' replaces, '' '' doesn''t',
  2524  15   58:3    72 		REPEATFACTOR-I+2,FALSE);
  2525  15   58:3    82       SHOWCURSOR;
  2526  15   58:3    85       CH:=GETCH;
  2527  15   58:3    92       IF CH=CHR(ESC) THEN
  2528  15   58:4    99 	BEGIN
  2529  15   58:5    99 	  GETLEADING; CURSOR:=MAX(CURSOR,STUFFSTART);
  2530  15   58:5   111 	  NEXTCOMMAND; EXIT(FIND)
  2531  15   58:4   117 	END;
  2532  15   58:3   117       IF (CH<>'R') AND (CH<>'r') THEN GOTO 1;
  2533  15   58:2   128     END;
  2534  15   58:2   128     (* Replace TARGET with SUBSTRING *)
  2535  15   58:1   128       IF SLENGTH>CURSOR-LASTPAT THEN
  2536  15   58:2   137 	IF SLENGTH-(CURSOR-LASTPAT)+BUFCOUNT>BUFSIZE-200 THEN
  2537  15   58:3   154 	    BEGIN
  2538  15   58:4   154 	      ERROR('Buffer full.  Aborting Replace',NONFATAL);
  2539  15   58:4   191 	      GETLEADING; CURSOR:=MAX(CURSOR,STUFFSTART);
  2540  15   58:4   203 	      NEXTCOMMAND; EXIT(FIND);
  2541  15   58:3   209 	    END
  2542  15   58:2   209 	ELSE
  2543  15   58:3   211 	  MOVERIGHT(EBUF^[CURSOR],EBUF^[LASTPAT+SLENGTH],BUFCOUNT-CURSOR)
  2544  15   58:1   226       ELSE
  2545  15   58:2   228 	IF SLENGTH<CURSOR-LASTPAT THEN
  2546  15   58:3   237 	  MOVELEFT(EBUF^[CURSOR],EBUF^[LASTPAT+SLENGTH],BUFCOUNT-CURSOR);
  2547  15   58:1   252       MOVELEFT(SUBSTRING[0],EBUF^[LASTPAT],SLENGTH);
  2548  15   58:1   264       IF SLENGTH<>CURSOR-LASTPAT THEN
  2549  15   58:2   273 	READJUST(LASTPAT,SLENGTH-(CURSOR-LASTPAT));
  2550  15   58:1   284       BUFCOUNT:=BUFCOUNT+SLENGTH-(CURSOR-LASTPAT);
  2551  15   58:1   295       CURSOR  :=CURSOR  +SLENGTH-(CURSOR-LASTPAT);
  2552  15   58:1   306       JUSTIN:=FALSE;
  2553  15   58:1   310 1:END;
  2554  15   58:1   324 
  2555  15    6:0     0 BEGIN
  2556  15    6:1     0   JUSTIN:=TRUE;
  2557  15    6:1     3   USEOLD:=FALSE;
  2558  15    6:1     7   VERIFY:=FALSE;
  2559  15    6:1    11   IF PAGEZERO.TOKDEF THEN MODE:=TOKEN ELSE MODE:=LITERAL;
  2560  15    6:1    24   IF COMMAND=FINDC THEN
  2561  15    6:2    29     PUTPROMPT(' Find',' <target>  =>',REPEATFACTOR,TRUE)
  2562  15    6:1    55   ELSE
  2563  15    6:2    59     PUTPROMPT(' Replace',' V(fy <targ> <sub>  =>',REPEATFACTOR,TRUE);
  2564  15    6:1    99   NEEDPROMPT:=TRUE; 
  2565  15    6:1   103   NEXTCH; SKIP;
  2566  15    6:1   107   OPTIONS;
  2567  15    6:1   109   IF NOT USEOLD THEN 
  2568  15    6:2   115     BEGIN
  2569  15    6:3   115       PARSESTRING(TARGET,TLENGTH);
  2570  15    6:3   123       TDEFINED:=TRUE
  2571  15    6:2   123     END;
  2572  15    6:1   127   IF COMMAND=REPLACEC THEN
  2573  15    6:2   132     BEGIN
  2574  15    6:3   132       NEXTCH; SKIP;
  2575  15    6:3   136       USEOLD:=FALSE;
  2576  15    6:3   140       OPTIONS;
  2577  15    6:3   142       IF NOT USEOLD THEN
  2578  15    6:4   148 	BEGIN
  2579  15    6:5   148 	  PARSESTRING(SUBSTRING,SLENGTH);
  2580  15    6:5   156 	  SDEFINED:=TRUE
  2581  15    6:4   156 	END
  2582  15    6:2   160     END;
  2583  15    6:1   160   HOME;
  2584  15    6:1   163   CLEARLINE(0);
  2585  15    6:1   167   IF ((COMMAND=FINDC) AND TDEFINED) 
  2586  15    6:1   174      OR ((COMMAND=REPLACEC) AND SDEFINED AND TDEFINED) THEN 
  2587  15    6:2   188     BEGIN
  2588  15    6:3   188       I:=1;
  2589  15    6:3   191       FOUND:=TRUE;
  2590  15    6:3   194       PTR:=CURSOR;
  2591  15    6:3   197       WHILE ((I<=REPEATFACTOR) OR INFINITY) AND FOUND DO
  2592  15    6:4   208 	BEGIN
  2593  15    6:5   208 	  GOFORIT; (* Find the target (handles token and literal mode) *)
  2594  15    6:5   210 	  I:=I+1;
  2595  15    6:5   215 	  IF FOUND THEN
  2596  15    6:6   218 	    BEGIN
  2597  15    6:7   218 	      CURSOR:=PTR+PLENGTH; LASTPAT:=COULDBE; (*Set up for next time*)
  2598  15    6:7   226 	      IF COMMAND=REPLACEC THEN REPLACEIT;
  2599  15    6:7   233 	      IF DIRECTION='<' THEN PTR:=COULDBE-1 ELSE PTR:=CURSOR;
  2600  15    6:6   248 	    END;
  2601  15    6:4   248 	END;
  2602  15    6:3   250       IF NOT FOUND THEN
  2603  15    6:4   254 	IF NOT( INFINITY AND (I>2) ) THEN
  2604  15    6:5   264 	  ERROR('Pattern not in the file',NONFATAL) 
  2605  15    6:2   291     END
  2606  15    6:1   294   ELSE 
  2607  15    6:2   296     ERROR('No old pattern.',NONFATAL);
  2608  15    6:1   318   CENTERCURSOR(TRASH,MIDDLE,NOT JUSTIN);
  2609  15    6:1   328   GETLEADING;
  2610  15    6:1   331   CURSOR:=MAX(STUFFSTART,CURSOR);
  2611  15    6:1   340   SHOWCURSOR;
  2612  15    6:1   343   NEXTCOMMAND
  2613  15    6:0   343 END;
  2614  15    6:0   360 
  2615  15    6:0   360 (* --- USER      --- *)
  2616  15    2:D     1 PROCEDURE NEXTCOMMAND;
  2617  15    2:0     0 BEGIN
  2618  15    2:1     0   IF NEEDPROMPT THEN
  2619  15    2:2     5     BEGIN
  2620  15    2:3     5       PROMPTLINE:=COMPROMPT; {Made variable for screens of short width. MAB}
  2621  15    2:3    13       PROMPT;
  2622  15    2:3    16       NEEDPROMPT:=FALSE;
  2623  15    2:3    20       SHOWCURSOR
  2624  15    2:2    20     END;
  2625  15    2:1    23   CH:=GETCH;
  2626  15    2:1    30   COMMAND:=MAPTOCOMMAND(CH);
  2627  15    2:0    38 END(* NEXTCOMMAND *);
  2628  15    2:0    50 
  2629  15   59:D     1 PROCEDURE COMMANDER;
  2630  15   59:0     0 BEGIN
  2631  15   59:1     0   INFINITY:=FALSE;
  2632  15   59:1     4   IF COMMAND=SLASHC THEN 
  2633  15   59:2     9     BEGIN REPEATFACTOR:=1; INFINITY:=TRUE; NEXTCOMMAND END
  2634  15   59:1    18   ELSE
  2635  15   59:2    20     IF COMMAND=DIGIT THEN REPEATFACTOR:=GETNUM ELSE REPEATFACTOR:=1;
  2636  15   59:1    37   CASE COMMAND OF 
  2637  15   59:1    40     ILLEGAL: BEGIN ERRWAIT; SHOWCURSOR; NEXTCOMMAND END;
  2638  15   59:1    50     REVERSEC,FORWARDC: FIXDIRECTION;
  2639  15   59:1    54     COPYC: COPY;
  2640  15   59:1    58     DUMPC: DUMP;
  2641  15   59:1    62     FINDC: FIND;
  2642  15   59:1    66     INSERTC: INSERTIT;
  2643  15   59:1    70     JUMPC: JUMP;
  2644  15   59:1    74     LISTC: NEXTCOMMAND; (* NOT YET, DEPENDS ON TERAK PAN *)
  2645  15   59:1    78     MACRODEFC: DEFMACRO;
  2646  15   59:1    82     QUITC: ; (* EXIT HANDLED IN OUTER BLOCK *)
  2647  15   59:1    84     REPLACEC: FIND;
  2648  15   59:1    88     SETC: SETSTUFF;
  2649  15   59:1    92     VERIFYC: VERIFY;
  2650  15   59:1    96     XECUTEC: XMACRO;
  2651  15   59:1   100     ZAPC: ZAPIT;
  2652  15   59:1   104     EQUALC: BEGIN
  2653  15   59:3   104       CURSOR:=LASTPAT;
  2654  15   59:3   107       GETLEADING;
  2655  15   59:3   110       CURSOR:=MAX(CURSOR,STUFFSTART);
  2656  15   59:3   119       CENTERCURSOR(TRASH,MIDDLE,FALSE); 
  2657  15   59:3   129       SHOWCURSOR; NEXTCOMMAND 
  2658  15   59:2   132     END;
  2659  15   59:1   136     ADJUSTC,DELETEC,PARAC,UP,DOWN,LEFT,RIGHT,ADVANCE,TAB,SPACE: MOVEIT
  2660  15   59:1   136   END (* BIG LONG CASE STATEMENT *);
  2661  15   59:0   204 END (* COMMANDER *);
  2662  15   59:0   218 
  2663  15    1:0     0 BEGIN (* Editcore *)
  2664  15    1:1     0   NEXTCOMMAND;
  2665  15    1:1     2   WHILE COMMAND<>QUITC DO COMMANDER
  2666  15    1:0     7 END;
  2667  15    1:0    26 
  2668  15    1:0    26 (* --- MISC      --- *)
  2669   1   12:D     3 FUNCTION MIN(* (A,B:INTEGER):INTEGER *);
  2670   1   12:0     0 BEGIN
  2671   1   12:1     0   IF A<B THEN MIN:=A ELSE MIN:=B
  2672   1   12:0    10 END;
  2673   1   12:0    26 
  2674   1   13:D     3 FUNCTION MAX (*(A,B:INTEGER):INTEGER*);
  2675   1   13:0     0 BEGIN
  2676   1   13:1     0   IF A>B THEN MAX:=A ELSE MAX:=B
  2677   1   13:0    10 END;
  2678   1   13:0    26 
  2679   1    4:D     3 FUNCTION GETCH(*:CHAR*);
  2680   1    4:D     3 VAR GCH: CHAR;
  2681   1    4:0     0 BEGIN
  2682   1    4:1     0   READ(KEYBOARD,GCH);
  2683   1    4:1     8   IF EOLN(KEYBOARD) THEN GCH:=CHR(EOL);
  2684   1    4:1    21   GETCH:=GCH;
  2685   1    4:0    24 END;
  2686   1    4:0    36 
  2687   1   16:D     1 PROCEDURE CONTROL(*(WHAT: SCREENCOMMAND)*);
  2688   1   16:0     0 BEGIN
  2689   1   16:1     0   WITH SCREEN DO
  2690   1   16:2     0     BEGIN
  2691   1   16:3     0       IF HASPREFIX[WHAT] THEN WRITE(PREFIX);
  2692   1   16:3    23       WRITE(CH[WHAT]);
  2693   1   16:3    35       WRITE(FILLIT); {So that the slower terminals can keep up<--M. Bernard}
  2694   1   16:2    44     END
  2695   1   16:0    44 END;
  2696   1   16:0    56 
  2697   1   14:D     3 FUNCTION SCREENHAS(*(WHAT: SCREENCOMMAND): BOOLEAN*);
  2698   1   14:0     0 BEGIN
  2699   1   14:1     0   SCREENHAS:=SCREEN.CH[WHAT]<>CHR(0);
  2700   1   14:0     9 END;
  2701   1   14:0    22 
  2702   1   15:D     3 FUNCTION HASKEY(*(WHAT: KEYCOMMAND): BOOLEAN*);
  2703   1   15:0     0 BEGIN
  2704   1   15:1     0   HASKEY:=KEYBRD.CH[WHAT] <> CHR(0);
  2705   1   15:0     9 END;
  2706   1   15:0    22 
  2707   1   33:D     3 FUNCTION MAPCRTCOMMAND(VAR KCH:CHAR): KEYCOMMAND;
  2708   1   33:D     4 VAR WHATITIS: KEYCOMMAND;
  2709   1   33:D     5     PREFIXREAD: BOOLEAN;
  2710   1   33:0     0 BEGIN
  2711   1   33:1     0   WITH KEYBRD DO
  2712   1   33:2     0   BEGIN
  2713   1   33:3     0     IF (KCH=PREFIX) AND (PREFIX <> CHR(0)) THEN
  2714   1   33:4    14       BEGIN
  2715   1   33:5    14 	PREFIXREAD:=TRUE;
  2716   1   33:5    17 	READ(KEYBOARD,KCH);
  2717   1   33:4    24       END
  2718   1   33:3    24     ELSE
  2719   1   33:4    26       PREFIXREAD:=FALSE;
  2720   1   33:3    29     WHATITIS:=BACKSPACEKEY;
  2721   1   33:3    32     WHILE (WHATITIS <> NOTLEGAL) AND NOT((CH[WHATITIS]=KCH) AND
  2722   1   33:3    43 	  (PREFIXREAD=HASPREFIX[WHATITIS])) DO
  2723   1   33:4    59       WHATITIS:=SUCC(WHATITIS);
  2724   1   33:3    66     MAPCRTCOMMAND:=WHATITIS;
  2725   1   33:2    69   END;
  2726   1   33:0    69 END;
  2727   1   33:0    84 
  2728   1    8:D     3 FUNCTION MAPTOCOMMAND(* (CH:CHAR): COMMANDS *);
  2729   1    8:D     4 (* For now, only the vector keys go through the new keyboard record *)
  2730   1    8:D     4 VAR KCMD: KEYCOMMAND;
  2731   1    8:0     0 BEGIN
  2732   1    8:1     0   IF (CH=KEYBRD.PREFIX) AND (CH<>CHR(0)) THEN
  2733   1    8:2    11     BEGIN
  2734   1    8:3    11       KCMD:=MAPCRTCOMMAND(CH);
  2735   1    8:3    19       IF KCMD IN [UPKEY..RIGHTKEY] THEN
  2736   1    8:4    27 	CASE KCMD OF
  2737   1    8:4    30 	  UPKEY:    MAPTOCOMMAND:=UP;
  2738   1    8:4    35 	  DOWNKEY:  MAPTOCOMMAND:=DOWN;
  2739   1    8:4    40 	  LEFTKEY:  MAPTOCOMMAND:=LEFT;
  2740   1    8:4    45 	  RIGHTKEY: MAPTOCOMMAND:=RIGHT
  2741   1    8:4    45 	END
  2742   1    8:2    66     END
  2743   1    8:1    66   ELSE
  2744   1    8:2    68     MAPTOCOMMAND:=TRANSLATE[CH]
  2745   1    8:0    74 END;
  2746   1    8:0    90 
  2747   1    9:D     3 FUNCTION UCLC(*(CH:CHAR):CHAR*); (* Map Lower Case to Upper Case *)
  2748   1    9:0     0 BEGIN
  2749   1    9:1     0   IF CH IN ['a'..'z'] THEN UCLC:=CHR(ORD(CH)-32) ELSE UCLC:=CH
  2750   1    9:0    31 END;
  2751   1    9:0    46 
  2752   1   10:D     1 PROCEDURE PROMPT;
  2753   1   10:0     0 BEGIN
  2754   1   10:1     0   PROMPTLINE[1]:=DIRECTION;
  2755   1   10:1     6   SAVETOP:=PROMPTLINE;
  2756   1   10:1    14   CONTROL(WHOME);
  2757   1   10:1    17   CLEARLINE(0);
  2758   1   10:1    20   WRITE(PROMPTLINE)
  2759   1   10:0    30 END;
  2760   1   10:0    42 
  2761   1    5:D     1 PROCEDURE CLEARSCREEN;
  2762   1    5:D     1 VAR I:INTEGER;
  2763   1    5:0     0 BEGIN
  2764   1    5:1     0   IF SCREENHAS(CLEARSCN) THEN 
  2765   1    5:2     7     CONTROL(CLEARSCN)
  2766   1    5:1     8   ELSE
  2767   1    5:2    12     BEGIN
  2768   1    5:3    12       HOME;
  2769   1    5:3    14       ERASEOS(0,0)
  2770   1    5:2    16     END;
  2771   1    5:0    18 END;
  2772   1    5:0    30 
  2773   1    7:D     1 PROCEDURE CLEARLINE(*Y:INTEGER*);
  2774   1    7:D     2 VAR I: INTEGER;
  2775   1    7:0     0 BEGIN
  2776   1    7:1     0   IF SCREENHAS(CLEARLNE) THEN
  2777   1    7:2     7     CONTROL(CLEARLNE)
  2778   1    7:1     8   ELSE
  2779   1    7:2    12     BEGIN
  2780   1    7:3    12       GOTOXY(0,Y);
  2781   1    7:3    17       ERASETOEOL(0,Y);
  2782   1    7:2    21     END;
  2783   1    7:0    21 END;
  2784   1    7:0    34 
  2785   1   17:D     1 PROCEDURE PUTMSG;
  2786   1   17:0     0 BEGIN
  2787   1   17:1     0   CONTROL(WHOME);
  2788   1   17:1     3   CLEARLINE(0);
  2789   1   17:1     6   SAVETOP:=MSG;
  2790   1   17:1    14   WRITE(MSG);
  2791   1   17:0    24 END;
  2792   1   17:0    36 
  2793   1   18:D     1 PROCEDURE HOME;
  2794   1   18:0     0 BEGIN 
  2795   1   18:1     0   IF SCREENHAS(WHOME) THEN
  2796   1   18:2     7     CONTROL(WHOME)
  2797   1   18:1     8   ELSE
  2798   1   18:2    12     GOTOXY(0,0);
  2799   1   18:0    17 END;
  2800   1   18:0    30 
  2801   1    3:D     1 PROCEDURE ERASETOEOL(*X,LINE:INTEGER*);
  2802   1    3:D     3 VAR I: INTEGER;
  2803   1    3:0     0 BEGIN
  2804   1    3:1     0   IF SCREENHAS(ERASEEOL) THEN CONTROL(ERASEEOL)
  2805   1    3:1     8   ELSE
  2806   1    3:2    12     BEGIN
  2807   1    3:3    12       IF LINE=SCREENHEIGHT THEN UNITWRITE(2,BLANKAREA,SCREENWIDTH-X)
  2808   1    3:3    29       ELSE UNITWRITE(2,BLANKAREA,SCREENWIDTH-X+1);
  2809   1    3:3    45       GOTOXY(X,LINE)
  2810   1    3:2    50     END;
  2811   1    3:0    50 END;
  2812   1    3:0    62 
  2813   1   20:D     1 PROCEDURE BLANKCRT(*Y: INTEGER*);
  2814   1   20:0     0 BEGIN
  2815   1   20:1     0   IF SCREENHAS(ERASEEOS) THEN BEGIN GOTOXY(0,Y); CONTROL(ERASEEOS) END
  2816   1   20:1    15   ELSE
  2817   1   20:2    17     IF Y=1 THEN
  2818   1   20:3    22       BEGIN
  2819   1   20:4    22 	CLEARSCREEN;
  2820   1   20:4    24 	WRITELN(SAVETOP)
  2821   1   20:3    40       END
  2822   1   20:2    40     ELSE
  2823   1   20:3    42       BEGIN
  2824   1   20:4    42 	GOTOXY(0,Y);
  2825   1   20:4    47 	ERASEOS(0,Y);
  2826   1   20:3    51       END;
  2827   1   20:0    51 END;
  2828   1   20:0    64 
  2829   1    6:D     1 PROCEDURE ERASEOS(*X,LINE*);
  2830   1    6:D     3 VAR I: INTEGER;
  2831   1    6:0     0 BEGIN
  2832   1    6:1     0   IF SCREENHAS(ERASEEOS) THEN
  2833   1    6:2     7     CONTROL(ERASEEOS)
  2834   1    6:1     8   ELSE
  2835   1    6:2    12     BEGIN
  2836   1    6:3    12       ERASETOEOL(X,LINE);
  2837   1    6:3    16       FOR I:=LINE+1 TO SCREENHEIGHT DO BEGIN WRITELN; CLEARLINE(I) END;
  2838   1    6:3    45       GOTOXY(X,LINE);
  2839   1    6:2    50     END;
  2840   1    6:0    50 END;
  2841   1    6:0    64 
  2842   1   19:D     1 PROCEDURE ERRWAIT;
  2843   1   19:0     0 BEGIN
  2844   1   19:1     0   WRITE(CHR(BELL));
  2845   1   19:1     8   PROMPT;
  2846   1   19:0    10 END;
  2847   1   19:0    22 
  2848   1   19:0    22 
  2849   1    2:D     1 PROCEDURE ERROR(*S: STRING;HOWBAD: ERRORTYPE*);
  2850   1    2:0     0 BEGIN
  2851   1    2:1     0   UNITCLEAR(1); (* Throw away all characters queued up *)
  2852   1    2:1     8   IF HOWBAD=FATAL THEN
  2853   1    2:2    13     BLANKCRT(1)
  2854   1    2:1    14   ELSE
  2855   1    2:2    18     BEGIN HOME; CLEARLINE(0) END;
  2856   1    2:1    23   WRITE('ERROR: ',S);
  2857   1    2:1    49   IF HOWBAD=FATAL THEN
  2858   1    2:2    54     EXIT(EDITOR)
  2859   1    2:1    58   ELSE
  2860   1    2:2    60     BEGIN
  2861   1    2:3    60       WRITE('  Please press <spacebar> to continue.');
  2862   1    2:3   108       REPEAT UNTIL GETCH=' '; NEEDPROMPT:=TRUE
  2863   1    2:2   116     END;
  2864   1    2:0   120 END;
  2865   1    2:0   134 
  2866   1    2:0   134 (* --- UTIL      --- *)
  2867   1   21:D     3 FUNCTION LEADBLANKS(* (PTR: PTRTYPE; VAR BYTES: INTEGER): INTEGER *);
  2868   1   21:D     5 (* On entry-
  2869   1   21:D     5       PTR points to the beginning of a line
  2870   1   21:D     5    On exit-
  2871   1   21:D     5       function returns the number of leading blanks on that line.
  2872   1   21:D     5       bytes has the offset into the line of the first non-blank character *) 
  2873   1   21:D     5 VAR
  2874   1   21:D     5   OLDPTR: PTRTYPE;
  2875   1   21:D     6   INDENT: INTEGER;
  2876   1   21:0     0 BEGIN
  2877   1   21:1     0   OLDPTR:=PTR; INDENT:=0;
  2878   1   21:1     6   WHILE ORD(EBUF^[PTR]) IN [HT,SP,DLE] DO
  2879   1   21:2    22     BEGIN
  2880   1   21:3    22       IF EBUF^[PTR]=CHR(DLE) THEN
  2881   1   21:4    30 	BEGIN PTR:=PTR+1; INDENT:=INDENT+ORD(EBUF^[PTR])-32 END
  2882   1   21:3    45       ELSE
  2883   1   21:4    47 	IF ORD(EBUF^[PTR])=SP THEN INDENT:=INDENT+1
  2884   1   21:4    56 	ELSE 
  2885   1   21:5    62 	  (*HT*) INDENT:=((INDENT DIV 8)+1)*8;  (* KLUDGE FOR COLUMNAR TAB! *)
  2886   1   21:3    71       PTR:=PTR+1
  2887   1   21:2    72     END;
  2888   1   21:1    78   BYTES:=PTR-OLDPTR;
  2889   1   21:1    83   LEADBLANKS:=INDENT;
  2890   1   21:0    86 END(*LEADBLANKS*);
  2891   1   21:0   100 
  2892   1   11:D     1 PROCEDURE REDISPLAY;
  2893   1   11:D     1 (* Do a total update of the screen.  Note that this code is partially a
  2894   1   11:D     1    duplicate of lineout/upscreen for reasons of speed.  This procedure is
  2895   1   11:D     1    called only from centercursor *)
  2896   1   11:D     1 VAR
  2897   1   11:D     1   LINEDIST,EOLDIST,LINE: INTEGER;
  2898   1   11:D     4   PTR: PTRTYPE;
  2899   1   11:D     5   T: PACKED ARRAY [0..MAXSW] OF CHAR;
  2900   1   11:0     0 BEGIN
  2901   1   11:1     0   BLANKCRT(1);
  2902   1   11:1     3   LINE:=1;
  2903   1   11:1     6   PTR:=LINE1PTR;
  2904   1   11:1    11   REPEAT
  2905   1   11:2    11     BLANKS:=MIN(LEADBLANKS(PTR,BYTES),SCREENWIDTH);
  2906   1   11:2    25     GOTOXY(BLANKS,LINE);
  2907   1   11:2    30     PTR:=PTR+BYTES;
  2908   1   11:2    35     EOLDIST:=SCAN(MAXCHAR,=CHR(EOL),EBUF^[PTR]);
  2909   1   11:2    48     LINEDIST:=MAX(0,MIN(EOLDIST,SCREENWIDTH-BLANKS+1));
  2910   1   11:2    65     MOVELEFT(EBUF^[PTR],T[0],LINEDIST);
  2911   1   11:2    74     IF EBUF^[PTR+LINEDIST]<>CHR(EOL) THEN (* Line truncation *)
  2912   1   11:3    84       T[MAX(0,LINEDIST-1)]:='!';
  2913   1   11:2    96     WRITE(T:LINEDIST);
  2914   1   11:2   106     PTR:=PTR+EOLDIST+1; LINE:=LINE+1
  2915   1   11:1   114   UNTIL (LINE>SCREENHEIGHT) OR (PTR>=BUFCOUNT)
  2916   1   11:0   124 END;
  2917   1   11:0   142 
  2918   1    1:D     1 PROCEDURE CENTERCURSOR
  2919   1   22:D     4 (*VAR LINE: INTEGER; LINESUP: INTEGER; NEWSCREEN: BOOLEAN*);
  2920   1   22:D     4 (* Figure out if the cursor is still on the screen.  If it is, and
  2921   1   22:D     4    newscreen is false, then no redisplay is done.  Otherwise an attempt
  2922   1   22:D     4    is made to position the cursor at line "linesup".  line is then updated
  2923   1   22:D     4    to the actual line the cursor was forced to. *)
  2924   1   22:D     4 VAR
  2925   1   22:D     4   MARK: INTEGER;
  2926   1   22:D     5   PTR: PTRTYPE;
  2927   1   22:0     0 BEGIN
  2928   1   22:1     0   IF EBUF^[CURSOR]=CHR(EOL) THEN PTR:=CURSOR ELSE PTR:=CURSOR+1;
  2929   1   22:1    18   LINE:=0;
  2930   1   22:1    21   REPEAT
  2931   1   22:2    21     PTR:=PTR-1;
  2932   1   22:2    26     PTR:=SCAN(-MAXCHAR,=CHR(EOL),EBUF^[PTR])+PTR;
  2933   1   22:2    42     LINE:=LINE+1;
  2934   1   22:2    48     IF LINE=LINESUP THEN MARK:=PTR;
  2935   1   22:1    57   UNTIL (LINE>SCREENHEIGHT) OR ((LINE1PTR=PTR+1) AND NOT NEWSCREEN) OR (PTR<1);
  2936   1   22:1    78   IF LINE>SCREENHEIGHT THEN (* Off the screen *)
  2937   1   22:2    84     BEGIN LINE1PTR:=MARK+1; REDISPLAY; LINE:=LINESUP END
  2938   1   22:1    95   ELSE
  2939   1   22:2    97     IF LINE1PTR=PTR+1 THEN 
  2940   1   22:3   106       BEGIN
  2941   1   22:4   106 	IF NEWSCREEN THEN REDISPLAY
  2942   1   22:3   109       END
  2943   1   22:2   111     ELSE
  2944   1   22:3   113       BEGIN
  2945   1   22:4   113 	LINE1PTR:=1; REDISPLAY
  2946   1   22:3   117       END;
  2947   1   22:0   119 END;
  2948   1   22:0   134 
  2949   1   23:D     1 PROCEDURE FINDXY(*VAR INDENT,LINE: INTEGER*);
  2950   1   23:D     3 VAR
  2951   1   23:D     3   I,LEAD: INTEGER;
  2952   1   23:D     5   PTR,EOLPTR: PTRTYPE;
  2953   1   23:0     0 BEGIN
  2954   1   23:0     0   (* Place CRT cursor on the screen at the position corresponding
  2955   1   23:0     0      to the logical cursor. *)
  2956   1   23:1     0   LINE:=1;
  2957   1   23:1     3   PTR:=LINE1PTR;
  2958   1   23:1     8   EOLPTR:=SCAN(MAXCHAR,=CHR(EOL),EBUF^[PTR])+PTR;
  2959   1   23:1    23   WHILE EOLPTR<CURSOR DO
  2960   1   23:2    28     BEGIN
  2961   1   23:3    28       LINE:=LINE+1; PTR:=EOLPTR+1; (* Set up for the next line *)
  2962   1   23:3    39       EOLPTR:=SCAN(MAXCHAR,=CHR(EOL),EBUF^[PTR])+PTR
  2963   1   23:2    50     END;
  2964   1   23:2    56   (* Now find the indentation on that line of the cursor *)
  2965   1   23:1    56   LEAD:=LEADBLANKS(PTR,I);
  2966   1   23:1    65   INDENT:=MIN(SCREENWIDTH,(LEAD-I)+(CURSOR-PTR));
  2967   1   23:1    79 			  (* (extra spaces) + (offset into line) *)
  2968   1   23:0    79 END;(* FINDXY *)
  2969   1   23:0    94 
  2970   1   24:D     1 PROCEDURE SHOWCURSOR;
  2971   1   24:D     1 VAR
  2972   1   24:D     1   X,Y: INTEGER;
  2973   1   24:0     0 BEGIN
  2974   1   24:1     0   FINDXY(X,Y);
  2975   1   24:1     6   GOTOXY(X,Y)
  2976   1   24:0    11 END(* SHOWCURSOR *);
  2977   1   24:0    24 
  2978   1   25:D     3 FUNCTION GETNUM(*:INTEGER*);
  2979   1   25:D     3 VAR 
  2980   1   25:D     3   N: INTEGER;
  2981   1   25:D     4   OVERFLOW: BOOLEAN;
  2982   1   25:0     0 BEGIN
  2983   1   25:1     0   N:=0;
  2984   1   25:1     3   OVERFLOW:=FALSE;
  2985   1   25:1     6   IF NOT (CH IN ['0'..'9']) THEN N:=1
  2986   1   25:1    23   ELSE
  2987   1   25:2    28     REPEAT
  2988   1   25:3    28       IF N > 1000 THEN OVERFLOW:=TRUE
  2989   1   25:3    35       ELSE
  2990   1   25:4    40 	BEGIN
  2991   1   25:5    40 	  N:=N*10+ORD(CH)-ORD('0');
  2992   1   25:5    49 	  CH:=GETCH
  2993   1   25:4    49 	END
  2994   1   25:2    55     UNTIL (NOT (CH IN ['0'..'9'])) OR OVERFLOW;
  2995   1   25:1    73   IF OVERFLOW THEN
  2996   1   25:2    76     BEGIN
  2997   1   25:3    76       ERROR('Repeatfactor > 10,000',NONFATAL);
  2998   1   25:3   103       GETNUM:=0;
  2999   1   25:2   106     END
  3000   1   25:1   106   ELSE
  3001   1   25:2   108     GETNUM:=N;
  3002   1   25:1   111   COMMAND:=MAPTOCOMMAND(CH); (* Takes CH and maps it to a command *)
  3003   1   25:0   118 END;
  3004   1   25:0   132 
  3005   1   26:D     1 PROCEDURE GETLEADING;
  3006   1   26:0     0 BEGIN
  3007   1   26:0     0   (* Sets:
  3008   1   26:0     0 	LINESTART ......... A pointer to the beginning of the line
  3009   1   26:0     0 	STUFFSTART ........ A pointer to the beginning of the text on the line 
  3010   1   26:0     0 	BYTES ............. The number of bytes between LINESTART and
  3011   1   26:0     0 			    STUFFSTART
  3012   1   26:0     0 	BLANKS ............ The indentation of the line    *)
  3013   1   26:1     0   LINESTART:=CURSOR;
  3014   1   26:1     3   IF EBUF^[LINESTART]=CHR(EOL) THEN LINESTART:=LINESTART-1; (* for scan! *)
  3015   1   26:1    16   LINESTART:=SCAN(-MAXCHAR,=CHR(EOL),EBUF^[LINESTART])+LINESTART+1;
  3016   1   26:1    34   BLANKS:=LEADBLANKS(LINESTART,BYTES);
  3017   1   26:1    43   STUFFSTART:=LINESTART+BYTES
  3018   1   26:0    44 END (* GETLEADING *);
  3019   1   26:0    60 
  3020   1   27:D     3 FUNCTION OKTODEL (* (CURSOR,ANCHOR: PTRTYPE):BOOLEAN *) ;
  3021   1   27:0     0 BEGIN
  3022   1   27:1     0   IF ABS(CURSOR-ANCHOR)>(BUFSIZE-BUFCOUNT)+10 THEN
  3023   1   27:2    12     BEGIN
  3024   1   27:3    12       MSG:=
  3025   1   27:3    15 'There is no room to copy the deletion.  Do you wish to delete anyway? (y/n)';
  3026   1   27:3    95       PUTMSG;
  3027   1   27:3    97       IF UCLC(GETCH)='Y' THEN OKTODEL:=TRUE ELSE OKTODEL:=FALSE;
  3028   1   27:2   117     END
  3029   1   27:1   117   ELSE
  3030   1   27:2   119     BEGIN
  3031   1   27:2   119       (* COPYLINE is set by the caller *)
  3032   1   27:3   119       COPYOK:=TRUE; COPYLENGTH:=ABS(CURSOR-ANCHOR);
  3033   1   27:3   130       COPYSTART:=BUFSIZE-COPYLENGTH+1;
  3034   1   27:3   140       MOVELEFT(EBUF^[MIN(CURSOR,ANCHOR)],EBUF^[COPYSTART],COPYLENGTH);
  3035   1   27:3   158       OKTODEL:=TRUE
  3036   1   27:2   158     END;
  3037   1   27:0   161 END;
  3038   1   27:0   174 
  3039   1   27:0   174 
  3040   1   28:D     1 PROCEDURE LINEOUT(*VAR PTR:PTRTYPE; BYTES,BLANKS,LINE:INTEGER*);
  3041   1   28:D     5 (* Write a line out *)
  3042   1   28:D     5 VAR 
  3043   1   28:D     5   LINEDIST,EOLDIST: INTEGER;
  3044   1   28:D     7   T: PACKED ARRAY [0..MAXSW] OF CHAR;
  3045   1   28:0     0 BEGIN
  3046   1   28:1     0   GOTOXY(BLANKS,LINE);
  3047   1   28:1     5   PTR:=PTR+BYTES;
  3048   1   28:1    11   EOLDIST:=SCAN(MAXCHAR,=CHR(EOL),EBUF^[PTR]);
  3049   1   28:1    25   LINEDIST:=MAX(0,MIN(EOLDIST,SCREENWIDTH-BLANKS+1));
  3050   1   28:1    42   MOVELEFT(EBUF^[PTR],T[0],LINEDIST);
  3051   1   28:1    52   IF EBUF^[PTR+LINEDIST]<>CHR(EOL) THEN (* Line truncation *)
  3052   1   28:2    63     BEGIN
  3053   1   28:3    63       LINEDIST:=MAX(LINEDIST,1);
  3054   1   28:3    71       T[LINEDIST-1]:='!';
  3055   1   28:2    78     END;
  3056   1   28:1    78   WRITE(T:LINEDIST);
  3057   1   28:1    88   PTR:=PTR+EOLDIST+1
  3058   1   28:0    93 END;
  3059   1   28:0   108 
  3060   1   29:D     1 PROCEDURE UPSCREEN(*FIRSTLINE,WHOLESCREEN: BOOLEAN; LINE: INTEGER*);
  3061   1   29:D     4 (* Zap, Insert and Delete call this procedure to update (possibly partially)
  3062   1   29:D     4    the screen.  FIRSTLINE means only the line that the cursor is on need
  3063   1   29:D     4    be updated.  WHOLESCREEN means that everything must be updated.  If 
  3064   1   29:D     4    neither of these is true then only the part of the screen that's after
  3065   1   29:D     4    the cursor is updated *)
  3066   1   29:D     4 VAR
  3067   1   29:D     4   PTR: PTRTYPE;
  3068   1   29:D     5 
  3069   1   29:0     0 BEGIN (* Upscreen *)
  3070   1   29:1     0   IF FIRSTLINE THEN
  3071   1   29:2     3     BEGIN
  3072   1   29:3     3       GETLEADING;
  3073   1   29:3     5       GOTOXY(0,LINE); ERASETOEOL(0,LINE); (* Clean the line *)
  3074   1   29:3    14       LINEOUT(LINESTART,BYTES,BLANKS,LINE) (* Just this line *)
  3075   1   29:2    19     END
  3076   1   29:1    21   ELSE
  3077   1   29:2    23     IF WHOLESCREEN THEN
  3078   1   29:3    26       CENTERCURSOR(TRASH,MIDDLE,TRUE)
  3079   1   29:2    33     ELSE (* Only update the part of the screen after the cursor *)
  3080   1   29:3    37       BEGIN
  3081   1   29:4    37 	GOTOXY(0,LINE); ERASEOS(0,LINE);
  3082   1   29:4    46 	GETLEADING;
  3083   1   29:4    48 	PTR:=LINESTART;
  3084   1   29:4    51 	REPEAT
  3085   1   29:5    51 	  BLANKS:=MIN(LEADBLANKS(PTR,BYTES),SCREENWIDTH);
  3086   1   29:5    65 	  LINEOUT(PTR,BYTES,BLANKS,LINE); (* Writes out the line at ptr *)
  3087   1   29:5    72 	  LINE:=LINE+1
  3088   1   29:4    73 	UNTIL (LINE>SCREENHEIGHT) OR (PTR>=BUFCOUNT)
  3089   1   29:3    83       END;
  3090   1   29:0    86 END;
  3091   1   29:0   100 
  3092   1   30:D     1 PROCEDURE READJUST(*CURSOR:PTRTYPE; DELTA: INTEGER*);
  3093   1   30:D     3 (* if DELTA<0 then move all affected markers to CURSOR.  Also adjust all
  3094   1   30:D     3    markers >= CURSOR by DELTA *)
  3095   1   30:D     3 VAR
  3096   1   30:D     3   I: INTEGER;
  3097   1   30:0     0 BEGIN
  3098   1   30:1     0   WITH PAGEZERO DO
  3099   1   30:2     0     FOR I:=0 TO COUNT-1 DO
  3100   1   30:3    15       IF POFFSET[I]>=CURSOR THEN POFFSET[I]:=MAX(POFFSET[I]+DELTA,CURSOR);
  3101   1   30:1    54   IF (COPYSTART>=CURSOR) AND (COPYSTART<BUFCOUNT) THEN
  3102   1   30:2    67     COPYSTART:=MAX(COPYSTART+DELTA,CURSOR);
  3103   1   30:0    80 END;
  3104   1   30:0    94 
  3105   1   31:D     1 PROCEDURE THEFIXER(*PARAPTR:PTRTYPE;RFAC:INTEGER;WHOLE:BOOLEAN*);
  3106   1   31:D     4 (* PARAPTR points somewhere in a paragraph.  If WHOLE is true then the
  3107   1   31:D     4    entire paragraph is filled, otherwise only that directly after the cursor
  3108   1   31:D     4    is filled.  RFAC, when implemented will tell how many paragraphs to be
  3109   1   31:D     4    filled.  Note: A paragraph is defined as lines of text delimited by a line
  3110   1   31:D     4    with no text on it whatsoever, or a line of a text whose first character is
  3111   1   31:D     4    RUNOFFCH *)
  3112   1   31:D     4 
  3113   1   31:D     4 VAR
  3114   1   31:D     4   SAVE,PTR,WPTR: INTEGER;
  3115   1   31:D     7   WLENGTH,X: INTEGER;
  3116   1   31:D     9   DONE: BOOLEAN;
  3117   1   31:0     0 BEGIN
  3118   1   31:1     0   WITH PAGEZERO DO
  3119   1   31:2     0     BEGIN
  3120   1   31:3     0       SAVE:=CURSOR;
  3121   1   31:3     3       CURSOR:=PARAPTR;
  3122   1   31:3     6       GETLEADING;
  3123   1   31:3     8       IF EBUF^[STUFFSTART] IN [CHR(EOL),RUNOFFCH] THEN EXIT(THEFIXER);
  3124   1   31:3    26       IF WHOLE THEN (* Scan backwards for the beginning of the paragraph *)
  3125   1   31:4    29 	BEGIN
  3126   1   31:5    29 	  REPEAT
  3127   1   31:6    29 	    CURSOR:=LINESTART-1;
  3128   1   31:6    34 	    GETLEADING
  3129   1   31:5    34 	  UNTIL (LINESTART<=1) OR (EBUF^[STUFFSTART] IN [RUNOFFCH,CHR(EOL)]);
  3130   1   31:5    54 	  IF EBUF^[STUFFSTART] IN [RUNOFFCH,CHR(EOL)] THEN
  3131   1   31:6    68 	    PTR:=CURSOR+1
  3132   1   31:5    69 	  ELSE
  3133   1   31:6    75 	    PTR:=1;
  3134   1   31:5    78 	  X:=PARAMARGIN;
  3135   1   31:4    83 	END
  3136   1   31:3    83       ELSE
  3137   1   31:4    85 	BEGIN
  3138   1   31:5    85 	  PTR:=LINESTART;
  3139   1   31:5    88 	  IF BLANKS=PARAMARGIN THEN X:=PARAMARGIN ELSE X:=LMARGIN
  3140   1   31:4   102 	END;
  3141   1   31:3   107       CURSOR:=BUFSIZE-(BUFCOUNT-PTR)+1; (* Split the buffer *)
  3142   1   31:3   116       MOVERIGHT(EBUF^[PTR],EBUF^[CURSOR],BUFCOUNT-PTR);
  3143   1   31:3   127       (* Now dribble back the (rest of the) paragraph *)
  3144   1   31:3   127       EBUF^[PTR]:=CHR(DLE);
  3145   1   31:3   132       EBUF^[PTR+1]:=CHR(X+32);
  3146   1   31:3   141       PTR:=PTR+2;
  3147   1   31:3   146       EBUF^[CURSOR-1]:=CHR(EOL); (* sentinel for getleading *)
  3148   1   31:3   153       DONE:=FALSE;
  3149   1   31:3   156       REPEAT
  3150   1   31:4   156 	WHILE EBUF^[CURSOR] IN [CHR(HT),CHR(SP),CHR(DLE)] DO
  3151   1   31:5   171 	  IF EBUF^[CURSOR]=CHR(DLE) THEN CURSOR:=CURSOR+2 ELSE CURSOR:=CURSOR+1;
  3152   1   31:4   193 	WPTR:=CURSOR;
  3153   1   31:4   196 	(* Skip over a token *)
  3154   1   31:4   196 	WHILE NOT (EBUF^[CURSOR] IN [CHR(EOL),' ','-']) DO CURSOR:=CURSOR+1;
  3155   1   31:4   223 	(* Special cases for ".<sp><sp>" and "-<sp>" *)
  3156   1   31:4   223 	IF EBUF^[CURSOR]='-' THEN IF EBUF^[CURSOR+1]=' ' THEN CURSOR:=CURSOR+1;
  3157   1   31:4   246 	IF (EBUF^[CURSOR-1]='.') THEN IF 
  3158   1   31:5   256 	   (EBUF^[CURSOR]=' ') AND (EBUF^[CURSOR+1]=' ') THEN CURSOR:=CURSOR+1;
  3159   1   31:4   278 	WLENGTH:=CURSOR-WPTR+1; (* Including the delimiter *)
  3160   1   31:4   285 	IF (X+WLENGTH>RMARGIN) OR (RMARGIN-LMARGIN+1<=WLENGTH) THEN
  3161   1   31:5   306 	  BEGIN
  3162   1   31:6   306 	    IF EBUF^[PTR-1]=' ' THEN PTR:=PTR-1;
  3163   1   31:6   321 	    EBUF^[PTR]:=CHR(EOL); EBUF^[PTR+1]:=CHR(DLE); 
  3164   1   31:6   333 	    EBUF^[PTR+2]:=CHR(LMARGIN+32); 
  3165   1   31:6   344 	    PTR:=PTR+3;
  3166   1   31:6   349 	    X:=LMARGIN
  3167   1   31:5   349 	  END;
  3168   1   31:4   354 	CURSOR:=CURSOR+1;
  3169   1   31:4   359 	MOVELEFT(EBUF^[WPTR],EBUF^[PTR],WLENGTH);
  3170   1   31:4   368 	IF EBUF^[CURSOR-1]=CHR(EOL) THEN
  3171   1   31:5   378 	  BEGIN
  3172   1   31:6   378 	    IF EBUF^[CURSOR]=CHR(0) THEN DONE:=TRUE
  3173   1   31:6   386 	    ELSE
  3174   1   31:7   391 	      BEGIN
  3175   1   31:8   391 		GETLEADING;
  3176   1   31:8   393 		DONE:=(EBUF^[STUFFSTART]=CHR(EOL)) 
  3177   1   31:8   399 		      OR (EBUF^[STUFFSTART]=RUNOFFCH);
  3178   1   31:8   410 		(* The last transfer will move 
  3179   1   31:8   410 		   over the <eol> for the paragraph *)
  3180   1   31:8   410 		IF NOT DONE THEN
  3181   1   31:9   414 		  BEGIN
  3182   1   31:0   414 		    EBUF^[PTR+WLENGTH-1]:=' ';
  3183   1   31:0   423 	            (* If <eol> <sp>, map to one space only *)
  3184   1   31:0   423 		    IF EBUF^[CURSOR-2]=' ' THEN PTR:=PTR-1;
  3185   1   31:9   438 		  END
  3186   1   31:7   438 	      END
  3187   1   31:5   438 	  END;
  3188   1   31:4   438 	X:=X+WLENGTH;
  3189   1   31:4   443 	PTR:=PTR+WLENGTH;
  3190   1   31:3   448       UNTIL DONE;
  3191   1   31:3   451       READJUST(PARAPTR,(BUFSIZE-CURSOR+PTR+1)-BUFCOUNT);
  3192   1   31:3   463       BUFCOUNT:=BUFSIZE-CURSOR+PTR+1;
  3193   1   31:3   472       MOVELEFT(EBUF^[CURSOR],EBUF^[PTR],BUFSIZE-CURSOR+1);
  3194   1   31:3   485       EBUF^[BUFCOUNT]:=CHR(0);
  3195   1   31:3   490       CURSOR:=MIN(BUFCOUNT-1,SAVE);
  3196   1   31:3   500       GETLEADING;
  3197   1   31:3   502       CURSOR:=MAX(CURSOR,STUFFSTART)
  3198   1   31:2   504    END;
  3199   1   31:0   510 END;
  3200   1   31:0   530 
  3201   1   32:D     1 PROCEDURE GETNAME(*MSG:STRING; VAR M:NAME*);
  3202   1   32:D    44 VAR
  3203   1   32:D    44   I: INTEGER;
  3204   1   32:D    45   S: STRING;
  3205   1   32:0     0 BEGIN
  3206   1   32:1     0   NEEDPROMPT:=TRUE; HOME; CLEARLINE(0); WRITE(MSG,' what marker? ');
  3207   1   32:1    47   READLN(S);
  3208   1   32:1    62   FOR I:=1 TO LENGTH(S) DO S[I]:=UCLC(S[I]);
  3209   1   32:1   100   MOVELEFT(S[1],M[0],MIN(8,LENGTH(S)));
  3210   1   32:1   116   FILLCHAR(M[LENGTH(S)],MAX(0,8-LENGTH(S)),' ')
  3211   1   32:0   135 END;
  3212   1   32:0   150 
  3213   1    1:0     0 BEGIN (* Segment procedure EDITOR *)
  3214   1    1:1     0   INITIALIZE; GETLEADING; CURSOR:=MAX(CURSOR,STUFFSTART);
  3215   1    1:1    26   REPEAT
  3216   1    1:2    26     CENTERCURSOR(TRASH,(SCREENHEIGHT DIV 2)+1,TRUE);
  3217   1    1:2    37     NEEDPROMPT:=TRUE;
  3218   1    1:2    41     IF USERINFO.ERRBLK>0 THEN PUTSYNTAX;
  3219   1    1:2    51     REPEAT
  3220   1    1:3    51       HOME; CLEARLINE(0);
  3221   1    1:3    56       EDITCORE;
  3222   1    1:3    59       IF COMMAND=SETC THEN ENVIRONMENT
  3223   1    1:3    64       ELSE IF COMMAND=COPYC THEN COPYFILE
  3224   1    1:2    74     UNTIL COMMAND=QUITC;
  3225   1    1:1    82   UNTIL OUT;
  3226   1    1:1    89   SYSCOM^.MISCINFO.NOBREAK := FALSE  (* 28 SEPT 77*)
  3227   1    1:0    96 END;
  3228   1    1:0   122 
  3229   0    1:0     0 BEGIN END.
