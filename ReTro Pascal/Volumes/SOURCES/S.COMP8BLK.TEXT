
{.fs} (* --- original source filename: PROCS.A.TEXT --- *)

    (******************************************************************)
    (*                                                                *)
    (*  Copyright (c) l979 Regents of the University of California.   *)
    (*  Permission to copy or distribute this software or documen-    *)
    (*  tation in hard or soft copy granted only by written license   *) 
    (*  obtained from the Institute for Information Systems.          *)
    (*                                                                *)
    (******************************************************************)

PROCEDURE ERROR(*ERRORNUM: INTEGER*);
  VAR CH: CHAR; ERRSTART: INTEGER;
      A: PACKED ARRAY [0..179] OF CHAR;
{.fs} CANEDIT: BOOLEAN;
BEGIN
  WITH USERINFO DO
    IF (ERRSYM <> SYMCURSOR) OR (ERRBLK <> SYMBLK) THEN
      BEGIN ERRBLK := SYMBLK;
	ERRSYM := SYMCURSOR; ERRNUM := ERRORNUM;
	IF STUPID THEN CH := 'E'
	ELSE
	  BEGIN
	    IF NOISY THEN WRITELN(OUTPUT)
	    ELSE
	      IF LIST AND (ERRORNUM <= 400) THEN
		EXIT(ERROR);
	    IF LINESTART = 0 THEN
	      WRITE(OUTPUT,SYMBUFP^:SYMCURSOR)
	    ELSE
	      BEGIN
		ERRSTART := SCAN(-(LINESTART-1),=CHR(EOL),
				    SYMBUFP^[LINESTART-2])+LINESTART-1;
		MOVELEFT(SYMBUFP^[ERRSTART],A[0],SYMCURSOR-ERRSTART);
		WRITE(OUTPUT,A:SYMCURSOR-ERRSTART)
	      END;
	    WRITELN(OUTPUT,' <<<<');
{.fs}       IF INCLUDING THEN
{.fs}         WRITE(OUTPUT,INCLNAME,         ' line ',SCREENDOTS,', error ',ERRORNUM:0,':')
{.fs}       ELSE  { shell does not tell us the source path, so we cannot show it }
	    WRITE(OUTPUT,'Line ',SCREENDOTS,', error ',ERRORNUM:0,':');
{.fs}       CANEDIT := NOT GOTSYM OR NOT INCLUDING;
{.fs}       { We can E(dit if error in main work file or if there is none, such  }
{.fs}       { that editor will prompt for the name (which we show for includes). }
	    IF NOISY THEN
{.fs}         IF NOT CANEDIT THEN
{.fs}           WRITE(OUTPUT,' <space>(continue), <esc>(terminate)')
{.fs}         ELSE
{.fs}	        WRITE(OUTPUT,' <space>(continue), <esc>(terminate), E(dit');
{.fs#	      WRITE(OUTPUT,' <sp>(continue), <esc>(terminate), E(dit'); }
	    WRITE(OUTPUT,CHR(7));
{.fs}       UNITCLEAR(1); { break queued up key strokes }
	    REPEAT READ(KEYBOARD,CH)
{.fs#	    UNTIL (CH = ' ') OR (CH = 'E') OR (CH = 'e') OR (CH = ALTMODE) }
{.fs}	    UNTIL (CH = ' ') OR ((CH = 'E') OR (CH = 'e') AND CANEDIT) OR (CH = ALTMODE)
	  END;
	IF (CH = 'E') OR (CH = 'e') THEN
	  BEGIN ERRBLK := SYMBLK-2; EXIT(PASCALCOMPILER) END; 
	IF (ERRORNUM > 400) OR (CH = CHR(27)) THEN
	  BEGIN ERRBLK := 0; EXIT(PASCALCOMPILER) END; 
	WRITELN(OUTPUT);
	IF NOISY THEN
	  WRITE(OUTPUT,'<',SCREENDOTS:4,'>')
      END
END (*ERROR*) ;

PROCEDURE GETNEXTPAGE;
BEGIN SYMCURSOR := 0; LINESTART := 0;
  IF USING THEN
    BEGIN
      IF USEFILE = WORKCODE THEN
	BEGIN
	  IF BLOCKREAD(USERINFO.WORKCODE^,SYMBUFP^,2,SYMBLK) <> 2 THEN
	    USING := FALSE
	END
      ELSE
	IF USEFILE = SYSLIBRARY THEN
	  IF BLOCKREAD(LIBRARY,SYMBUFP^,2,SYMBLK) <> 2 THEN
	    USING := FALSE;
      IF NOT USING THEN
	BEGIN
	  SYMBLK := PREVSYMBLK; SYMCURSOR := PREVSYMCURSOR;
	  LINESTART := PREVLINESTART
	END
    END;
  IF NOT USING THEN
    BEGIN
      IF INCLUDING THEN
	IF BLOCKREAD(INCLFILE,SYMBUFP^,2,SYMBLK) <> 2 THEN
	  BEGIN CLOSE(INCLFILE); INCLUDING := FALSE;
{.fs}       INCLNAME := ''; INCLDOTS := INCLDOTS + SCREENDOTS;
	    SYMBLK := OLDSYMBLK; SYMCURSOR := OLDSYMCURSOR;
{.fs}       SCREENDOTS := OLDDOTS;
	    LINESTART := OLDLINESTART
	  END
    END;
  IF NOT (INCLUDING OR USING) THEN
    IF BLOCKREAD(USERINFO.WORKSYM^,SYMBUFP^,2,SYMBLK) <> 2 THEN
      ERROR(401);
  IF SYMCURSOR = 0 THEN
    BEGIN
      IF INMODULE THEN
	IF ININTERFACE AND NOT USING THEN WRITETEXT;
      IF SYMBUFP^[0] = CHR(16(*DLE*)) THEN
       SYMCURSOR := 2
    END;
  SYMBLK := SYMBLK+2
END (*GETNEXTPAGE*) ;

(*$I+*)
PROCEDURE PRINTLINE;
  VAR DORLEV,STARORC: CHAR; LENG: INTEGER;
      A: PACKED ARRAY [0..99] OF CHAR;
BEGIN STARORC := ':';
  IF DP THEN DORLEV := 'D'
  ELSE DORLEV := CHR((BEGSTMTLEV MOD 10) + ORD('0'));
  IF BPTONLINE THEN STARORC := '*';
  WRITE(LP,SCREENDOTS:6,SEG:4,CURPROC:5,
	    STARORC,DORLEV,LINEINFO:6,' ');
  LENG := SYMCURSOR-LINESTART;
  IF LENG > 100 THEN LENG := 100;
  MOVELEFT(SYMBUFP^[LINESTART],A,LENG);
  IF A[0] = CHR(16(*DLE*)) THEN
    BEGIN
      IF A[1] > ' ' THEN
	WRITE(LP,' ':ORD(A[1])-ORD(' '));
      LENG := LENG-2;
      MOVELEFT(A[2],A,LENG)
    END;
  A[LENG-1] := CHR(EOL); (*JUST TO MAKE SURE*)
  WRITE(LP,A:LENG);
  WITH USERINFO DO
    IF (ERRBLK = SYMBLK) AND (ERRSYM > LINESTART) THEN
      WRITELN(LP,'>>>>>> Error # ',ERRNUM)
END (*PRINTLINE*) ;
(*$I-*)

PROCEDURE ENTERID(*FCP: CTP*);
  VAR LCP,LCP1: CTP; I: INTEGER;
BEGIN LCP := DISPLAY[TOP].FNAME;
  IF LCP = NIL THEN DISPLAY[TOP].FNAME := FCP
  ELSE
    BEGIN I := TREESEARCH(LCP,LCP1,FCP^.NAME);
      WHILE I = 0 DO
	BEGIN ERROR(101);
	  IF LCP1^.RLINK = NIL THEN I := 1
	  ELSE I := TREESEARCH(LCP1^.RLINK,LCP1,FCP^.NAME)
	END;
      IF I = 1 THEN LCP1^.RLINK := FCP ELSE LCP1^.LLINK := FCP
    END;
  FCP^.LLINK := NIL; FCP^.RLINK := NIL
END (*ENTERID*) ;

PROCEDURE INSYMBOL; (* COMPILER VERSION 3.4 06-NOV-76 *)
  LABEL 1;
  VAR LVP: CSP; X: INTEGER;

PROCEDURE CHECKEND;
BEGIN (* CHECKS FOR THE END OF THE PAGE *)
  SCREENDOTS := SCREENDOTS+1;
  SYMCURSOR := SYMCURSOR + 1;
  IF NOISY THEN
    BEGIN WRITE(OUTPUT,'.');
      IF (SCREENDOTS-STARTDOTS) MOD 50 = 0 THEN
	BEGIN WRITELN(OUTPUT);
	  WRITE(OUTPUT,'<',SCREENDOTS:4,'>')
	END
    END;
  IF LIST THEN PRINTLINE;
  BPTONLINE := FALSE;
  IF SYMBUFP^[SYMCURSOR]=CHR(0) THEN GETNEXTPAGE
  ELSE LINESTART := SYMCURSOR;
  IF SYMBUFP^[SYMCURSOR] = CHR(12(*FF*)) THEN SYMCURSOR:=SYMCURSOR+1;
  IF SYMBUFP^[SYMCURSOR] = CHR(16(*DLE*)) THEN
    SYMCURSOR := SYMCURSOR+2
  ELSE
    BEGIN
      SYMCURSOR := SYMCURSOR+SCAN(80,<>CHR(9),SYMBUFP^[SYMCURSOR]);
      SYMCURSOR := SYMCURSOR+SCAN(80,<>' ',SYMBUFP^[SYMCURSOR])
    END;
  IF DP THEN LINEINFO := LC ELSE LINEINFO := IC
END;

PROCEDURE COMMENTER(STOPPER: CHAR);
  VAR CH,SW,DEL: CHAR; LTITLE: STRING[40];

  PROCEDURE SCANSTRING(VAR STRG: STRING; MAXLENG: INTEGER);
    VAR LENG: INTEGER;
  BEGIN SYMCURSOR := SYMCURSOR+2;
    LENG := SCAN(MAXLENG,=STOPPER,SYMBUFP^[SYMCURSOR]);
    STRG[0] := CHR(LENG);
    MOVELEFT(SYMBUFP^[SYMCURSOR],STRG[1],LENG);
    SYMCURSOR := SYMCURSOR+LENG+1
  END (*SCANSTRING*) ;

BEGIN
  SYMCURSOR := SYMCURSOR+1; (* POINT TO THE FIRST CH PAST "(*" *)
  IF SYMBUFP^[SYMCURSOR]='$' THEN
     IF SYMBUFP^[SYMCURSOR+1] <> STOPPER THEN
	REPEAT
	  CH := SYMBUFP^[SYMCURSOR+1];
	  SW := SYMBUFP^[SYMCURSOR+2];
	  DEL := SYMBUFP^[SYMCURSOR+3];
	  IF (SW = ',') OR (SW = STOPPER) THEN
	    BEGIN DEL := SW; SW := '+';
	      SYMCURSOR := SYMCURSOR-1
	    END;
	  CASE CH OF
	  'C': BEGIN
		 IF LEVEL > 1 THEN ERROR(194);
		 NEW(COMMENT); SCANSTRING(COMMENT^,80); EXIT(COMMENTER)
	       END;
	  'D': DEBUGGING := (SW='+');
	  'F': FLIPBYTES := (SW='+');
	  'G': GOTOOK := (SW='+');
	  'I': IF (SW='+') OR (SW='-') THEN IOCHECK := (SW='+')
	       ELSE
		 BEGIN SCANSTRING(LTITLE,40);
		   IF STOPPER = '*' THEN
		     SYMCURSOR := SYMCURSOR+1;
		   IF LIST THEN
		     BEGIN
		       SYMCURSOR := SYMCURSOR + 1;
		       PRINTLINE;
		       SYMCURSOR := SYMCURSOR - 1;
		     END;
		   IF INCLUDING OR INMODULE AND ININTERFACE THEN
		     BEGIN ERROR(406); EXIT(COMMENTER) END;
		   OPENOLD(INCLFILE,LTITLE);
		   IF IORESULT <> 0 THEN
		     BEGIN OPENOLD(INCLFILE,CONCAT(LTITLE,'.TEXT'));
			IF IORESULT <> 0 THEN ERROR(403)
		     END;
		   INCLUDING := TRUE;
		   OLDSYMCURSOR := SYMCURSOR;
		   OLDLINESTART := LINESTART;
		   OLDSYMBLK := SYMBLK-2;
{.fs}              OLDDOTS := SCREENDOTS; SCREENDOTS := 1; { keep for error messages }
{.fs}              INCLNAME := LTITLE;
		   SYMBLK := 2; GETNEXTPAGE;
		   INSYMBOL; EXIT(INSYMBOL)
		 END;
	  'L': IF (SW='+') OR (SW='-') THEN
		 BEGIN LIST := (SW='+');
		   IF LIST THEN OPENNEW(LP,'*SYSTEM.LST.TEXT')
		 END
	       ELSE
		 BEGIN SCANSTRING(LTITLE,40);
		   OPENNEW(LP,LTITLE);
		   LIST := IORESULT = 0;
		   EXIT(COMMENTER)
		 END;
	  'Q': NOISY := (SW='-');
{.fs#	  'P': WRITE(LP,CHR(12(*FF*))); } { bug (cf. Apple Pascal 1.2 doc) }
{.fs}	  'P': IF LIST THEN WRITE(LP,CHR(12(*FF*))); { must check LIST }
	  'R': RANGECHECK := (SW='+');
	  'S': NOSWAP:=(SW='-');
	  'T': TINY := (SW='+');
	  'U': IF (SW='+') OR (SW='-') THEN
		 BEGIN SYSCOMP := (SW = '-');
		   RANGECHECK := NOT SYSCOMP;
		   IOCHECK := RANGECHECK;
		   GOTOOK := SYSCOMP
		 END
	       ELSE
		 IF NOT USING THEN
		   BEGIN SCANSTRING(SYSTEMLIB,40);
		     CLOSE(LIBRARY); LIBNOTOPEN := TRUE;
		     EXIT(COMMENTER)
		   END
	  END (*CASES*);
	  SYMCURSOR := SYMCURSOR+3;
	UNTIL DEL <> ',';
  SYMCURSOR := SYMCURSOR-1; (* ADJUST *)
  REPEAT
    REPEAT
      SYMCURSOR := SYMCURSOR+1;
      WHILE SYMBUFP^[SYMCURSOR] = CHR(EOL) DO CHECKEND
    UNTIL SYMBUFP^[SYMCURSOR]=STOPPER;
  UNTIL (SYMBUFP^[SYMCURSOR+1]=')') OR (STOPPER='}');
  SYMCURSOR := SYMCURSOR+1;
END (*COMMENTER*);

PROCEDURE STRING;
LABEL 1;
VAR
{.fs# T: PACKED ARRAY [1..80] OF CHAR; }
{.fs} T: PACKED ARRAY [1..STRGLGTH] OF CHAR; { (cf. Apple Pascal 1.2 doc) }
  TP,NBLANKS,L: INTEGER;
  DUPLE: BOOLEAN;

BEGIN
  DUPLE := FALSE; (* INDICATES WHEN '' IS PRESENT *)
  TP := 0; (* INDEX INTO TEMPORARY STRING *)
  REPEAT
    IF DUPLE THEN SYMCURSOR := SYMCURSOR+1;
    REPEAT
      SYMCURSOR := SYMCURSOR+1;
      TP := TP+1;
      IF SYMBUFP^[SYMCURSOR] = CHR(EOL) THEN
	BEGIN ERROR(202); CHECKEND; GOTO 1 END;
{.fs} IF TP<=STRGLGTH THEN { check for buffer overflow (cf. Apple Pascal 1.2 doc) }
      T[TP] := SYMBUFP^[SYMCURSOR];
    UNTIL SYMBUFP^[SYMCURSOR]='''';
    DUPLE := TRUE;
  UNTIL SYMBUFP^[SYMCURSOR+1]<>'''';
1:  TP := TP-1; (* ADJUST *)
{.fs} IF TP>STRGLGTH THEN BEGIN ERROR(202); TP:=255 END; { rather long src line! }
  SY := STRINGCONST; OP := NOOP;
  LGTH := TP; (* GROSS *)
  IF TP=1 (* SINGLE CHARACTER CONSTANT *)
    THEN
      VAL.IVAL := ORD(T[1])
    ELSE
      WITH SCONST^ DO
	BEGIN
	  CCLASS := STRG;
	  SLGTH := TP;
	  MOVELEFT(T[1],SVAL[1],TP);
	  VAL.VALP := SCONST
	END
END(*STRING*);

PROCEDURE NUMBER;
VAR
  EXPONENT,ENDI,ENDF,ENDE,SIGN,IPART,FPART,EPART,
  ISUM:  INTEGER;
  TIPE: (REALTIPE,INTEGERTIPE);
  RSUM: REAL;
  NOTLONG: BOOLEAN;
  K,J: INTEGER;
BEGIN
  (* TAKES A NUMBER AND DECIDES WHETHER IT'S REAL
     OR INTEGER AND CONVERTS IT TO THE INTERNAL
     FORM. *)
  TIPE := INTEGERTIPE;
  ENDI := 0;
  ENDF := 0;
  ENDE := 0;
  SIGN := 1;
  NOTLONG := TRUE;
  EPART := 9999; (* OUT OF REACH *)
  IPART := SYMCURSOR; (* INTEGER PART STARTS HERE *)
  REPEAT
    SYMCURSOR := SYMCURSOR+1
  UNTIL (SYMBUFP^[SYMCURSOR]<'0') OR (SYMBUFP^[SYMCURSOR]>'9');
  (* SYMCURSOR NOW POINTS AT FIRST CHARACTER PAST INTEGER PART *)
  ENDI := SYMCURSOR-1; (* MARK THE END OF IPART *)
  IF SYMBUFP^[SYMCURSOR]='.'
    THEN
      IF SYMBUFP^[SYMCURSOR+1]<>'.'  (* WATCH OUT FOR '..' *)
	THEN
	  BEGIN
	    TIPE := REALTIPE;
	    SYMCURSOR := SYMCURSOR+1;
	    FPART := SYMCURSOR; (* BEGINNING OF FPART *)
	    WHILE (SYMBUFP^[SYMCURSOR] >= '0') AND
		  (SYMBUFP^[SYMCURSOR] <= '9') DO
	      SYMCURSOR := SYMCURSOR+1;
	    IF SYMCURSOR = FPART THEN ERROR(201);
	    ENDF := SYMCURSOR-1;
	  END;
  IF SYMBUFP^[SYMCURSOR]='E'
    THEN
      BEGIN
	TIPE := REALTIPE;
	SYMCURSOR := SYMCURSOR+1;
	IF SYMBUFP^[SYMCURSOR]='-'
	  THEN
	    BEGIN
	      SYMCURSOR := SYMCURSOR+1;
	      SIGN := -1;
	    END
	  ELSE
	    IF SYMBUFP^[SYMCURSOR]='+'
	      THEN
		SYMCURSOR := SYMCURSOR+1;
	EPART := SYMCURSOR; (* BEGINNING OF EXPONENT *)
	WHILE (SYMBUFP^[SYMCURSOR]>='0') AND (SYMBUFP^[SYMCURSOR]<='9') DO
	  SYMCURSOR := SYMCURSOR+1;
  	ENDE := SYMCURSOR-1;
	IF ENDE<EPART THEN ERROR(201); (* ERROR IN REAL CONSTANT *)
      END;
  (* NOW CONVERT TO INTERNAL FORM *)
  IF TIPE=INTEGERTIPE THEN
    BEGIN
      ISUM := 0;
      FOR J := IPART TO ENDI DO
	BEGIN
	  IF (ISUM>MAXINT DIV 10) OR ((ISUM=MAXINT DIV 10) AND 
		      (ORD(SYMBUFP^[J]) - ORD('0') > MAXINT MOD 10)) THEN
	      BEGIN NOTLONG := FALSE; K := J; J := ENDI END
	  ELSE ISUM := ISUM*10+(ORD(SYMBUFP^[J])-ORD('0'));
	END;
	IF NOTLONG THEN
	  BEGIN
	    SY := INTCONST;  OP := NOOP;
	    VAL.IVAL := ISUM;
	  END
	ELSE
	  BEGIN 
	    IF ENDI - IPART >= MAXDEC THEN
	      BEGIN ERROR(203); IPART := ENDI; K := ENDI END;
	    NEW(LVP,LONG);
	    WITH LVP^ DO
	      BEGIN CCLASS := LONG; J := 4; LLENG := 0;
		WHILE K <= ENDI DO
		  BEGIN
		    IF J = 4 THEN
		      BEGIN LLENG := LLENG + 1;
			LONGVAL[LLENG] := ISUM;
			ISUM := 0;
			J := 0
		      END;
		    ISUM := ISUM * 10 + ORD(SYMBUFP^[K])-ORD('0');
	            K := K + 1; J := J + 1
		  END;
	        LLAST := J;
		IF J > 0 THEN
		  BEGIN LLENG := LLENG + 1;
		    LONGVAL[LLENG] := ISUM
		  END;
	      END;
	    SY := LONGCONST; OP := NOOP;
	    LGTH := ENDI - IPART + 1;
	    VAL.VALP := LVP
	  END;
    END (*TIPE = INTEGERTIPE*)
  ELSE
    BEGIN (* REAL NUMBER HERE *)
      RSUM := 0;
      FOR J := IPART TO ENDI DO
	BEGIN
	  RSUM := RSUM*10+(ORD(SYMBUFP^[J])-ORD('0'));
	END;
      FOR J := ENDF DOWNTO FPART DO
	RSUM := RSUM+(ORD(SYMBUFP^[J])-ORD('0'))/PWROFTEN(J-FPART+1);
      EXPONENT := 0;
      FOR J := EPART TO ENDE DO
	EXPONENT := EXPONENT*10+ORD(SYMBUFP^[J])-ORD('0');
      IF SIGN=-1 THEN
	RSUM := RSUM/PWROFTEN(EXPONENT)
      ELSE
	RSUM := RSUM*PWROFTEN(EXPONENT);
      SY := REALCONST;  OP := NOOP;
      NEW(LVP,REEL);
      LVP^.CCLASS := REEL;
      LVP^.RVAL := RSUM;
      VAL.VALP := LVP;
    END;
  SYMCURSOR := SYMCURSOR-1; (* ADJUST FOR POSTERITY *)
END (*NUMBER*) ;

BEGIN (* INSYMBOL *)
  IF GETSTMTLEV THEN BEGIN BEGSTMTLEV := STMTLEV; GETSTMTLEV := FALSE END;
  OP := NOOP;
1:  SY := OTHERSY; (* IF NO CASES EXERCISED BLOW UP *)
  CASE SYMBUFP^[SYMCURSOR] OF
  '''':STRING;
  '0','1','2','3','4','5','6','7','8','9':
       NUMBER;
  'A','B','C','D','E','F','G','H','I','J','K','L','M',
  'N','O','P','Q','R','S','T','U','V','W','X','Y','Z',
  'a','b','c','d','e','f','g','h','i','j','k','l','m',
  'n','o','p','q','r','s','t','u','v','w','x','y','z':
       IDSEARCH(SYMCURSOR,SYMBUFP^); (* MAGIC PROC *)
  '{': BEGIN COMMENTER('}'); GOTO 1 END;
  '(': BEGIN
	 IF SYMBUFP^[SYMCURSOR+1]='*' THEN
	     BEGIN
		SYMCURSOR := SYMCURSOR+1;
		COMMENTER('*');
		SYMCURSOR := SYMCURSOR+1;
		GOTO 1; (* GET ANOTHER TOKEN *)
	     END
	   ELSE
	     SY := LPARENT;
       END;
  ')': SY := RPARENT;
  ',': SY := COMMA;
  ' ','	': BEGIN SYMCURSOR := SYMCURSOR+1; GOTO 1; END;
  '.': BEGIN
	 IF SYMBUFP^[SYMCURSOR+1]='.'
	   THEN
	     BEGIN
	       SYMCURSOR := SYMCURSOR+1;
	       SY := COLON
	     END
	   ELSE
	     SY := PERIOD;
       END;
  ':': IF SYMBUFP^[SYMCURSOR+1]='='
	 THEN
	   BEGIN
	     SYMCURSOR := SYMCURSOR+1;
	     SY := BECOMES;
	  END
	ELSE
	   SY := COLON;
  ';': SY := SEMICOLON;
  '^': SY := ARROW;
  '[': SY := LBRACK;
  ']': SY := RBRACK;
  '*': BEGIN SY := MULOP; OP := MUL END;
  '+': BEGIN SY := ADDOP; OP := PLUS END;
  '-': BEGIN SY := ADDOP; OP := MINUS END;
  '/': BEGIN SY := MULOP; OP := RDIV END;
  '<': BEGIN
	 SY := RELOP;
	 OP := LTOP;
	 CASE SYMBUFP^[SYMCURSOR+1] OF
	   '>': BEGIN
		  OP := NEOP;
		  SYMCURSOR := SYMCURSOR+1
		END;
	   '=': BEGIN
		  OP := LEOP;
		  SYMCURSOR := SYMCURSOR+1
		END
	 END;
       END;
  '=': BEGIN SY := RELOP; OP := EQOP END;
  '>': BEGIN
	 SY := RELOP;
	 IF SYMBUFP^[SYMCURSOR+1]='='
	   THEN
	     BEGIN
	       OP := GEOP;
	       SYMCURSOR := SYMCURSOR+1;
	     END
	   ELSE
	     OP := GTOP;
       END
END (* CASE SYMBUFP^[SYMCURSOR] OF *);
  IF SY=OTHERSY THEN
    IF SYMBUFP^[SYMCURSOR] = CHR(EOL) THEN
      BEGIN CHECKEND; GETSTMTLEV := TRUE; GOTO 1 END
    ELSE ERROR(400);
  SYMCURSOR := SYMCURSOR+1; (* NEXT CALL TALKS ABOUT NEXT TOKEN *)
END (*INSYMBOL*) ;

{.fs} (* --- original source filename: PROCS.B.TEXT --- *)

  (*      COPYRIGHT  (C) 1979, REGENTS OF THE      *)
  (*      UNIVERSITY OF CALIFORNIA, SAN DIEGO      *)

  PROCEDURE SEARCHSECTION(*FCP: CTP; VAR FCP1: CTP*);
  BEGIN
    IF FCP <> NIL THEN
      IF TREESEARCH(FCP,FCP1,ID) = 0 THEN (*NADA*)
      ELSE FCP1 := NIL
    ELSE FCP1 := NIL
  END (*SEARCHSECTION*) ;

  PROCEDURE SEARCHID(*FIDCLS: SETOFIDS; VAR FCP: CTP*);
    LABEL 1; VAR LCP: CTP;
  BEGIN
    FOR DISX := TOP DOWNTO 0 DO
      BEGIN LCP := DISPLAY[DISX].FNAME;
	IF LCP <> NIL THEN
	  IF TREESEARCH(LCP,LCP,ID) = 0 THEN
	    IF LCP^.KLASS IN FIDCLS THEN GOTO 1
	    ELSE
	      IF PRTERR THEN ERROR(103)
	      ELSE LCP := NIL
	  ELSE LCP := NIL
      END;
    IF PRTERR THEN
      BEGIN ERROR(104);
	IF TYPES IN FIDCLS THEN LCP := UTYPPTR
	ELSE
	  IF ACTUALVARS IN FIDCLS THEN LCP := UVARPTR
	  ELSE
	    IF FIELD IN FIDCLS THEN LCP := UFLDPTR
	    ELSE
	      IF KONST IN FIDCLS THEN LCP := UCSTPTR
	      ELSE
		IF PROC IN FIDCLS THEN LCP := UPRCPTR
		ELSE LCP := UFCTPTR
      END;
1:  FCP := LCP
  END (*SEARCHID*) ;

  PROCEDURE GETBOUNDS(*FSP: STP; VAR FMIN,FMAX: INTEGER*);
  BEGIN
    WITH FSP^ DO
      IF FORM = SUBRANGE THEN
	BEGIN FMIN := MIN.IVAL; FMAX := MAX.IVAL END
      ELSE
	BEGIN FMIN := 0;
	  IF FSP = CHARPTR THEN FMAX := 255
	  ELSE
	    IF FSP^.FCONST <> NIL THEN
	      FMAX := FSP^.FCONST^.VALUES.IVAL
	    ELSE FMAX := 0
	END
  END (*GETBOUNDS*) ;

  PROCEDURE SKIP(*FSYS: SETOFSYS*);
  BEGIN WHILE NOT(SY IN FSYS) DO INSYMBOL
  END (*SKIP*) ;

  FUNCTION PAOFCHAR(*FSP: STP): BOOLEAN*);
  BEGIN PAOFCHAR := FALSE;
    IF FSP <> NIL THEN
      IF FSP^.FORM = ARRAYS THEN
	PAOFCHAR := FSP^.AISPACKD AND (FSP^.AELTYPE = CHARPTR)
  END (*PAOFCHAR*) ;

  FUNCTION STRGTYPE(*FSP: STP) : BOOLEAN*);
  BEGIN STRGTYPE := FALSE;
    IF PAOFCHAR(FSP) THEN STRGTYPE := FSP^.AISSTRNG
  END (*STRGTYPE*) ;

  FUNCTION DECSIZE(*I: INTEGER): INTEGER*);
  BEGIN DECSIZE := (I + 3) DIV 4 + 1 (*GROSS..MAXIMUM NEEDED SPACE*)
  (* BINARY FN. SHOULD BE ((I*332) DIV 100 + 1 + BITSPERWD) DIV BITSPERWD *)
  END (*DECSIZE*) ;

  PROCEDURE CONSTANT(*FSYS: SETOFSYS; VAR FSP: STP; VAR FVALU: VALU*);
    VAR LSP: STP; LCP: CTP; SIGN: (NONE,POS,NEG);
	LVP: CSP;
  BEGIN LSP := NIL; FVALU.IVAL := 0;
    IF NOT(SY IN CONSTBEGSYS) THEN
      BEGIN ERROR(50); SKIP(FSYS+CONSTBEGSYS) END;
    IF SY IN CONSTBEGSYS THEN
      BEGIN
	IF SY = STRINGCONSTSY THEN
	  BEGIN
	    IF LGTH = 1 THEN LSP := CHARPTR
	    ELSE
	      BEGIN
		NEW(LSP,ARRAYS,TRUE,TRUE);
		LSP^ := STRGPTR^;
		LSP^.MAXLENG := LGTH;
		LSP^.INXTYPE := NIL;
		NEW(LVP);
		LVP^ := VAL.VALP^;
		VAL.VALP := LVP
	      END;
	    FVALU := VAL; INSYMBOL
	  END
	ELSE
	  BEGIN
	    SIGN := NONE;
	    IF (SY = ADDOP) AND (OP IN [PLUS,MINUS]) THEN
	      BEGIN IF OP = PLUS THEN SIGN := POS ELSE SIGN := NEG;
		INSYMBOL
	      END;
	    IF SY = IDENT THEN
	      BEGIN SEARCHID([KONST],LCP);
		WITH LCP^ DO
		  BEGIN LSP := IDTYPE; FVALU := VALUES END;
		IF SIGN <> NONE THEN
		  IF LSP = INTPTR THEN
		    BEGIN IF SIGN = NEG THEN
		      FVALU.IVAL := -FVALU.IVAL END
		  ELSE
		    IF LSP = REALPTR THEN
		      BEGIN
			IF SIGN = NEG THEN
			  BEGIN NEW(LVP,REEL);
			    LVP^.CCLASS := REEL;
			    LVP^.RVAL := -FVALU.VALP^.RVAL;
			    FVALU.VALP := LVP;
			  END
		      END
		    ELSE
		      IF COMPTYPES(LSP,LONGINTPTR) THEN
			BEGIN
			  IF SIGN = NEG THEN
			    BEGIN NEW(LVP,LONG);
			      LVP^.CCLASS := LONG;
			      LVP^.LONGVAL[1] := - FVALU.VALP^.LONGVAL[1];
			      FVALU.VALP := LVP
			    END
			END
		      ELSE ERROR(105);
		INSYMBOL;
	      END
	    ELSE
	      IF SY = INTCONST THEN
		BEGIN IF SIGN = NEG THEN VAL.IVAL := -VAL.IVAL;
		  LSP := INTPTR; FVALU := VAL; INSYMBOL
		END
	      ELSE
		IF SY = REALCONST THEN
		  BEGIN IF SIGN = NEG THEN
			  VAL.VALP^.RVAL := -VAL.VALP^.RVAL;
		    LSP := REALPTR; FVALU := VAL; INSYMBOL
		  END
		ELSE
		  IF SY = LONGCONST THEN
		    BEGIN
		      IF SIGN = NEG THEN
			BEGIN VAL.VALP^.LONGVAL[1] := - VAL.VALP^.LONGVAL[1];
			  NEW(LSP,LONGINT);
			  LSP^.SIZE := DECSIZE(LGTH);
			  LSP^.FORM := LONGINT;
			  FVALU := VAL;
			  INSYMBOL
			END
		    END
		  ELSE
		    BEGIN ERROR(106); SKIP(FSYS) END
	  END;
	IF NOT (SY IN FSYS) THEN
	  BEGIN ERROR(6); SKIP(FSYS) END
	END;
    FSP := LSP
  END (*CONSTANT*) ;

  FUNCTION COMPTYPES(*FSP1,FSP2: STP) : BOOLEAN*);
    VAR NXT1,NXT2: CTP; COMP: BOOLEAN;
      LTESTP1,LTESTP2 : TESTP;
  BEGIN
    IF FSP1 = FSP2 THEN COMPTYPES := TRUE
    ELSE
      IF (FSP1 = NIL) OR (FSP2 = NIL) THEN COMPTYPES := TRUE
      ELSE
	IF FSP1^.FORM = FSP2^.FORM THEN
	  CASE FSP1^.FORM OF
	    SCALAR:
	      COMPTYPES := FALSE;
	    SUBRANGE:
	      COMPTYPES := COMPTYPES(FSP1^.RANGETYPE,
				       FSP2^.RANGETYPE);
	    POINTER:
		BEGIN
		  COMP := FALSE; LTESTP1 := GLOBTESTP;
		  LTESTP2 := GLOBTESTP;
		  WHILE LTESTP1 <> NIL DO
		    WITH LTESTP1^ DO
		      BEGIN
			IF (ELT1 = FSP1^.ELTYPE) AND
			  (ELT2 = FSP2^.ELTYPE) THEN COMP := TRUE;
			LTESTP1 := LASTTESTP
		      END;
		  IF NOT COMP THEN
		    BEGIN NEW(LTESTP1);
		      WITH LTESTP1^ DO
			BEGIN ELT1 := FSP1^.ELTYPE;
			  ELT2 := FSP2^.ELTYPE;
			  LASTTESTP := GLOBTESTP
			END;
		      GLOBTESTP := LTESTP1;
		      COMP := COMPTYPES(FSP1^.ELTYPE,FSP2^.ELTYPE)
		    END;
		  COMPTYPES := COMP; GLOBTESTP := LTESTP2
		END;
	    LONGINT: COMPTYPES := TRUE;
	    POWER:
	      COMPTYPES := COMPTYPES(FSP1^.ELSET,FSP2^.ELSET);
	    ARRAYS:
	      BEGIN
		COMP := COMPTYPES(FSP1^.AELTYPE,FSP2^.AELTYPE)
			AND (FSP1^.AISPACKD = FSP2^.AISPACKD);
		IF COMP AND FSP1^.AISPACKD THEN
		    COMP := (FSP1^.ELSPERWD = FSP2^.ELSPERWD)
			    AND (FSP1^.ELWIDTH = FSP2^.ELWIDTH)
			    AND (FSP1^.AISSTRNG = FSP2^.AISSTRNG);
		IF COMP AND NOT STRGTYPE(FSP1) THEN
		  COMP := (FSP1^.SIZE = FSP2^.SIZE);
		COMPTYPES := COMP;
	      END;
	    RECORDS:
	      BEGIN NXT1 := FSP1^.FSTFLD; NXT2 := FSP2^.FSTFLD;
		COMP := TRUE;
		WHILE (NXT1 <> NIL) AND (NXT2 <> NIL) AND COMP DO
		  BEGIN COMP:=COMPTYPES(NXT1^.IDTYPE,NXT2^.IDTYPE);
		    NXT1 := NXT1^.NEXT; NXT2 := NXT2^.NEXT
		  END;
		COMPTYPES := COMP AND (NXT1 = NIL) AND (NXT2 = NIL)
			    AND (FSP1^.RECVAR = NIL)
			    AND (FSP2^.RECVAR = NIL)
	      END;
	    FILES:
	      COMPTYPES := COMPTYPES(FSP1^.FILTYPE,FSP2^.FILTYPE)
	  END (*CASE*)
	ELSE (*FSP1^.FORM <> FSP2^.FORM*)
	  IF FSP1^.FORM = SUBRANGE THEN
	    COMPTYPES := COMPTYPES(FSP1^.RANGETYPE,FSP2)
	  ELSE
	    IF FSP2^.FORM = SUBRANGE THEN
	      COMPTYPES := COMPTYPES(FSP1,FSP2^.RANGETYPE)
	    ELSE COMPTYPES := FALSE
  END (*COMPTYPES*) ;
  

  PROCEDURE GENBYTE(*FBYTE: INTEGER*);
  BEGIN
    CODEP^[IC] := CHR(FBYTE); IC := IC+1
  END (*GENBYTE*) ;

  PROCEDURE GENWORD(*FWORD: INTEGER*);
   VAR TEMP: CHAR;
  BEGIN
    IF ODD(IC) THEN IC := IC + 1;
    MOVELEFT(FWORD,CODEP^[IC],2);
    IF FLIPBYTES THEN
      BEGIN
	TEMP := CODEP^[IC];
	CODEP^[IC] := CODEP^[IC+1];
	CODEP^[IC+1] := TEMP
      END;
    IC := IC + 2
  END (*GENWORD*) ;

PROCEDURE WRITETEXT;
  BEGIN
    MOVELEFT(SYMBUFP^[SYMCURSOR],CODEP^[0],1024);
    IF USERINFO.ERRNUM = 0 THEN
      IF BLOCKWRITE(USERINFO.WORKCODE^,CODEP^[0],2,CURBLK) <> 2 THEN
	ERROR(402);
    CURBLK := CURBLK + 2
  END (*WRITETEXT*) ;

  PROCEDURE WRITECODE(*FORCEBUF: BOOLEAN*);
    VAR CODEINX,LIC,I: INTEGER;
  BEGIN CODEINX := 0; LIC := IC;
    REPEAT
      I := 512-CURBYTE;
      IF I > LIC THEN I := LIC;
      MOVELEFT(CODEP^[CODEINX],DISKBUF[CURBYTE],I);
      CODEINX := CODEINX+I;
      CURBYTE := CURBYTE+I;
      IF (CURBYTE = 512) OR FORCEBUF THEN
	BEGIN
	  IF USERINFO.ERRNUM = 0 THEN
	    IF BLOCKWRITE(USERINFO.WORKCODE^,DISKBUF,1,CURBLK) <> 1 THEN
	      ERROR(402);
	  CURBLK := CURBLK+1; CURBYTE := 0
	END;
      LIC := LIC-I
    UNTIL LIC = 0;
  END (*WRITECODE*) ;

  PROCEDURE FINISHSEG;
    VAR I: INTEGER;
  BEGIN IC := 0;
    FOR I := NEXTPROC-1 DOWNTO 1 DO 
      IF PROCTABLE[I] = 0 THEN 
	GENWORD(0)
      ELSE 
        GENWORD(SEGINX+IC-PROCTABLE[I]);
    GENBYTE(SEG); GENBYTE(NEXTPROC-1);
    SEGTABLE[SEG].CODELENG := SEGINX+IC;
    WRITECODE(TRUE); SEGINX := 0; CODEINSEG := FALSE
  END (*FINISHSEG*) ;

{.fs} (* --- original source filename: BLOCK.TEXT --- *)

PROCEDURE BLOCK(*FSYS: SETOFSYS*);
LABEL 1;
VAR BFSYFOUND: BOOLEAN;

  PROCEDURE FINDFORW(FCP: CTP);
    BEGIN
      IF FCP <> NIL THEN
	WITH FCP^ DO
	  BEGIN
	    IF KLASS IN [PROC,FUNC] THEN
	      IF PFDECKIND = DECLARED THEN
		IF PFKIND = ACTUAL THEN
		  IF FORWDECL THEN
		    BEGIN
		      USERINFO.ERRNUM := 117; WRITELN(OUTPUT);
		      WRITE(OUTPUT,NAME,' undefined')
		    END;
	    FINDFORW(RLINK); FINDFORW(LLINK)
	  END
    END (*FINDFORW*) ;

  BEGIN (*BLOCK*)
     IF (NOSWAP) AND (STARTINGUP) THEN
       BEGIN
	 BODYPART(FSYS,NIL);
	 EXIT(BLOCK);
       END;
     IF (SY IN [UNITSY,SEPARATSY]) AND (NOT INMODULE) THEN
       BEGIN
	 UNITPART(FSYS + [UNITSY,INTERSY,IMPLESY,ENDSY]);
	 IF SY = PERIOD THEN EXIT(BLOCK)
       END;
     NEWBLOCK:=TRUE;
     REPEAT
       IF NOT NEWBLOCK THEN
	 BEGIN
	   DP := FALSE; STMTLEV := 0; IC := 0; LINEINFO := 0;
	   IF (NOT SYSCOMP) OR (LEVEL>1) THEN FINDFORW(DISPLAY[TOP].FNAME);
	   IF INMODULE THEN
	     IF TOS^.PREVLEXSTACKP^.DFPROCP = OUTERBLOCK THEN
	       IF (SY = ENDSY) THEN
		 BEGIN FINISHSEG; EXIT(BLOCK) END
	       ELSE IF (SY = BEGINSY) THEN
		 BEGIN ERROR(13); FINISHSEG; EXIT(BLOCK) END;
	   IF SY = BEGINSY THEN INSYMBOL ELSE ERROR(17);
	   REPEAT 
	     BODYPART(FSYS + [CASESY] - [ENDSY], TOS^.DFPROCP);
	     BFSYFOUND := (SY = TOS^.BFSY) OR (INMODULE AND (SY = ENDSY));
	     IF NOT BFSYFOUND THEN
	       BEGIN 
		 IF TOS^.BFSY = SEMICOLON THEN
		   ERROR(14)  (*SEMICOLON EXPECTED*)
		 ELSE  ERROR(6);  (* PERIOD EXPECTED *)
		 SKIP(FSYS + [TOS^.BFSY]);
		 BFSYFOUND := (SY = TOS^.BFSY) OR (INMODULE AND (SY = ENDSY))
	     END
	   UNTIL (BFSYFOUND) OR (SY IN BLOCKBEGSYS);
	   IF NOT BFSYFOUND THEN
	     BEGIN
	       IF TOS^.BFSY = SEMICOLON THEN ERROR(14)
	       ELSE ERROR(6); (*PERIOD EXPECTED*)
	       DECLARATIONPART(FSYS);
	     END
	   ELSE
	     BEGIN
	       IF SY = SEMICOLON THEN INSYMBOL;
	       IF (NOT(SY IN [BEGINSY,PROCSY,FUNCSY,PROGSY])) AND
		  (TOS^.BFSY = SEMICOLON) THEN
		 IF NOT (INMODULE AND (SY = ENDSY)) THEN
		   BEGIN
		     ERROR(6); SKIP(FSYS);
		     DECLARATIONPART(FSYS);
		   END
		 ELSE GOTO 1
	       ELSE
	 1:      BEGIN
		   WITH TOS^ DO
		     BEGIN
		       IF DFPROCP <> NIL THEN
			 DFPROCP^.INSCOPE:=FALSE;
		       IF ISSEGMENT THEN
			 BEGIN
			   IF CODEINSEG THEN FINISHSEG;
			   IF DLINKERINFO AND (LEVEL = 1) THEN
			     BEGIN SEGTABLE[SEG].SEGKIND := 2;
			       WRITELINKERINFO(TRUE)
			     END
			   ELSE
			     IF CLINKERINFO THEN
			       BEGIN SEGTABLE[SEG].SEGKIND := 2;
				 WRITELINKERINFO(FALSE)
			       END;
			   NEXTPROC:=SOLDPROC;
			   SEG:=DOLDSEG;
			 END;
		       LEVEL:=DOLDLEV;
		       TOP:=DOLDTOP;
		       LC:=DLLC;
		       CURPROC:=POLDPROC;
		     END;
		   RELEASE(TOS^.DMARKP);
		   TOS:=TOS^.PREVLEXSTACKP;
		   NEWBLOCK:=(SY IN [PROCSY,FUNCSY,PROGSY]);
		 END
	     END
	 END
       ELSE   
	 BEGIN DECLARATIONPART(FSYS);
	   IF LEVEL = 0 THEN
	     IF SY IN [UNITSY,SEPARATSY] THEN
	       BEGIN
		 UNITPART(FSYS + [UNITSY,INTERSY,IMPLESY,ENDSY]);
		 IF SY IN [PROCSY,FUNCSY,PROGSY] THEN DECLARATIONPART(FSYS)
	       END
         END;
     UNTIL TOS = NIL;
     FINISHSEG;
 END (*BLOCK*) ;

BEGIN (* PASCALCOMPILER *)
  COMPINIT;
  TIME(LGTH,LOWTIME); 
  BLOCK(BLOCKBEGSYS+STATBEGSYS-[CASESY]);
  IF SY <> PERIOD THEN ERROR(21);
  IF LIST THEN
    BEGIN SCREENDOTS := SCREENDOTS+1;
      SYMBUFP^[SYMCURSOR] := CHR(EOL);
      SYMCURSOR := SYMCURSOR+1;
      PRINTLINE
    END;
  USERINFO.ERRBLK := 0;
  TIME(LGTH,STARTDOTS); LOWTIME := STARTDOTS-LOWTIME;
  UNITWRITE(3,IC,7);
  IF DLINKERINFO OR CLINKERINFO THEN
    BEGIN SEGTABLE[SEG].SEGKIND := 1;
      WRITELINKERINFO(TRUE)
    END;
  CLOSE(LP,LOCK);
  IF NOISY THEN WRITELN(OUTPUT);
{.fs} SCREENDOTS := SCREENDOTS + INCLDOTS;  { account for includes in stats }
  WRITE(OUTPUT,SCREENDOTS,' lines');
  IF LOWTIME > 0 THEN
    WRITE(OUTPUT,', ',(LOWTIME+30) DIV 60,' secs, ',
	ROUND((3600/LOWTIME)*SCREENDOTS),' lines/min');
  IF NOISY THEN
    BEGIN
      WRITELN(OUTPUT);
      WRITE(OUTPUT,'Smallest available space = ',SMALLESTSPACE,' words');
    END;
  IC := 0;
  FOR SEG := 0 TO MAXSEG DO
    WITH SEGTABLE[SEG] DO
      BEGIN GENWORD(DISKADDR); GENWORD(CODELENG) END;
  FOR SEG := 0 TO MAXSEG DO
    WITH SEGTABLE[SEG] DO
      FOR LGTH := 1 TO 8 DO
	GENBYTE(ORD(SEGNAME[LGTH]));
  FOR SEG := 0 TO MAXSEG DO GENWORD(SEGTABLE[SEG].SEGKIND);
  FOR SEG := 0 TO MAXSEG DO GENWORD(SEGTABLE[SEG].TEXTADDR);
{.fs} { adapted to Apple format, comment comes later than in original UCSD format }
{.fs} FOR SEG := 0 TO MAXSEG DO GENWORD(0);                             { SEGINFO }
  FOR LGTH := 1 TO 72 DO GENWORD(0);             { Apple: intrin flags, checksums }
{.fs} IF NOISY AND (COMMENT <> NIL) THEN BEGIN
{.fs}   WRITELN; WRITE('Comment = ',COMMENT^)                { dump it for info, e.g. version# }
{.fs} END;
  FOR LGTH := 1 TO 80 DO
{.fs# IF COMMENT <> NIL THEN GENBYTE(ORD(COMMENT^[LGTH])) ELSE GENBYTE(0); }
{.fs}   GENBYTE(0); { short-term remedy: comment strings currently broken }
{.fs# FOR LGTH := 1 TO 256 - 8*(MAXSEG + 1) - 40 DO GENWORD(0); }

  CURBLK := 0; CURBYTE := 0; WRITECODE(TRUE)
END (* PASCALCOMPILER *) ;
