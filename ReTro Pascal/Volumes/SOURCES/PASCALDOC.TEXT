
List of all PASCAL functions and keywords
=========================================

...add references: Titles of Apple Pascal books and TechNotes

Pascal Keywords and Operators Overview
--------------------------------------

  * Program structure:
        PROGRAM, PROCEDURE, FUNCTION, SEGMENT, FORWARD
        CONST, TYPE, VAR, LABEL
        BEGIN, END
  * Operators:
        +, -, *, /, DIV, MOD, NOT, AND, OR, IN, =, <>, <, >, <=, >=
  * Flow control:
        IF, THEN, ELSE, FOR, TO, DOWNTO, WHILE, DO, REPEAT, UNTIL, EXIT, CASE, OF, GOTO, LABEL
  * Type declarations:
        TYPE, RECORD, CASE, END, ARRAY, SET, FILE, OF, PACKED
  * Units:
        USES, UNIT, INTERFACE, IMPLEMENTATION, SEPARATE, EXTERNAL

Predefined Functions and Symbols Overview
-----------------------------------------

  * Input/output
        WRITE, WRITELN, READ, READLN, GET, PUT, SEEK, EOLN, EOF
        RESET, REWRITE, CLOSE, IORESULT
        PAGE, GOTOXY
        KEYBOARD, INPUT, OUTPUT
  * Numbers and math:
        ABS, SQRT, SQR, TRUNC, ROUND
        SIN, COS, LOG, ATAN, LN, EXP
        SUCC, PRED, ORD
  * Strings and characters:
        LENGTH, INSERT, DELETE, CONCAT, COPY, POS, STR
        CHR, ORD
  * Dynamic memory:
        NEW, MARK, RELEASE
  * Constants:
        TRUE, FALSE, NIL, MAXINT
  * Types:
        INTEGER, REAL, STRING, CHAR, BOOLEAN, TEXT
  * Dynamic data structure support:
        MOVELEFT, MOVERIGHT, SCAN, FILLCHAR, SIZEOF
        TREESEARCH
        NEWARRAY
  * Graphics (TURTLEGRAPHICS unit):
        INITTURTLE, TURN, MOVE, MOVETO, TURNTO, TURTLEX, TURTLEY, TURTLEANG
        PENCOLOR, RGBCOLOR, SCREENCOLOR
        NONE, WHITE, BLACK, REVERSE, GREEN, VIOLET, ORANGE, BLUE
        TEXTMODE, GRAFMODE, VIEWPORT
        FILLSCREEN, DRAWBLOCK, WHAR, WSTRING, CHARTYPE, SCALEMODE
        HOLDFRAME, SYNCFRAME
  * System support (incl. RETROSTUFF and APPLESTUFF units):
        PADDLE, BUTTON, KEYPRESS
        RANDOM, RANDOMIZE
        NOTE
        APPENDEXTENSION, READLNPATHNAME
        GETTERMSIZE, RAMAVAIL
        TIME, YIELDCPU
        BLOCKREAD, BLOCKWRITE, UNITREAD, UNITWRITE, OPENNEW, OPENOLD
        IDSEARCH

Alphabetic
----------

...TODO: complete this, and annotate 

 FUNCTION ABS(V: INTEGER):   INTEGER;
 FUNCTION ABS(V: REAL):      REAL;
 FUNCTION ABS(V: INTEGER[]): INTEGER[];  ...exists?
          AND { e.g. IF (CH>='0') AND (CH<='9') THEN ... }
PROCEDURE APPENDEXTENSION(VAR FILENAME: STRING; EXT: STRING); { RETROSTUFF }
 { type } ARRAY [minindex..maxindex] OF type
 FUNCTION ATAN(ARG: REAL): REAL;
          BEGIN ... END
    CONST BLACK { TURTLEGRAPHICS SCREENCOLOR }
PROCEDURE BLOCKREAD (F: FILE; VAR BUFFER: array; NUMBLOCKS: INTEGER [; BLOCKINDEX: INTEGER]);
PROCEDURE BLOCKWRITE(F: FILE; VAR BUFFER: array; NUMBLOCKS: INTEGER [; BLOCKINDEX: INTEGER]);
    CONST BLUE { TURTLEGRAPHICS SCREENCOLOR }
     TYPE BOOLEAN = (FALSE, TRUE);
 FUNCTION BUTTON(WHICH: INTEGER): BOOLEAN;
          CASE expr OF v1,v2,...: stmt; v3,...: stmt; END
     TYPE CHAR { = CHR(0)..CHR(255) }
PROCEDURE CHARTYPE(MODE: INTEGER); { TURTLEGRAPHICS; see TURTLEGRAPHICS UNIT source for Retro-Pascal specific extensions }
 FUNCTION CHR(CHARCODE: INTEGER): CHAR; { character with CHARCODE }
PROCEDURE CLOSE(F: FILE [; CLOSEHOW: (NORMAL,LOCK,PURGE)]);
 FUNCTION CONCAT(S1, S2, ...: STRING): STRING;
          CONST c1 = v1; c2 = v2; ...
 FUNCTION COPY(S: STRING; FROMPOS, HOWMANY: INTEGER): STRING;
 FUNCTION COS(ARG: REAL): REAL;
PROCEDURE DELETE(VAR S: STRING; FROMPOS, HOWMANY: INTEGER);
          DIV { i DIV j; INTEGER division }
          DO { FOR var:=start TO end DO stmt; WHILE expr DO stmt }
          DOWNTO { FOR var:=start DOWNTO end DO stmt ; use this when end < start }
PROCEDURE DRAWBLOCK(VAR SOURCE; ROWSIZE, XSKIP, YSKIP, WIDTH, HEIGHT, XSCREEN, YSCREEN, MODE: INTEGER); { TURTLEGRAPHICS; has Retro-Pascal specific extensions }
          ELSE { IF expr THEN stmt ELSE stmt }
          END
 FUNCTION EOF(F: FILE): BOOLEAN;
 FUNCTION EOLN(F: FILE): BOOLEAN;
          EXIT(functionname)
 FUNCTION EXP(ARG: REAL): REAL;
    CONST FALSE { BOOLEAN }
 { type } FILE OF type
PROCEDURE FILLCHAR(DESTINATION: array, LENGTH: INTEGER, CHARACTER: CHAR);   { ...also pointer to a single object? How about UNITREAD? }
PROCEDURE FILLSCREEN(FILLCOLOR: SCREENCOLOR); { TURTLEGRAPHICS }
          FOR var:=start TO     end DO stmt
          FOR var:=start DOWNTO end DO stmt
          FORWARD { e.g. PROCEDURE CLEARSCREEN; FORWARD; }
          FUNCTION name xyz
PROCEDURE GET(F: FILE);
PROCEDURE GETTERMSIZE(VAR WIDTH, HEIGHT: INTEGER); { RETROSTUFF }
          GOTO label
PROCEDURE GOTOXY(COLUMN, ROW: INTEGER); { top-left corner is (0,0) }
PROCEDURE GRAFMODE; { TURTLEGRAPHICS }
    CONST GREEN { TURTLEGRAPHICS SCREENCOLOR }
PROCEDURE HOLDFRAME(HOLDORNOT: BOOLEAN); { TURTLEGRAPHICS; Retro-Pascal specific }
PROCEDURE IDSEARCH (VAR OFFSET:INTEGER; VARBUFFER:BYTESTREAM); { special function for Pascal compiler use only }
          IF expr THEN stmt ELSE stmt
          IN { e.g. IF (CH IN ['Y','N',CHR(27)]) THEN ... }
PROCEDURE INITTURTLE; { TURTLEGRAPHICS }
      VAR INPUT: TEXT;  { standard input; terminal with echo }
PROCEDURE INSERT(WHAT: STRING; VAR INTOWHAT: STRING; ATPOS: INTEGER)
     TYPE INTEGER { = (-32768..32767)
 FUNCTION IORESULT: INTEGER;
      VAR KEYBOARD: TEXT;      { for reading from keyboard without terminal echo }
 FUNCTION KEYPRESS: BOOLEAN; { APPLESTUFF }
          LABEL label;
 FUNCTION LENGTH(S: STRING): INTEGER;
 FUNCTION LN(ARG: REAL): REAL;
 FUNCTION LOG(ARG: REAL): REAL;
PROCEDURE MARK(VAR HEAPTOP: ^INTEGER);
    CONST MAXINT { = 32767 }
          MOD { i MOD j; INTEGER division modulus, result in [0..j-1] }
PROCEDURE MOVE(RELDISTANCE: INTEGER); { TURTLEGRAPHICS }
PROCEDURE MOVELEFT (SRC, DST: arraywithoptionaloffset; NUMBYTES: INTEGER);
PROCEDURE MOVERIGHT(SRC, DST: arraywithoptionaloffset; NUMBYTES: INTEGER);
PROCEDURE MOVETO(X, Y: INTEGER); { TURTLEGRAPHICS }
          NEW(VAR PTR: ^any [; casesel1 [; casesel2 [; ...]]]);
PROCEDURE NEWARRAY(VAR X: arraytype; COUNT, SIZEINBYTES: INTEGER); { RETROSTUFF }
    CONST NIL { the null pointer }
    CONST NONE { TURTLEGRAPHICS SCREENCOLOR }
          NOT expr
PROCEDURE NOTE(PITCH,DURATION: INTEGER); { APPLESTUFF; PITCH=MIDI note; DURATION in ms }
          OF { used in RECORD, ARRAY, SET, and CASE }
PROCEDURE OPENNEW(F: FILE; FILENAME: STRING);
PROCEDURE OPENOLD(F: FILE; FILENAME: STRING);
          OR { e.g. IF (CH<'0') OR (CH<'0') THEN ... }
    CONST ORANGE { TURTLEGRAPHICS SCREENCOLOR }
 FUNCTION ORD(V: scalartype): INTEGER;
 FUNCTION ORD(P: ^any): INTEGER; { ...does this exist? }
      VAR OUTPUT: TEXT;  { standard output }
 { type } PACKED ARRAY ...
 { type } PACKED RECORD ...   { ... any other? }
 FUNCTION PADDLE(WHICH: INTEGER): INTEGER;
PROCEDURE PAGE;
PROCEDURE PAGE(F: TEXT);   ...also other types?
PROCEDURE PENCOLOR(PCOLOR: SCREENCOLOR); { TURTLEGRAPHICS }
 FUNCTION POS(WHAT, INWHAT: STRING); { returns 0 if not found }
 FUNCTION PRED(V: scalartype): INTEGER;
          PROCEDURE name;
          PROCEDURE name(parameter list);
          PROGRAM name;
          PROGRAM name(INPUT, OUTPUT); { note: args ignored }
PROCEDURE PUT(F: FILE);
 FUNCTION RAMAVAIL: REAL;     { RETROSTUFF }
 FUNCTION RANDOM: INTEGER;    { APPLESTUFF }
PROCEDURE RANDOMIZE;          { APPLESTUFF }
PROCEDURE READ(...); {...TODO}
PROCEDURE READLN; {...TODO}
PROCEDURE READLN(...); {...TODO}
PROCEDURE READLNPATHNAME(VAR PATHNAME: STRING; SUFFIXES, EXTENSION: STRING); { RETROSTUFF }
     TYPE REAL { IEEE single-precision float }
 { type } RECORD field1, field2: type1; field3: type3 ... END
PROCEDURE RELEASE(VAR HEAPTOPTORESTORETO: ^INTEGER);
          REPEAT stmt1; stmt2... UNTIL expr
PROCEDURE RESET(F: FILE);
PROCEDURE RESET(F: FILE; FILENAME: STRING);
    CONST REVERSE { TURTLEGRAPHICS SCREENCOLOR }
PROCEDURE REWRITE(F: FILE; FILENAME: STRING);
 FUNCTION RGBCOLOR(R, G, B: REAL): SCREENCOLOR; { TURTLEGRAPHICS; Retro-Pascal specific }
 FUNCTION ROUND(V:REAL): INTEGER; { round towards nearest INTEGER value }
 FUNCTION SCALEMODE(SCALEFACTOR: INTEGER): INTEGER; { TURTLEGRAPHICS; Retro-Pascal specific }
 FUNCTION SCAN(LEN: INTEGER, = FORWHAT: CHAR, VAR ARRAY[OFFSET]; { e.g. POS:=SCAN(LENGTH(STR), = '[', STR[1]); pass length<0 to search backward }
 FUNCTION SCREENBIT(X, Y: INTEGER): BOOLEAN; { TURTLEGRAPHICS, not supported in Retro Pascal }
     TYPE SCREENCOLOR
PROCEDURE SEEK(F: FILE, RECORDNO: INTEGER);
  SEGMENT PROCEDURE ...
 { type } SET OF type
 FUNCTION SIN(ARG: REAL): REAL;
 FUNCTION SIZEOF(variable): INTEGER;
 FUNCTION SIZEOF(type): INTEGER;
 FUNCTION SQR(ARG: INTEGER): INTEGER;  {... and/or REAL?}
 FUNCTION SQRT(ARG: REAL): REAL;
PROCEDURE STR(V: INTEGER;   VAR OUT: STRING[.]); {...exists?}
PROCEDURE STR(V: REAL;      VAR OUT: STRING[.]); {...exists?}
PROCEDURE STR(V: INTEGER[]; VAR OUT: STRING[.]);
     TYPE STRING = STRING[80];    { ... check this }
 { type } STRING[numchars]
 FUNCTION SUCC(V: scalartype): scalartype;
 FUNCTION SYNCFRAME: INTEGER; { TURTLEGRAPHICS; Retro-Pascal specific }
     TYPE TEXT { similar to FILE OF CHAR }   {... is it the same? }
PROCEDURE TEXTMODE; { TURTLEGRAPHICS }
          THEN { IF expr THEN stmt ELSE stmt }
PROCEDURE TIME(VAR HNOW, LNOW: INTEGER);
          TO { FOR var:=start DOWNTO end DO stmt }
 FUNCTION TREESEARCH (ROOTPTR: ^NODE; VAR NODEPTR: ^NODE; ID: PACKED ARRAY [1..8] OF CHAR) :INTEGER; { cf. give title of Apple TechNote }
    CONST TRUE { BOOLEAN }
 FUNCTION TRUNC(V: REAL):      INTEGER;    ...exists?
 FUNCTION TRUNC(V: INTEGER[]): INTEGER;
PROCEDURE TTLOUT(WHICH: INTEGER; DATA: BOOLEAN); { APPLESTUFF, not supported in Retro Pascal }
PROCEDURE TURN(RELANGLE: INTEGER); { TURTLEGRAPHICS }
PROCEDURE TURNTO(ANGLE: INTEGER); { TURTLEGRAPHICS }
 FUNCTION TURTLEANG: INTEGER; { TURTLEGRAPHICS }
 FUNCTION TURTLEX: INTEGER; { TURTLEGRAPHICS }
 FUNCTION TURTLEY: INTEGER; { TURTLEGRAPHICS }
          TYPE typename1 = type1; typename2 = type2; ...
 FUNCTION UNITREAD (UNIT: INTEGER; VAR VARTOREAD:  any; BYTES: INTEGER [; BLOCK: INTEGER [; MODE: INTEGER]])
 FUNCTION UNITWRITE(UNIT: INTEGER; VAR VALTOWRITE: any; BYTES: INTEGER [; BLOCK: INTEGER [; MODE: INTEGER]])
          UNTIL { REPEAT stmt1; stmt2... UNTIL expr }
          VAR varname1, varname2, ...: type1; varname3: typename3; ...
PROCEDURE VIEWPORT(LEFT, RIGHT, BOTTOM, TOP: INTEGER); { TURTLEGRAPHICS }
    CONST VIOLET { TURTLEGRAPHICS SCREENCOLOR }
PROCEDURE WCHAR(CH: CHAR); { TURTLEGRAPHICS; see TURTLEGRAPHICS UNIT source for Retro-Pascal specific extensions }
          WHILE expr DO stmt
    CONST WHITE { TURTLEGRAPHICS SCREENCOLOR }
PROCEDURE WRITE(...);  {...TODO}
PROCEDURE WRITELN;  {...TODO}
PROCEDURE WRITELN(...);  {...TODO}
PROCEDURE WSTRING(S: STRING); { TURTLEGRAPHICS; see TURTLEGRAPHICS UNIT source for Retro-Pascal specific extensions }
PROCEDURE YIELDCPU(MS: INTEGER); { RETROSTUFF }
