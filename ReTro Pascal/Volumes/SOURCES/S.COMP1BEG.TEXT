
{.fs} (* --- original source filename: COMPGLBLS.TEXT --- *)

{.fs} { INFOREC from GLOBALS.TEXT (we should really get it from there...) }
{.fs} CONST
{.fs}      VIDLENG = 7;       (*NUMBER OF CHARS IN A VOLUME ID*)
{.fs}      TIDLENG = 15;      (*NUMBER OF CHARS IN TITLE ID*)
TYPE PHYLE = FILE;
{.fs}      VID = STRING[VIDLENG];
{.fs}      TID = STRING[TIDLENG];
INFOREC = RECORD
	    WORKSYM,WORKCODE: ^PHYLE;
	    ERRSYM,ERRBLK,ERRNUM: INTEGER;
	    SLOWTERM,STUPID: BOOLEAN;
	    ALTMODE: CHAR;
{.fs}	    GOTSYM,GOTCODE: BOOLEAN;       (*TITLES ARE MEANINGFUL*)
{.fs}	    WORKVID,SYMVID,CODEVID: VID;   (*PERM&CUR WORKFILE VOLUMES*)
{.fs}	    WORKTID,SYMTID,CODETID: TID    (*PERM&CUR WORKFILES TITLE*)
	  END;


{.fs#} { interface does not exist; instead using the same mechanism as EDITOR }
{.fs# SEGMENT PROCEDURE USERPROGRAM;   }

{.fs#   SEGMENT PROCEDURE FILEHANDLER; }
{.fs#   BEGIN END;                     }

{.fs#   SEGMENT PROCEDURE DEBUGGER;    }
{.fs#   BEGIN END;                     }

{.fs#   SEGMENT PROCEDURE PRINTERROR;  }
{.fs#   BEGIN END;                     }

{.fs#   SEGMENT PROCEDURE INITIALIZE;  }
{.fs#   BEGIN END;                     }

{.fs#   SEGMENT PROCEDURE GETCMD;      }
{.fs#   BEGIN END;                     }

{.fs#   SEGMENT PROCEDURE NOTUSED1;    }
{.fs#   BEGIN END;                     }

{.fs#   SEGMENT PROCEDURE NOTUSED2;    }
{.fs#   BEGIN END;                     }

{.fs#   SEGMENT PROCEDURE NOTUSED3;    }
{.fs#   BEGIN END;                     }

{.fs# BEGIN END; (* USERPROGRAM *)     }

{.fs# SEGMENT PROCEDURE PASCALCOMPILER(VAR USERINFO: INFOREC); }

{.fs} { access to USERINFO through globals }
{.fs} { (this is copied from EDITOR.TEXT) }
{.fs} VAR (* I.4 Globals as of 30-Jan-78 *)
{.fs}   TRASHY: ARRAY [0..6] OF INTEGER;
{.fs}   USERINFO: INFOREC;

{.fs} SEGMENT PROCEDURE PASCALCOMPILER(XXX,YYY: INTEGER);

CONST DISPLIMIT = 12; MAXLEVEL = 8; MAXADDR = 28000;
      INTSIZE = 1; REALSIZE = 2; BITSPERWD = 16;
      CHARSIZE = 1; BOOLSIZE = 1; PTRSIZE = 1;
      FILESIZE = 300; NILFILESIZE = 40; BITSPERCHR = 8; CHRSPERWD = 2;
      STRINGSIZE = 0; STRGLGTH = 255; MAXINT = 32767; MAXDEC = 36;
      DEFSTRGLGTH = 80; LCAFTERMARKSTACK = 1; REFSPERBLK = 128;
{.fs# EOL = 13; MAXCURSOR = 1023; MAXCODE = 1299; }
{.fs} EOL = 13; MAXCURSOR = 1023; MAXCODE = 13999;   { increased per-proc limit }
{.fs} DISPUJPFLAG = 14000;  { max IC<DISPUJPFLAG; IC+DISPUJPFLAG<MAXADDR }
      MAXJTAB = 24; MAXSEG = 15; MAXPROCNUM = 149;

TYPE
		 (*BASIC SYMBOLS, MUST MATCH ORDER IN IDSEARCH*)

     SYMBOL =  (IDENT,COMMA,COLON,SEMICOLON,LPARENT,RPARENT,DOSY,TOSY,
		DOWNTOSY,ENDSY,UNTILSY,OFSY,THENSY,ELSESY,BECOMES,LBRACK,
		RBRACK,ARROW,PERIOD,BEGINSY,IFSY,CASESY,REPEATSY,WHILESY,
		FORSY,WITHSY,GOTOSY,LABELSY,CONSTSY,TYPESY,VARSY,PROCSY,
		FUNCSY,PROGSY,FORWARDSY,INTCONST,REALCONST,STRINGCONST,
		NOTSY,MULOP,ADDOP,RELOP,SETSY,PACKEDSY,ARRAYSY,RECORDSY,
		FILESY,OTHERSY,LONGCONST,USESSY,UNITSY,INTERSY,IMPLESY,
		EXTERNLSY,SEPARATSY);


     OPERATOR = (MUL,RDIV,ANDOP,IDIV,IMOD,PLUS,MINUS,OROP,LTOP,LEOP,
		 GEOP,GTOP,NEOP,EQOP,INOP,NOOP);

     SETOFSYS = SET OF SYMBOL;

     NONRESIDENT = (SEEK,FREADREAL,FWRITEREAL,FREADDEC,FWRITEDEC,DECOPS);
     NONRESPFLIST = ARRAY[NONRESIDENT] OF INTEGER;

					      (*CONSTANTS*)
     CSTCLASS = (REEL,PSET,STRG,TRIX,LONG);
     CSP = ^ CONSTREC;
     CONSTREC = RECORD CASE CCLASS: CSTCLASS OF
			 LONG: (LLENG,LLAST: INTEGER;
				LONGVAL: ARRAY[1..9] OF INTEGER);
			 TRIX: (CSTVAL: ARRAY [1..8] OF INTEGER);
			       (*MUST COMPLETELY OVERLAP FOLLOWING FIELDS*)
			 REEL: (RVAL: REAL);
			 PSET: (PVAL: SET OF 0..127);
			 STRG: (SLGTH: 0..STRGLGTH;
				SVAL: PACKED ARRAY [1..STRGLGTH] OF CHAR)
		       END;

     VALU = RECORD CASE BOOLEAN OF
		     TRUE:  (IVAL: INTEGER);
		     FALSE: (VALP: CSP)
		   END;

						  (*DATA STRUCTURES*)
     BITRANGE = 0..BITSPERWD; OPRANGE = 0..80;
     CURSRANGE = 0..MAXCURSOR; PROCRANGE = 0..MAXPROCNUM;
     LEVRANGE = 0..MAXLEVEL; ADDRRANGE = 0..MAXADDR;
     JTABRANGE = 0..MAXJTAB; SEGRANGE = 0..MAXSEG;
     DISPRANGE = 0..DISPLIMIT;

     STRUCTFORM = (SCALAR,SUBRANGE,POINTER,LONGINT,POWER,ARRAYS,
		   RECORDS,FILES,TAGFLD,VARIANT);

     DECLKIND = (STANDARD,DECLARED,SPECIAL);

     STP = ^ STRUCTURE; CTP = ^ IDENTIFIER;

     STRUCTURE = RECORD
		   SIZE: ADDRRANGE;
		   CASE FORM: STRUCTFORM OF
		     SCALAR:   (CASE SCALKIND: DECLKIND OF
				  DECLARED: (FCONST: CTP));
		     SUBRANGE: (RANGETYPE: STP; MIN,MAX: VALU);
		     POINTER:  (ELTYPE: STP);
		     POWER:    (ELSET: STP);
		     ARRAYS:   (AELTYPE,INXTYPE: STP;
				CASE AISPACKD:BOOLEAN OF
				  TRUE: (ELSPERWD,ELWIDTH: BITRANGE;
					 CASE AISSTRNG: BOOLEAN OF
					  TRUE:(MAXLENG: 1..STRGLGTH)));
		     RECORDS:  (FSTFLD: CTP; RECVAR: STP);
		     FILES:    (FILTYPE: STP);
		     TAGFLD:   (TAGFIELDP: CTP; FSTVAR: STP);
		     VARIANT:  (NXTVAR,SUBVAR: STP; VARVAL: VALU)
		   END;

							    (*NAMES*)
     IDCLASS = (TYPES,KONST,FORMALVARS,ACTUALVARS,FIELD,
		PROC,FUNC,MODULE);
     SETOFIDS = SET OF IDCLASS;
     IDKIND = (ACTUAL,FORMAL);
     ALPHA = PACKED ARRAY [1..8] OF CHAR;
     
     IDENTIFIER = RECORD
		   NAME: ALPHA; LLINK, RLINK: CTP;
		   IDTYPE: STP; NEXT: CTP;
		   CASE KLASS: IDCLASS OF
		     KONST: (VALUES: VALU);
		FORMALVARS,
		ACTUALVARS: (VLEV: LEVRANGE;
			     VADDR: ADDRRANGE;
			     CASE BOOLEAN OF
			       TRUE: (PUBLIC: BOOLEAN));
		     FIELD: (FLDADDR: ADDRRANGE;
			     CASE FISPACKD: BOOLEAN OF
			       TRUE: (FLDRBIT,FLDWIDTH: BITRANGE));
		     PROC,
		     FUNC:  (CASE PFDECKIND: DECLKIND OF
			      SPECIAL:  (KEY: INTEGER);
			      STANDARD: (CSPNUM: INTEGER);
			      DECLARED: (PFLEV: LEVRANGE;
					 PFNAME: PROCRANGE;
					 PFSEG: SEGRANGE;
					 CASE PFKIND: IDKIND OF
					  ACTUAL: (LOCALLC: ADDRRANGE;
						   FORWDECL: BOOLEAN;
						   EXTURNAL: BOOLEAN;
						   INSCOPE: BOOLEAN;
						   CASE BOOLEAN OF
						    TRUE: (IMPORTED:BOOLEAN))));
		   MODULE: (SEGID: INTEGER)
		   END;


     WHERE = (BLCK,CREC,VREC,REC);

					      (*EXPRESSIONS*)
     ATTRKIND = (CST,VARBL,EXPR);
     VACCESS = (DRCT,INDRCT,PACKD,MULTI,BYTE);

     ATTR = RECORD TYPTR: STP;
	      CASE KIND: ATTRKIND OF
		CST:   (CVAL: VALU);
		VARBL: (CASE ACCESS: VACCESS OF
			  DRCT:   (VLEVEL: LEVRANGE; DPLMT: ADDRRANGE);
			  INDRCT: (IDPLMT: ADDRRANGE))
	    END;

     TESTP = ^ TESTPOINTER;
     TESTPOINTER = RECORD
		     ELT1,ELT2 : STP;
		     LASTTESTP : TESTP
		   END;

						   (*LABELS*)
     LBP = ^ CODELABEL;
     CODELABEL = RECORD
		   CASE DEFINED: BOOLEAN OF
		     FALSE: (REFLIST: ADDRRANGE); {.fs +DISPUJPFLAG if UJP else FJP}
		     TRUE:  (OCCURIC: ADDRRANGE; JTABINX: JTABRANGE)
		 END;

     LABELP = ^ USERLABEL;
     USERLABEL = RECORD
		   LABVAL: INTEGER;
		   NEXTLAB: LABELP;
		   CODELBP: LBP
		 END;

     REFARRAY = ARRAY[1..REFSPERBLK] OF
		  RECORD
		    KEY,OFFSET: INTEGER
		  END;

     CODEARRAY = PACKED ARRAY [0..MAXCODE] OF CHAR;
     SYMBUFARRAY = PACKED ARRAY [CURSRANGE] OF CHAR;
     
     UNITFILE = (WORKCODE,SYSLIBRARY);

     LEXSTKREC = RECORD
		   DOLDTOP: DISPRANGE;
		   DOLDLEV: 0..MAXLEVEL;
		   POLDPROC,SOLDPROC: PROCRANGE;
		   DOLDSEG: SEGRANGE;
		   DLLC: ADDRRANGE;
		   BFSY: SYMBOL;
		   DFPROCP: CTP;
		   DMARKP: ^INTEGER;
		   ISSEGMENT: BOOLEAN;
		   PREVLEXSTACKP: ^LEXSTKREC
		 END;


(*--------------------------------------------------------------------*)

VAR

    CODEP: ^ CODEARRAY;             (*CODE BUFFER UNTIL WRITEOUT*)
    SYMBUFP: ^ SYMBUFARRAY;         (*SYMBOLIC BUFFER...ASCII OR CODED*)

    GATTR: ATTR;                    (*DESCRIBES CURRENT EXPRESSION*)

    TOP: DISPRANGE;                 (*TOP OF DISPLAY*)
    LC,IC: ADDRRANGE;               (*LOCATION AND INSTRUCT COUNTERS*)
    TEST: BOOLEAN;
    INTPTR: STP;                    (*POINTER TO STANDARD INTEGER TYPE*)
    SEG: SEGRANGE;                  (*CURRENT SEGMENT NO.*)
				    (*SCANNER GLOBALS...NEXT FOUR VARS*)
				    (*MUST BE IN THIS ORDER FOR IDSEARCH*)
    SYMCURSOR: CURSRANGE;           (*CURRENT SCANNING INDEX IN SYMBUFP^*)
    SY: SYMBOL;                     (*SYMBOL FOUND BY INSYMBOL*)
    OP: OPERATOR;                   (*CLASSIFICATION OF LAST SYMBOL*)
    ID: ALPHA;                      (*LAST IDENTIFIER FOUND*)

    LGTH: INTEGER;                  (*LENGTH OF LAST STRING CONSTANT IN CHARS
				      OR LEN OF LAST LONG INTEGER CONSTANT
				       IN DIGITS*)
    VAL: VALU;                      (*VALUE OF LAST CONSTANT*)
    DISX: DISPRANGE;                (*LEVEL OF LAST ID SEARCHED*)

    LCMAX: ADDRRANGE;               (*TEMPORARIES LOCATION COUNTER*)

				    (*SWITCHES:*)

    PRTERR,GOTOOK,RANGECHECK,DEBUGGING,
    NOISY,CODEINSEG,IOCHECK,BPTONLINE,
    CLINKERINFO,DLINKERINFO,LIST,TINY,LSEPPROC,
    DP,INCLUDING,USING,NOSWAP,SEPPROC,
    STARTINGUP,INMODULE,ININTERFACE,FLIPBYTES,
    LIBNOTOPEN,SYSCOMP,PUBLICPROCS,GETSTMTLEV: BOOLEAN;

				    (*POINTERS:*)
    (*INTPTR,*)REALPTR,LONGINTPTR,
    CHARPTR,BOOLPTR,
    TEXTPTR,NILPTR,
    INTRACTVPTR,STRGPTR: STP;       (*POINTERS TO STANDARD IDS*)

    UTYPPTR,UCSTPTR,UVARPTR,
    UFLDPTR,UPRCPTR,UFCTPTR,        (*POINTERS TO UNDECLARED IDS*)
    MODPTR,INPUTPTR,OUTPUTPTR,
    OUTERBLOCK,FWPTR,USINGLIST: CTP;

    GLOBTESTP: TESTP;               (*LAST TESTPOINTER*)

    LEVEL: LEVRANGE;                (*CURRENT STATIC LEVEL*)
    BEGSTMTLEV,STMTLEV: INTEGER;    (*CURRENT STATEMENT NESTING LEVEL*)
    MARKP: ^INTEGER;                (*FOR MARKING HEAP*)
    TOS: ^LEXSTKREC;                (*TOP OF LEX STACK*)
    GLEV: DISPRANGE;                (*GLOBAL LEVEL OF DISPLAY*)
    NEWBLOCK: BOOLEAN;              (*INDICATES NEED TO PUSH LEX STACK*)

    NEXTSEG: SEGRANGE;              (*NEXT SEGMENT #*)
    SEGINX: INTEGER;                (*CURRENT INDEX IN SEGMENT*)
    SCONST: CSP;                    (*INSYMBOL STRING RESULTS*)
    STRGCSTIC: ADDRRANGE;           (*ADDR OF LAST STRING IN CODE*)

    LOWTIME,LINEINFO,SCREENDOTS,STARTDOTS,SYMBLK,SMALLESTSPACE: INTEGER;
{.fs} INCLDOTS: INTEGER;            { for showing correct total/timing }
    LINESTART: CURSRANGE;

    CURPROC,NEXTPROC: PROCRANGE;     (*PROCEDURE NUMBER ASSIGNMENT*)

    CONSTBEGSYS,SIMPTYPEBEGSYS,TYPEBEGSYS,
    BLOCKBEGSYS,SELECTSYS,FACBEGSYS,STATBEGSYS,TYPEDELS: SETOFSYS;
    VARS: SETOFIDS;

    DISPLAY: ARRAY [DISPRANGE] OF
		RECORD
		  FNAME: CTP;
		  CASE OCCUR: WHERE OF
		    BLCK: (FFILE: CTP; FLABEL: LABELP);
		    CREC: (CLEV: LEVRANGE; CDSPL: ADDRRANGE);
		    VREC: (VDSPL: ADDRRANGE)
		  END;

    PFNUMOF: NONRESPFLIST;

    PROCTABLE: ARRAY [PROCRANGE] OF INTEGER;

    SEGTABLE: ARRAY [SEGRANGE] OF
		RECORD
		  DISKADDR,CODELENG: INTEGER;
		  SEGNAME: ALPHA;
		  SEGKIND,
		  TEXTADDR: INTEGER
		END (*SEGTABLE*) ;

    COMMENT: ^STRING;
    SYSTEMLIB: STRING[40];
    NEXTJTAB: JTABRANGE;
    JTAB: ARRAY [JTABRANGE] OF INTEGER;

    REFFILE: FILE;
    NREFS,REFBLK: INTEGER;
    REFLIST: ^REFARRAY;
    OLDSYMBLK,PREVSYMBLK: INTEGER;
    OLDSYMCURSOR,OLDLINESTART,PREVSYMCURSOR,PREVLINESTART: CURSRANGE;
{.fs} OLDDOTS: INTEGER;         { for printing line numbers correctly }
    USEFILE: UNITFILE;
{.fs# INCLFILE,LIBRARY: FILE; } { compiler bug, cannot handle multiple FILE decls }
{.fs} LIBRARY: FILE; INCLFILE: FILE;
{.fs} INCLNAME: STRING[40];     { for error messages }
    LP: TEXT;

    CURBYTE, CURBLK: INTEGER;
    DISKBUF: PACKED ARRAY [0..511] OF CHAR;

(*--------------------------------------------------------------------*)

{.fs} { occupy the segments we should not get into (copied from EDITOR) }
{.fs} SEGMENT PROCEDURE NUM2; BEGIN END;      SEGMENT PROCEDURE NUM3; BEGIN END;
{.fs} SEGMENT PROCEDURE NUM4; BEGIN END;      SEGMENT PROCEDURE NUM5; BEGIN END;
{.fs} SEGMENT PROCEDURE NUM6; BEGIN END;      SEGMENT PROCEDURE NUM7; BEGIN END;
{.fs} SEGMENT PROCEDURE NUM8; BEGIN END;      SEGMENT PROCEDURE NUM9; BEGIN END;

(* FORWARD DECLARED PROCEDURES NEEDED BY COMPINIT *)

PROCEDURE ERROR(ERRORNUM: INTEGER);
  FORWARD;
PROCEDURE GETNEXTPAGE;
  FORWARD;
PROCEDURE PRINTLINE;
  FORWARD;
PROCEDURE ENTERID(FCP: CTP);
  FORWARD;
PROCEDURE INSYMBOL;
  FORWARD;

(* FORWARD DECLARED PROCEDURES USED IN BOTH DECLARATIONPART AND BODYPART *)

PROCEDURE SEARCHSECTION(FCP:CTP; VAR FCP1: CTP);
  FORWARD;
PROCEDURE SEARCHID(FIDCLS: SETOFIDS; VAR FCP: CTP);
  FORWARD;
PROCEDURE GETBOUNDS(FSP: STP; VAR FMIN,FMAX: INTEGER);
  FORWARD;
PROCEDURE SKIP(FSYS: SETOFSYS);
  FORWARD;
FUNCTION PAOFCHAR(FSP: STP): BOOLEAN;
  FORWARD;
FUNCTION STRGTYPE(FSP: STP): BOOLEAN;
  FORWARD;
FUNCTION DECSIZE(I: INTEGER): INTEGER;
  FORWARD;
PROCEDURE CONSTANT(FSYS: SETOFSYS; VAR FSP: STP; VAR FVALU: VALU);
  FORWARD;
FUNCTION COMPTYPES(FSP1,FSP2: STP): BOOLEAN;
  FORWARD;
PROCEDURE GENBYTE(FBYTE: INTEGER);
  FORWARD;
PROCEDURE GENWORD(FWORD: INTEGER);
  FORWARD;
PROCEDURE WRITETEXT;
  FORWARD;
PROCEDURE WRITECODE(FORCEBUF: BOOLEAN);
  FORWARD;
PROCEDURE BLOCK(FSYS: SETOFSYS);
  FORWARD;

(* --- COMPINIT.TEXT --- *)

SEGMENT PROCEDURE COMPINIT;

  PROCEDURE ENTSTDTYPES;
  BEGIN
    NEW(INTPTR,SCALAR,STANDARD);
    WITH INTPTR^ DO
      BEGIN SIZE := INTSIZE; FORM := SCALAR; SCALKIND := STANDARD END;
    NEW(REALPTR,SCALAR,STANDARD);
    WITH REALPTR^ DO
      BEGIN SIZE := REALSIZE; FORM := SCALAR; SCALKIND := STANDARD END;
    NEW(LONGINTPTR,LONGINT);
    WITH LONGINTPTR^ DO
      BEGIN SIZE := DECSIZE((BITSPERWD-1)*100 DIV 332 + 1); FORM := LONGINT END;
    NEW(CHARPTR,SCALAR,STANDARD);
    WITH CHARPTR^ DO
      BEGIN SIZE := CHARSIZE; FORM := SCALAR; SCALKIND := STANDARD END;
    NEW(BOOLPTR,SCALAR,DECLARED);
    WITH BOOLPTR^ DO
      BEGIN SIZE := BOOLSIZE; FORM := SCALAR; SCALKIND := DECLARED END;
    NEW(NILPTR,POINTER);
    WITH NILPTR^ DO
      BEGIN SIZE := PTRSIZE; FORM := POINTER; ELTYPE := NIL END;
    NEW(TEXTPTR,FILES);
    WITH TEXTPTR^ DO
      BEGIN SIZE := FILESIZE+CHARSIZE; FORM := FILES; FILTYPE := CHARPTR END;
    NEW(INTRACTVPTR,FILES);
    WITH INTRACTVPTR^ DO
      BEGIN SIZE := FILESIZE+CHARSIZE; FORM := FILES; FILTYPE := CHARPTR END;
    NEW(STRGPTR,ARRAYS,TRUE,TRUE);
    WITH STRGPTR^ DO
      BEGIN FORM := ARRAYS; SIZE := (DEFSTRGLGTH + CHRSPERWD) DIV CHRSPERWD;
	AISPACKD := TRUE; AISSTRNG := TRUE; INXTYPE := INTPTR;
	ELWIDTH := BITSPERCHR; ELSPERWD := CHRSPERWD;
	AELTYPE := CHARPTR; MAXLENG := DEFSTRGLGTH;
      END
  END (*ENTSTDTYPES*) ;

  PROCEDURE ENTSTDNAMES;
    VAR CP,CP1: CTP; I: INTEGER;
  BEGIN
    NEW(CP,TYPES);
    WITH CP^ DO
      BEGIN NAME := 'INTEGER '; IDTYPE := INTPTR; KLASS := TYPES END;
    ENTERID(CP);
    NEW(CP,TYPES);
    WITH CP^ DO
      BEGIN NAME := 'REAL    '; IDTYPE := REALPTR; KLASS := TYPES END;
    ENTERID(CP);
    NEW(CP,TYPES);
    WITH CP^ DO
      BEGIN NAME := 'CHAR    '; IDTYPE := CHARPTR; KLASS := TYPES END;
    ENTERID(CP);
    NEW(CP,TYPES);
    WITH CP^ DO
      BEGIN NAME := 'BOOLEAN '; IDTYPE := BOOLPTR; KLASS := TYPES END;
    ENTERID(CP);
    NEW(CP,TYPES);
    WITH CP^ DO
      BEGIN NAME := 'STRING  '; IDTYPE := STRGPTR; KLASS := TYPES END;
    ENTERID(CP);
    NEW(CP,TYPES);
    WITH CP^ DO
      BEGIN NAME := 'TEXT    '; IDTYPE := TEXTPTR; KLASS := TYPES END;
    ENTERID(CP);
    NEW(CP,TYPES);
    WITH CP^ DO
      BEGIN NAME := 'INTERACT'; IDTYPE := INTRACTVPTR; KLASS := TYPES END;
    ENTERID(CP);
    NEW(INPUTPTR,FORMALVARS,FALSE);
    WITH INPUTPTR^ DO
      BEGIN NAME := 'INPUT   '; IDTYPE := TEXTPTR; KLASS := FORMALVARS;
	VLEV := 0; VADDR := 2
      END;
    ENTERID(INPUTPTR);
    NEW(OUTPUTPTR,FORMALVARS,FALSE);
    WITH OUTPUTPTR^ DO
      BEGIN NAME := 'OUTPUT  '; IDTYPE := TEXTPTR; KLASS := FORMALVARS;
	VLEV := 0; VADDR := 3
      END;
    ENTERID(OUTPUTPTR);
    NEW(CP,FORMALVARS,FALSE);
    WITH CP^ DO
      BEGIN NAME := 'KEYBOARD'; IDTYPE := TEXTPTR; KLASS := FORMALVARS;
	VLEV := 0; VADDR := 4
      END;
    ENTERID(CP);
    CP1 := NIL;
    FOR I := 0 TO 1 DO
      BEGIN NEW(CP,KONST);
	WITH CP^ DO
	  BEGIN IDTYPE := BOOLPTR;
	    IF I = 0 THEN NAME := 'FALSE   '
	    ELSE NAME := 'TRUE    ';
	    NEXT := CP1; VALUES.IVAL := I; KLASS := KONST
	  END;
	ENTERID(CP); CP1 := CP
      END;
    BOOLPTR^.FCONST := CP;
    NEW(CP,KONST);
    WITH CP^ DO
      BEGIN NAME := 'NIL     '; IDTYPE := NILPTR;
	NEXT := NIL; VALUES.IVAL := 0; KLASS := KONST
      END;
    ENTERID(CP);
    NEW(CP,KONST);
    WITH CP^ DO
      BEGIN
	NAME := 'MAXINT  '; IDTYPE := INTPTR;
	KLASS := KONST; VALUES.IVAL := MAXINT
      END;
    ENTERID(CP);
  END (*ENTSTDNAMES*) ;

  PROCEDURE ENTUNDECL;
  BEGIN
    NEW(UTYPPTR,TYPES);
    WITH UTYPPTR^ DO
      BEGIN NAME := '        '; IDTYPE := NIL; KLASS := TYPES END;
    NEW(UCSTPTR,KONST);
    WITH UCSTPTR^ DO
      BEGIN NAME := '        '; IDTYPE := NIL; NEXT := NIL;
	VALUES.IVAL := 0; KLASS := KONST
      END;
    NEW(UVARPTR,ACTUALVARS,FALSE);
    WITH UVARPTR^ DO
      BEGIN NAME := '        '; IDTYPE := NIL;
	NEXT := NIL; VLEV := 0; VADDR := 0; KLASS := ACTUALVARS
      END;
    NEW(UFLDPTR,FIELD);
    WITH UFLDPTR^ DO
      BEGIN NAME := '        '; IDTYPE := NIL; NEXT := NIL;
	FLDADDR := 0; KLASS := FIELD
      END;
    NEW(UPRCPTR,PROC,DECLARED,ACTUAL,FALSE);
    WITH UPRCPTR^ DO
      BEGIN NAME := '        '; IDTYPE := NIL; FORWDECL := FALSE;
	NEXT := NIL; INSCOPE := FALSE; LOCALLC := 0; EXTURNAL := FALSE;
	PFLEV := 0; PFNAME := 0; PFSEG := 0;
	KLASS := PROC; PFDECKIND := DECLARED; PFKIND := ACTUAL
      END;
    NEW(UFCTPTR,FUNC,DECLARED,ACTUAL,FALSE);
    WITH UFCTPTR^ DO
      BEGIN NAME := '        '; IDTYPE := NIL; NEXT := NIL;
	FORWDECL := FALSE; EXTURNAL := FALSE; INSCOPE := FALSE; LOCALLC := 0;
	PFLEV := 0; PFNAME := 0; PFSEG := 0;
	KLASS := FUNC; PFDECKIND := DECLARED; PFKIND := ACTUAL
      END
  END (*ENTUNDECL*) ;

  PROCEDURE ENTSPCPROCS;
    LABEL 1;
    VAR LCP: CTP; I: INTEGER; ISFUNC: BOOLEAN;
	NA: ARRAY [1..43] OF ALPHA;
  BEGIN
    NA[ 1] := 'READ    '; NA[ 2] := 'READLN  '; NA[ 3] := 'WRITE   ';
    NA[ 4] := 'WRITELN '; NA[ 5] := 'EOF     '; NA[ 6] := 'EOLN    ';
    NA[ 7] := 'PRED    '; NA[ 8] := 'SUCC    '; NA[ 9] := 'ORD     ';
    NA[10] := 'SQR     '; NA[11] := 'ABS     '; NA[12] := 'NEW     ';
    NA[13] := 'UNITREAD'; NA[14] := 'UNITWRIT'; NA[15] := 'CONCAT  ';
    NA[16] := 'LENGTH  '; NA[17] := 'INSERT  '; NA[18] := 'DELETE  ';
    NA[19] := 'COPY    '; NA[20] := 'POS     '; NA[21] := 'MOVELEFT';
    NA[22] := 'MOVERIGH'; NA[23] := 'EXIT    '; NA[24] := 'IDSEARCH';
    NA[25] := 'TREESEAR'; NA[26] := 'TIME    '; NA[27] := 'FILLCHAR';
    NA[28] := 'OPENNEW '; NA[29] := 'OPENOLD '; NA[30] := 'REWRITE ';
    NA[31] := 'CLOSE   '; NA[32] := 'SEEK    '; NA[33] := 'RESET   ';
    NA[34] := 'GET     '; NA[35] := 'PUT     '; NA[36] := 'SCAN    ';
    NA[37] := 'BLOCKREA'; NA[38] := 'BLOCKWRI'; NA[39] := 'TRUNC   ';
    NA[40] := 'PAGE    '; NA[41] := 'SIZEOF  '; NA[42] := 'STR     ';
    NA[43] := 'GOTOXY  ';
    FOR I := 1 TO 43 DO
      BEGIN
	IF TINY THEN
	    IF I IN [2,7,8,10,13,17,18,19,20,32,34,35,40,42,43] THEN
	      GOTO 1;
	ISFUNC := I IN [5,6,7,8,9,10,11,15,16,19,20,25,36,37,38,39,41];
	IF ISFUNC THEN NEW(LCP,FUNC,SPECIAL)
	ELSE NEW(LCP,PROC,SPECIAL);
	WITH LCP^ DO
	  BEGIN NAME := NA[I]; NEXT := NIL; IDTYPE := NIL;
	    IF ISFUNC THEN KLASS := FUNC ELSE KLASS := PROC;
	    PFDECKIND := SPECIAL; KEY := I
	  END;
	ENTERID(LCP);
1:    END
    END (*ENTSPCPROCS*) ;

  PROCEDURE ENTSTDPROCS;
    VAR LCP,PARAM: CTP; LSP,FTYPE: STP; I: INTEGER; ISPROC: BOOLEAN;
	NA: ARRAY [1..19] OF ALPHA;
  BEGIN
    NA[ 1] := 'ODD     '; NA[ 2] := 'CHR     '; NA[ 3] := 'MEMAVAIL';
    NA[ 4] := 'ROUND   '; NA[ 5] := 'SIN     '; NA[ 6] := 'COS     ';
    NA[ 7] := 'LOG     '; NA[ 8] := 'ATAN    '; NA[ 9] := 'LN      ';
    NA[10] := 'EXP     '; NA[11] := 'SQRT    '; NA[12] := 'MARK    ';
    NA[13] := 'RELEASE '; NA[14] := 'IORESULT'; NA[15] := 'UNITBUSY';
    NA[16] := 'PWROFTEN'; NA[17] := 'UNITWAIT'; NA[18] := 'UNITCLEA';
    NA[19] := 'HALT    ';
    FOR I := 1 TO 19 DO
      BEGIN ISPROC := I IN [12,13,17,18,19];
	CASE I OF
	  1:  BEGIN FTYPE := BOOLPTR; NEW(PARAM,ACTUALVARS,FALSE);
		WITH PARAM^ DO
		  BEGIN IDTYPE := INTPTR; KLASS := ACTUALVARS END
	      END;
	  2:  FTYPE := CHARPTR;
	  3:  BEGIN FTYPE := INTPTR; PARAM := NIL END;
	  4:  BEGIN FTYPE := INTPTR; NEW(PARAM,ACTUALVARS,FALSE);
		WITH PARAM^ DO BEGIN IDTYPE := REALPTR; KLASS := ACTUALVARS END
	      END;
	  5:  FTYPE := REALPTR;
	 12:  BEGIN FTYPE := NIL; NEW(PARAM,FORMALVARS,FALSE); NEW(LSP,POINTER);
		WITH LSP^ DO
		  BEGIN SIZE := PTRSIZE; FORM := POINTER; ELTYPE := NIL END;
		WITH PARAM^ DO BEGIN IDTYPE := LSP; KLASS := FORMALVARS END
	      END;
	 14:  BEGIN FTYPE := INTPTR; PARAM := NIL END;
	 15:  BEGIN FTYPE := BOOLPTR; NEW(PARAM,ACTUALVARS,FALSE);
	      WITH PARAM^ DO
		BEGIN IDTYPE := INTPTR; KLASS := ACTUALVARS END;
	      END;
	 16:  FTYPE := REALPTR;
	 17:  FTYPE := NIL;
	 19:  BEGIN FTYPE := NIL; PARAM := NIL END
	END (*PARAM AND TYPE CASES*) ;
	IF ISPROC THEN NEW(LCP,PROC,STANDARD)
	ELSE NEW(LCP,FUNC,STANDARD);
	WITH LCP^ DO
	  BEGIN NAME := NA[I]; PFDECKIND := STANDARD; CSPNUM := I + 20;
	    IF ISPROC THEN KLASS := PROC ELSE KLASS := FUNC;
	    IF PARAM <> NIL THEN PARAM^.NEXT := NIL;
	    IDTYPE := FTYPE; NEXT := PARAM
	  END;
	ENTERID(LCP)
      END
    END (*ENTSTDPROCS*) ;

  PROCEDURE INITSCALARS;
   VAR I: NONRESIDENT;
  BEGIN
    IF MEMAVAIL > 9950 (* EMPIRICAL VALUE FOR A 50K BYTE MACHINE *) THEN
      NOSWAP := TRUE ELSE NOSWAP := FALSE;
    FWPTR := NIL; MODPTR := NIL; GLOBTESTP := NIL;
    LINESTART := 0; LINEINFO := LCAFTERMARKSTACK; LIST := FALSE;
    SYMBLK := 2; SCREENDOTS := 0; STARTDOTS := 0;
{.fs} INCLNAME := ''; INCLDOTS := 0;
    FOR SEG := 0 TO MAXSEG DO
      WITH SEGTABLE[SEG] DO
	BEGIN DISKADDR := 0; CODELENG := 0; SEGNAME := '        ';
	  SEGKIND := 0; TEXTADDR := 0
	END;
    USINGLIST := NIL;
    IF USERINFO.STUPID THEN SYSTEMLIB := '*SYSTEM.PASCAL'
    ELSE SYSTEMLIB := '*SYSTEM.LIBRARY';
    LC := LCAFTERMARKSTACK; IOCHECK := TRUE; DP := TRUE;
    SEGINX := 0; NEXTJTAB := 1; NEXTPROC := 2; CURPROC := 1;
    NEW(SCONST); NEW(SYMBUFP); NEW(CODEP);
    CLINKERINFO := FALSE; DLINKERINFO := FALSE;
{.fs# SEG := 1; NEXTSEG := 10; CURBLK := 1; CURBYTE := 0; LSEPPROC := FALSE; }
{.fs} SEG := 1; NEXTSEG := 2; CURBLK := 1; CURBYTE := 0; LSEPPROC := FALSE;
{.fs} { Retro Pascal has unlimited code space, so SYS is all in seg #0 }
    STARTINGUP := TRUE; NOISY := NOT USERINFO.SLOWTERM; SEPPROC := FALSE;
    DEBUGGING := FALSE; BPTONLINE := FALSE; INMODULE := FALSE;
    GOTOOK := FALSE; RANGECHECK := TRUE; SYSCOMP := FALSE; TINY := FALSE;
    CODEINSEG := FALSE; PRTERR := TRUE; INCLUDING := FALSE; USING := FALSE;
    FOR I := SEEK TO DECOPS DO PFNUMOF[I] := 0;
    COMMENT := NIL; LIBNOTOPEN := TRUE;
    GETSTMTLEV := TRUE; BEGSTMTLEV := 0;
    FLIPBYTES := FALSE
  END (*INITSCALARS*) ;

  PROCEDURE INITSETS;
  BEGIN
    CONSTBEGSYS := [ADDOP,INTCONST,REALCONST,STRINGCONST,IDENT];
    SIMPTYPEBEGSYS := [LPARENT] + CONSTBEGSYS;
    TYPEBEGSYS := [ARROW,PACKEDSY,ARRAYSY,RECORDSY,SETSY,FILESY]
		  + SIMPTYPEBEGSYS;
    TYPEDELS := [ARRAYSY,RECORDSY,SETSY,FILESY];
    BLOCKBEGSYS := [USESSY,LABELSY,CONSTSY,TYPESY,VARSY,
		    PROCSY,FUNCSY,PROGSY,BEGINSY];
    SELECTSYS := [ARROW,PERIOD,LBRACK];
    FACBEGSYS := [INTCONST,REALCONST,LONGCONST,STRINGCONST,IDENT,
		  LPARENT,LBRACK,NOTSY];
    STATBEGSYS := [BEGINSY,GOTOSY,IFSY,WHILESY,REPEATSY,FORSY,WITHSY,CASESY];
    VARS := [FORMALVARS,ACTUALVARS]
  END (*INITSETS*) ;

BEGIN (*COMPINIT*)
  INITSCALARS; INITSETS;
  LEVEL := 0; TOP := 0;
  IF NOISY THEN
    BEGIN
      FOR IC := 1 TO 7 DO WRITELN(OUTPUT);
{.fs# WRITELN(OUTPUT,'PASCAL Compiler [II.0.A.1]'); }
{.fs} WRITELN(OUTPUT,'PASCAL Compiler [II.801]');
      WRITE(OUTPUT,'<   0>')
    END;
  WITH DISPLAY[0] DO
    BEGIN FNAME := NIL; FFILE := NIL; FLABEL := NIL; OCCUR := BLCK END;
  SMALLESTSPACE:=MEMAVAIL;
  GETNEXTPAGE;
  INSYMBOL;
  ENTSTDTYPES;   ENTSTDNAMES;   ENTUNDECL;
  ENTSPCPROCS;   ENTSTDPROCS;
  IF SYSCOMP THEN
    BEGIN OUTERBLOCK := NIL; SEG := 0; NEXTSEG := 1;
      GLEV :=1; BLOCKBEGSYS := BLOCKBEGSYS + [UNITSY,SEPARATSY]
    END
  ELSE
    BEGIN TOP := 1; LEVEL := 1;
      WITH DISPLAY[1] DO
	BEGIN FNAME := NIL; FFILE := NIL;
	  FLABEL := NIL; OCCUR := BLCK
	END;
      LC := LC+2; GLEV := 3; (*KEEP STACK STRAIGHT FOR NOW*)
      NEW(OUTERBLOCK,PROC,DECLARED,ACTUAL,FALSE);
      WITH OUTERBLOCK^ DO
	BEGIN NEXT := NIL; LOCALLC := LC;
	  NAME := 'PROGRAM '; IDTYPE := NIL; KLASS := PROC;
	  PFDECKIND := DECLARED; PFLEV := 0; PFNAME := 1; PFSEG := SEG;
	  PFKIND := ACTUAL; FORWDECL := FALSE; EXTURNAL := FALSE;
	  INSCOPE := TRUE
	END
    END;
  IF SY = PROGSY THEN
    BEGIN INSYMBOL;
      IF SY = IDENT THEN
	BEGIN SEGTABLE[SEG].SEGNAME := ID;
	  IF OUTERBLOCK <> NIL THEN
	    BEGIN
	      OUTERBLOCK^.NAME := ID;
	      ENTERID(OUTERBLOCK) (*ALLOWS EXIT ON PROGRAM NAME*)
	    END
	END
      ELSE ERROR(2); INSYMBOL;
      IF SY = LPARENT THEN
	BEGIN
	  REPEAT INSYMBOL
	  UNTIL SY IN [RPARENT,SEMICOLON]+BLOCKBEGSYS;
	  IF SY = RPARENT THEN INSYMBOL ELSE ERROR(4)
	END;
      IF SY = SEMICOLON THEN INSYMBOL ELSE ERROR(14)
    END;
  MARK(MARKP);
  NEW(TOS);
  WITH TOS^ DO  (*MAKE LEXSTKREC FOR OUTERBLOCK*)
    BEGIN
      PREVLEXSTACKP:=NIL;
      BFSY:=PERIOD;
      DFPROCP:=OUTERBLOCK;
      DLLC:=LC;
      DOLDLEV:=LEVEL;
      DOLDTOP:=TOP;
      POLDPROC:=CURPROC;
      ISSEGMENT:=FALSE;
      DMARKP:=MARKP;
    END;
END (*COMPINIT*) ;
