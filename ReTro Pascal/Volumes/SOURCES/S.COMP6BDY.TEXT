
(* --- original source filename: BODYPART.D.TEXT --- *)

(*    COPYRIGHT (C) 1979, REGENTS OF THE	*)
(*    UNIVERSITY OF CALIFORNIA, SAN DIEGO	*)

  PROCEDURE EXPRESSION(*FSYS: SETOFSYS*);
    LABEL 1; 	(* STRING COMPARE KLUDGE *)
    VAR LATTR: ATTR; LOP: OPERATOR; TYPIND: INTEGER;
	LSTRGIC,LSIZE: ADDRRANGE; LSTRING,GSTRING: BOOLEAN;
	LMIN,LMAX: INTEGER;

    PROCEDURE FLOATIT(VAR FSP: STP; FORCEFLOAT: BOOLEAN);
    BEGIN
      IF (GATTR.TYPTR = REALPTR) OR (FSP = REALPTR) OR FORCEFLOAT THEN
	BEGIN
	  IF GATTR.TYPTR = INTPTR THEN
	    BEGIN GEN0(10(*FLT*)); GATTR.TYPTR := REALPTR END;
	  IF FSP = INTPTR THEN
	    BEGIN GEN0(9(*FLO*)); FSP := REALPTR END
	END
    END (*FLOATIT*) ;

    PROCEDURE STRETCHIT(VAR FSP: STP);
    BEGIN
      IF (FSP^.FORM = LONGINT) OR (GATTR.TYPTR^.FORM = LONGINT) THEN
	IF GATTR.TYPTR = INTPTR THEN
	  BEGIN GENLDC(18(*DCVT*)); GENNR(DECOPS); GATTR.TYPTR := LONGINTPTR END
	ELSE
	  IF FSP = INTPTR THEN
	    BEGIN GENLDC(14(*DCV*)); GENNR(DECOPS); FSP := LONGINTPTR END
    END (*STRETCHIT*) ;

    PROCEDURE SIMPLEEXPRESSION(FSYS: SETOFSYS);
      VAR LATTR: ATTR; LOP: OPERATOR; SIGNED: BOOLEAN;

      PROCEDURE TERM(FSYS: SETOFSYS);
	VAR LATTR: ATTR; LSP: STP; LOP: OPERATOR;

	PROCEDURE FACTOR(FSYS: SETOFSYS);
	  VAR LCP: CTP; LVP: CSP; VARPART,ALLCONST: BOOLEAN;
	      LSP: STP; HIGHVAL,LOWVAL,LIC,LOP: INTEGER;
	      CSTPART: SET OF 0..127;
	BEGIN
	  IF NOT (SY IN FACBEGSYS) THEN
	    BEGIN ERROR(58); SKIP(FSYS + FACBEGSYS);
	      GATTR.TYPTR := NIL
	    END;
	  WHILE SY IN FACBEGSYS DO
	    BEGIN
	      CASE SY OF
	(*ID*)  IDENT:
		  BEGIN SEARCHID([KONST,FORMALVARS,ACTUALVARS,FIELD,FUNC],LCP);
		    INSYMBOL;
		    IF LCP^.KLASS = FUNC THEN
		      BEGIN CALL(FSYS,LCP); GATTR.KIND := EXPR END
		    ELSE
		      IF LCP^.KLASS = KONST THEN
			WITH GATTR, LCP^ DO
			  BEGIN TYPTR := IDTYPE; KIND := CST;
			    CVAL := VALUES
			  END
		      ELSE SELECTOR(FSYS,LCP);
		    IF GATTR.TYPTR <> NIL THEN
		      WITH GATTR,TYPTR^ DO
			IF FORM = SUBRANGE THEN TYPTR := RANGETYPE
		  END;
	(*CST*) INTCONST:
		  BEGIN
		    WITH GATTR DO
		      BEGIN TYPTR := INTPTR; KIND := CST;
			CVAL := VAL
		      END;
		    INSYMBOL
		  END;
		REALCONST:
		  BEGIN
		    WITH GATTR DO
		      BEGIN TYPTR := REALPTR; KIND := CST;
			CVAL := VAL
		      END;
		    INSYMBOL
		  END;
		STRINGCONST:
		  BEGIN
		    WITH GATTR DO
		      BEGIN
			IF LGTH = 1 THEN TYPTR := CHARPTR
			ELSE
			  BEGIN NEW(LSP,ARRAYS,TRUE,TRUE);
			    LSP^ := STRGPTR^;
			    LSP^.MAXLENG := LGTH;
			    TYPTR := LSP
			  END;
			KIND := CST; CVAL := VAL
		      END;
		    INSYMBOL
		  END;
		LONGCONST:
		  BEGIN
		    WITH GATTR DO
		      BEGIN NEW(LSP,LONGINT);
			LSP^ := LONGINTPTR^;
			LSP^.SIZE := DECSIZE(LGTH);
		        TYPTR := LSP; KIND := CST; CVAL := VAL
		      END;
		    INSYMBOL
		  END;
	(*(*)   LPARENT:
		  BEGIN INSYMBOL; EXPRESSION(FSYS + [RPARENT]);
		    IF SY = RPARENT THEN INSYMBOL ELSE ERROR(4)
		  END;
	(*NOT*) NOTSY:
		  WITH GATTR DO
		    BEGIN INSYMBOL; FACTOR(FSYS);
		      IF (KIND = CST) AND (TYPTR = BOOLPTR) THEN
			CVAL.IVAL := ORD(NOT ODD(CVAL.IVAL))
		      ELSE
		      BEGIN LOAD; GEN0(19(*NOT*));
			IF TYPTR <> NIL THEN
			  IF TYPTR <> BOOLPTR THEN
			    BEGIN ERROR(135); TYPTR := NIL END
		      END
		    END;
	(*[*)   LBRACK:
		  BEGIN INSYMBOL; CSTPART := [ ]; VARPART := FALSE;
		    NEW(LSP,POWER);
		    WITH LSP^ DO
		      BEGIN ELSET := NIL; SIZE := 0; FORM := POWER END;
		    IF SY = RBRACK THEN
		      BEGIN
			WITH GATTR DO
			  BEGIN TYPTR := LSP; KIND := CST END;
			INSYMBOL
		      END
		    ELSE
		      BEGIN
			REPEAT EXPRESSION(FSYS + [COMMA,RBRACK,COLON]);
			  IF GATTR.TYPTR <> NIL THEN
			    IF GATTR.TYPTR^.FORM <> SCALAR THEN
			      BEGIN ERROR(136); GATTR.TYPTR := NIL END
			    ELSE
			      IF COMPTYPES(LSP^.ELSET,GATTR.TYPTR) THEN
				BEGIN ALLCONST := FALSE; LOP := 23(*SGS*);
				  IF (GATTR.KIND = CST) AND
				     (GATTR.CVAL.IVAL <= 127) THEN
				    BEGIN ALLCONST := TRUE;
				      LOWVAL := GATTR.CVAL.IVAL;
				      HIGHVAL := LOWVAL
				    END;
				  LIC := IC; LOAD;
				  IF SY = COLON THEN
				    BEGIN INSYMBOL; LOP := 20(*SRS*);
				      EXPRESSION(FSYS + [COMMA,RBRACK]);
				      IF COMPTYPES(LSP^.ELSET,GATTR.TYPTR) THEN
				      ELSE
					BEGIN ERROR(137); GATTR.TYPTR:=NIL END;
				      IF ALLCONST THEN
					IF (GATTR.KIND = CST) AND
					   (GATTR.CVAL.IVAL <= 127) THEN
					    HIGHVAL := GATTR.CVAL.IVAL
					ELSE
					  BEGIN LOAD; ALLCONST := FALSE END
				      ELSE LOAD
				    END;
				  IF ALLCONST THEN
				    BEGIN IC := LIC; (*FORGET FIRST CONST*)
				      CSTPART := CSTPART + [LOWVAL..HIGHVAL]
				    END
				  ELSE
				    BEGIN GEN0(LOP);
				      IF VARPART THEN GEN0(28(*UNI*))
				      ELSE VARPART := TRUE
				    END;
				  LSP^.ELSET := GATTR.TYPTR;
				  GATTR.TYPTR := LSP
				END
			      ELSE ERROR(137);
			  TEST := SY <> COMMA;
			  IF NOT TEST THEN INSYMBOL
			UNTIL TEST;
			IF SY = RBRACK THEN INSYMBOL ELSE ERROR(12)
		      END;
		    IF VARPART THEN
		      BEGIN
			IF CSTPART <> [ ] THEN
			  BEGIN
			    SCONST^.PVAL := CSTPART;
			    SCONST^.CCLASS := PSET;
			    GATTR.CVAL.VALP := SCONST;
			    GATTR.KIND := CST;
			    LOAD; GEN0(28(*UNI*))
			  END;
			GATTR.KIND := EXPR
		      END
		    ELSE
		      BEGIN
			SCONST^.PVAL := CSTPART;
			SCONST^.CCLASS := PSET;
			GATTR.CVAL.VALP := SCONST;
			GATTR.KIND := CST
		      END
		  END
	      END (*CASE*) ;
	      IF NOT (SY IN FSYS) THEN
		BEGIN ERROR(6); SKIP(FSYS + FACBEGSYS) END
	    END (*WHILE*)
	END (*FACTOR*) ;

      BEGIN (*TERM*)
	FACTOR(FSYS + [MULOP]);
	WHILE SY = MULOP DO
	  BEGIN LOAD; LATTR := GATTR; LOP := OP;
	    INSYMBOL; FACTOR(FSYS + [MULOP]); LOAD;
	    IF (LATTR.TYPTR <> NIL) AND (GATTR.TYPTR <> NIL) THEN
	      CASE LOP OF
      (***)     MUL:  BEGIN FLOATIT(LATTR.TYPTR,FALSE); STRETCHIT(LATTR.TYPTR);
			IF (LATTR.TYPTR = INTPTR) AND (GATTR.TYPTR = INTPTR)
			  THEN GEN0(15(*MPI*))
			ELSE
			  IF (LATTR.TYPTR = REALPTR) AND
			     (GATTR.TYPTR = REALPTR) THEN GEN0(16(*MPR*))
			  ELSE
			    IF (GATTR.TYPTR^.FORM = LONGINT) AND
			       (LATTR.TYPTR^.FORM = LONGINT) THEN
			      BEGIN GENLDC(8(*DMP*)); GENNR(DECOPS) END
			    ELSE
			      IF (LATTR.TYPTR^.FORM = POWER)
				  AND COMPTYPES(LATTR.TYPTR,GATTR.TYPTR) THEN
				GEN0(12(*INT*))
			      ELSE BEGIN ERROR(134); GATTR.TYPTR:=NIL END
		      END;
      (*/*)     RDIV: BEGIN FLOATIT(LATTR.TYPTR,TRUE);
			IF (LATTR.TYPTR = REALPTR) AND
			   (GATTR.TYPTR = REALPTR) THEN GEN0(7(*DVR*))
			ELSE BEGIN ERROR(134); GATTR.TYPTR := NIL END
		      END;
      (*DIV*)   IDIV: BEGIN STRETCHIT(LATTR.TYPTR);
			IF (LATTR.TYPTR = INTPTR) AND
			   (GATTR.TYPTR = INTPTR) THEN GEN0(6(*DVI*))
			ELSE
			  IF (LATTR.TYPTR^.FORM = LONGINT) AND
			     (GATTR.TYPTR^.FORM = LONGINT) THEN
			    BEGIN GENLDC(10(*DDV*)); GENNR(DECOPS) END
			  ELSE BEGIN ERROR(134); GATTR.TYPTR := NIL END
		      END;
      (*MOD*)   IMOD: IF (LATTR.TYPTR = INTPTR) AND
			 (GATTR.TYPTR = INTPTR) THEN GEN0(14(*MOD*))
		      ELSE BEGIN ERROR(134); GATTR.TYPTR := NIL END;
      (*AND*)   ANDOP:IF (LATTR.TYPTR = BOOLPTR) AND
			 (GATTR.TYPTR = BOOLPTR) THEN GEN0(4(*AND*))
		      ELSE BEGIN ERROR(134); GATTR.TYPTR := NIL END
	      END (*CASE*)
	    ELSE GATTR.TYPTR := NIL
	  END (*WHILE*)
      END (*TERM*) ;

    BEGIN (*SIMPLEEXPRESSION*)
      SIGNED := FALSE;
      IF (SY = ADDOP) AND (OP IN [PLUS,MINUS]) THEN
	BEGIN SIGNED := OP = MINUS; INSYMBOL END;
      TERM(FSYS + [ADDOP]);
      IF SIGNED THEN
	BEGIN LOAD;
	  IF GATTR.TYPTR = INTPTR THEN GEN0(17(*NGI*))
	  ELSE
	    IF GATTR.TYPTR = REALPTR THEN GEN0(18(*NGR*))
	    ELSE
	      IF GATTR.TYPTR^.FORM = LONGINT THEN
	        BEGIN GENLDC(6(*DNG*)); GENNR(DECOPS) END
	      ELSE BEGIN ERROR(134); GATTR.TYPTR := NIL END
	END;
      WHILE SY = ADDOP DO
	BEGIN LOAD; LATTR := GATTR; LOP := OP;
	  INSYMBOL; TERM(FSYS + [ADDOP]); LOAD;
	  IF (LATTR.TYPTR <> NIL) AND (GATTR.TYPTR <> NIL) THEN
	    CASE LOP OF
    (*+*)     PLUS:
		BEGIN FLOATIT(LATTR.TYPTR,FALSE); STRETCHIT(LATTR.TYPTR);
		  IF (LATTR.TYPTR = INTPTR)AND(GATTR.TYPTR = INTPTR) THEN
		    GEN0(2(*ADI*))
		  ELSE
		    IF (LATTR.TYPTR = REALPTR)AND(GATTR.TYPTR = REALPTR) THEN
		      GEN0(3(*ADR*))
		    ELSE
		      IF (GATTR.TYPTR^.FORM = LONGINT) AND
			 (LATTR.TYPTR^.FORM = LONGINT) THEN
			BEGIN GENLDC(2(*DAD*)); GENNR(DECOPS) END
		      ELSE
			IF (LATTR.TYPTR^.FORM = POWER)
			   AND COMPTYPES(LATTR.TYPTR,GATTR.TYPTR) THEN
			  GEN0(28(*UNI*))
			ELSE BEGIN ERROR(134); GATTR.TYPTR := NIL END
		END;
    (*-*)     MINUS:
		BEGIN FLOATIT(LATTR.TYPTR,FALSE); STRETCHIT(LATTR.TYPTR);
		  IF (LATTR.TYPTR = INTPTR) AND (GATTR.TYPTR = INTPTR) THEN
		    GEN0(21(*SBI*))
		  ELSE
		    IF (LATTR.TYPTR = REALPTR) AND (GATTR.TYPTR = REALPTR)
		      THEN GEN0(22(*SBR*))
		    ELSE
		      IF (GATTR.TYPTR^.FORM = LONGINT) AND
			 (LATTR.TYPTR^.FORM = LONGINT) THEN
			BEGIN GENLDC(4(*DSB*)); GENNR(DECOPS) END
		      ELSE
			IF (LATTR.TYPTR^.FORM = POWER)
			    AND COMPTYPES(LATTR.TYPTR,GATTR.TYPTR) THEN
			  GEN0(5(*DIF*))
			ELSE BEGIN ERROR(134); GATTR.TYPTR := NIL END
		END;
    (*OR*)    OROP:
		IF (LATTR.TYPTR = BOOLPTR) AND (GATTR.TYPTR = BOOLPTR) THEN
		  GEN0(13(*IOR*))
		ELSE BEGIN ERROR(134); GATTR.TYPTR := NIL END
	    END (*CASE*)
	  ELSE GATTR.TYPTR := NIL
	END (*WHILE*)
    END (*SIMPLEEXPRESSION*) ;

    PROCEDURE MAKEPA(VAR STRGFSP: STP; PAFSP: STP);
      VAR LMIN,LMAX: INTEGER;
    BEGIN
      IF PAFSP^.INXTYPE <> NIL THEN
	BEGIN GETBOUNDS(PAFSP^.INXTYPE,LMIN,LMAX);
	  IF LMAX-LMIN+1 <> STRGFSP^.MAXLENG THEN ERROR(129)
	END;
      STRGFSP := PAFSP
    END (*MAKEPA*) ;

  BEGIN (*EXPRESSION*)
    SIMPLEEXPRESSION(FSYS + [RELOP]);
    IF SY = RELOP THEN
      BEGIN
	LSTRING := (GATTR.KIND = CST) AND
		(STRGTYPE(GATTR.TYPTR) OR (GATTR.TYPTR = CHARPTR));
	IF GATTR.TYPTR <> NIL THEN
	  IF GATTR.TYPTR^.FORM <= POWER THEN LOAD
	  ELSE LOADADDRESS;
	LATTR := GATTR; LOP := OP; LSTRGIC := STRGCSTIC;
	INSYMBOL; SIMPLEEXPRESSION(FSYS);
	GSTRING := (GATTR.KIND = CST) AND
		(STRGTYPE(GATTR.TYPTR) OR (GATTR.TYPTR = CHARPTR));
	IF GATTR.TYPTR <> NIL THEN
	  IF GATTR.TYPTR^.FORM <= POWER THEN LOAD
	  ELSE LOADADDRESS;
	IF (LATTR.TYPTR <> NIL) AND (GATTR.TYPTR <> NIL) THEN
	  IF LOP = INOP THEN
	    IF GATTR.TYPTR^.FORM = POWER THEN
	      IF COMPTYPES(LATTR.TYPTR,GATTR.TYPTR^.ELSET) THEN
		GEN0(11(*INN*))
	      ELSE BEGIN ERROR(129); GATTR.TYPTR := NIL END
	    ELSE BEGIN ERROR(130); GATTR.TYPTR := NIL END
	  ELSE
	    BEGIN
	      IF LATTR.TYPTR <> GATTR.TYPTR THEN
		BEGIN FLOATIT(LATTR.TYPTR,FALSE); STRETCHIT(LATTR.TYPTR) END;
	      IF LSTRING THEN
		BEGIN
		  IF PAOFCHAR(GATTR.TYPTR) THEN
		    IF NOT GATTR.TYPTR^.AISSTRNG THEN
		      BEGIN STRGTOPA(LSTRGIC);
			MAKEPA(LATTR.TYPTR,GATTR.TYPTR)
		      END
		END
	      ELSE
		IF GSTRING THEN
		  BEGIN
		    IF PAOFCHAR(LATTR.TYPTR) THEN
		      IF NOT LATTR.TYPTR^.AISSTRNG THEN
			BEGIN STRGTOPA(STRGCSTIC);
			  MAKEPA(GATTR.TYPTR,LATTR.TYPTR)
			END;
		  END;
	      IF (LSTRING AND STRGTYPE(GATTR.TYPTR)) OR
		 (GSTRING AND STRGTYPE(LATTR.TYPTR)) THEN GOTO 1;
	      IF COMPTYPES(LATTR.TYPTR,GATTR.TYPTR) THEN
		BEGIN LSIZE := LATTR.TYPTR^.SIZE; (*INVALID FOR LONG INTEGERS*)
		  CASE LATTR.TYPTR^.FORM OF
		    SCALAR:
		      IF LATTR.TYPTR = REALPTR THEN TYPIND := 1
		      ELSE
			IF LATTR.TYPTR = BOOLPTR THEN TYPIND := 3
			ELSE TYPIND := 0;
		    POINTER:
		      BEGIN
			IF LOP IN [LTOP,LEOP,GTOP,GEOP] THEN ERROR(131);
			TYPIND := 0
		      END;
		    LONGINT: TYPIND := 7;
		    POWER:
		      BEGIN
			IF LOP IN [LTOP,GTOP] THEN ERROR(132);
			TYPIND := 4
		      END;
		    ARRAYS:
		      BEGIN
			TYPIND := 6;
			IF PAOFCHAR(LATTR.TYPTR) THEN
			  IF LATTR.TYPTR^.AISSTRNG THEN
		1:	    TYPIND := 2
			  ELSE
			    BEGIN TYPIND := 5;
			      IF LATTR.TYPTR^.INXTYPE <> NIL THEN
				BEGIN
				  GETBOUNDS(LATTR.TYPTR^.INXTYPE,LMIN,LMAX);
				  LSIZE := LMAX - LMIN + 1
				END
			    END
			ELSE
			  IF LOP IN [LTOP,LEOP,GTOP,GEOP] THEN ERROR(131)
		      END;
		    RECORDS:
		      BEGIN
			IF LOP IN [LTOP,LEOP,GTOP,GEOP] THEN ERROR(131);
			TYPIND := 6
		      END;
		    FILES:
		      BEGIN ERROR(133); TYPIND := 0 END
		  END;
		  IF TYPIND = 7 THEN
		    BEGIN GENLDC(ORD(LOP)); GENLDC(16(*DCMP*));
		      GENNR(DECOPS)
		    END
		  ELSE
		    CASE LOP OF
		      LTOP: GEN2(53(*LES*),TYPIND,LSIZE);
		      LEOP: GEN2(52(*LEQ*),TYPIND,LSIZE);
		      GTOP: GEN2(49(*GRT*),TYPIND,LSIZE);
		      GEOP: GEN2(48(*GEQ*),TYPIND,LSIZE);
		      NEOP: GEN2(55(*NEQ*),TYPIND,LSIZE);
		      EQOP: GEN2(47(*EQU*),TYPIND,LSIZE)
		    END
		END
	      ELSE ERROR(129)
	    END;
	GATTR.TYPTR := BOOLPTR; GATTR.KIND := EXPR
      END (*SY = RELOP*)
  END (*EXPRESSION*) ;

{.fs} (* --- original source filename: BODYPART.E.TEXT --- *)

(*    COPYRIGHT (C) 1979, REGENTS OF THE	*)
(*    UNIVERSITY OF CALIFORNIA, SAN DIEGO	*)

  PROCEDURE STATEMENT(FSYS: SETOFSYS);
    LABEL 1;
    VAR LCP: CTP; TTOP: DISPRANGE; LLP: LABELP; HEAP: ^INTEGER;

    PROCEDURE ASSIGNMENT(FCP: CTP);
      VAR LATTR: ATTR; CSTRING,PAONLEFT: BOOLEAN; LMIN,LMAX: INTEGER;
    BEGIN SELECTOR(FSYS + [BECOMES],FCP);
      IF SY = BECOMES THEN
	BEGIN LMAX := 0; CSTRING := FALSE;
	  IF GATTR.TYPTR <> NIL THEN
	    IF (GATTR.ACCESS = INDRCT) OR (GATTR.TYPTR^.FORM > POWER) THEN
	      LOADADDRESS;
	  PAONLEFT := PAOFCHAR(GATTR.TYPTR);
	  LATTR := GATTR;
	  INSYMBOL; EXPRESSION(FSYS);
	  IF GATTR.KIND = CST THEN
	    CSTRING := (GATTR.TYPTR = CHARPTR) OR STRGTYPE(GATTR.TYPTR);
	  IF GATTR.TYPTR <> NIL THEN
	    IF GATTR.TYPTR^.FORM <= POWER THEN LOAD
	    ELSE LOADADDRESS;
	  IF (LATTR.TYPTR <> NIL) AND (GATTR.TYPTR <> NIL) THEN
	    BEGIN
	      IF GATTR.TYPTR = INTPTR THEN
		IF COMPTYPES(REALPTR,LATTR.TYPTR) THEN
		  BEGIN GEN0(10(*FLT*)); GATTR.TYPTR := REALPTR END;
	      IF COMPTYPES(LONGINTPTR,LATTR.TYPTR) THEN
		BEGIN
		  IF GATTR.TYPTR = INTPTR THEN
		    BEGIN GENLDC(18(*DCVT*)); GENNR(DECOPS);
		      GATTR.TYPTR := LONGINTPTR
		    END;
		  IF GATTR.TYPTR^.FORM <> LONGINT THEN
		    BEGIN ERROR(129); GATTR.TYPTR := LONGINTPTR END
		END;
	      IF PAONLEFT THEN
		IF LATTR.TYPTR^.AISSTRNG THEN
		  IF CSTRING AND (GATTR.TYPTR = CHARPTR) THEN
		    GATTR.TYPTR := STRGPTR
		  ELSE
		ELSE
		  IF LATTR.TYPTR^.INXTYPE <> NIL THEN
		    BEGIN GETBOUNDS(LATTR.TYPTR^.INXTYPE,LMIN,LMAX);
		      LMAX := LMAX - LMIN + 1;
		      IF CSTRING AND (GATTR.TYPTR <> CHARPTR) THEN
			BEGIN STRGTOPA(STRGCSTIC);
			  IF LMAX <> GATTR.TYPTR^.MAXLENG THEN ERROR(129);
			  GATTR.TYPTR := LATTR.TYPTR
			END
		    END
		  ELSE GATTR.TYPTR := LATTR.TYPTR;
	      IF COMPTYPES(LATTR.TYPTR,GATTR.TYPTR) THEN
		CASE LATTR.TYPTR^.FORM OF
		  SUBRANGE: BEGIN
			      IF RANGECHECK THEN
				BEGIN
				  GENLDC(LATTR.TYPTR^.MIN.IVAL);
				  GENLDC(LATTR.TYPTR^.MAX.IVAL);
				  GEN0(8(*CHK*))
				END;
			      STORE(LATTR)
			    END;
		  POWER:    BEGIN
			      GEN1(32(*ADJ*),LATTR.TYPTR^.SIZE);
			      STORE(LATTR)
			    END;
		  SCALAR,
		  POINTER:  STORE(LATTR);
		  LONGINT: BEGIN
			      GENLDC(LATTR.TYPTR^.SIZE);
			      GENLDC(0(*DAJ*));
			      GENNR(DECOPS);
			      STORE(LATTR)
			    END;
		  ARRAYS:  IF PAONLEFT THEN
			     IF LATTR.TYPTR^.AISSTRNG THEN
			       GEN1(42(*SAS*),LATTR.TYPTR^.MAXLENG)
			     ELSE GEN1(40(*MOV*),(LMAX+1) DIV 2)
			   ELSE GEN1(40(*MOV*),LATTR.TYPTR^.SIZE);
		  RECORDS: GEN1(40(*MOV*),LATTR.TYPTR^.SIZE);
		  FILES:   ERROR(146)
		END
	      ELSE ERROR(129)
	    END
	END (*SY = BECOMES*)
      ELSE ERROR(51)
    END (*ASSIGNMENT*) ;

    PROCEDURE GOTOSTATEMENT;
      VAR LLP: LABELP; FOUND: BOOLEAN; TTOP: DISPRANGE;
    BEGIN
      IF NOT GOTOOK THEN ERROR(6);
      IF SY = INTCONST THEN
	BEGIN
	  FOUND := FALSE; TTOP := TOP;
	  WHILE DISPLAY[TTOP].OCCUR <> BLCK DO TTOP := TTOP - 1;
	  LLP := DISPLAY[TTOP].FLABEL;
	  WHILE (LLP <> NIL) AND NOT FOUND DO
	    WITH LLP^ DO
	      IF LABVAL = VAL.IVAL THEN
		BEGIN FOUND := TRUE;
		  GENJMP(57(*UJP*),CODELBP)
		END
	      ELSE LLP := NEXTLAB;
	  IF NOT FOUND THEN ERROR(167);
	  INSYMBOL
	END
      ELSE ERROR(15)
    END (*GOTOSTATEMENT*) ;

    PROCEDURE COMPOUNDSTATEMENT;
    BEGIN
      REPEAT
	REPEAT STATEMENT(FSYS + [SEMICOLON,ENDSY])
	UNTIL NOT (SY IN STATBEGSYS);
	TEST := SY <> SEMICOLON;
	IF NOT TEST THEN INSYMBOL
      UNTIL TEST;
      IF SY = ENDSY THEN INSYMBOL ELSE ERROR(13)
    END (*COMPOUNDSTATEMENET*) ;

    PROCEDURE IFSTATEMENT;
      VAR LCIX1,LCIX2: LBP; LIC: INTEGER; CONDCOMPILE,NOTHENCLAUSE: BOOLEAN;
    BEGIN
      CONDCOMPILE := FALSE;
      EXPRESSION(FSYS + [THENSY]);
      IF (GATTR.KIND = CST) THEN
	IF (GATTR.TYPTR = BOOLPTR) THEN
	  BEGIN CONDCOMPILE := TRUE;
	    NOTHENCLAUSE := NOT ODD(GATTR.CVAL.IVAL);
	    LIC := IC
	  END;
      IF NOT CONDCOMPILE THEN
        BEGIN GENLABEL(LCIX1); GENFJP(LCIX1) END;
      IF SY = THENSY THEN INSYMBOL ELSE ERROR(52);
      STATEMENT(FSYS + [ELSESY]);
      IF CONDCOMPILE THEN
	IF NOTHENCLAUSE THEN IC := LIC
	ELSE LIC := IC;
      IF SY = ELSESY THEN
	BEGIN
	  IF NOT CONDCOMPILE THEN
	    BEGIN GENLABEL(LCIX2); GENJMP(57(*UJP*),LCIX2); PUTLABEL(LCIX1) END;
	  INSYMBOL; STATEMENT(FSYS);
	  IF CONDCOMPILE THEN
	    BEGIN
	      IF NOT NOTHENCLAUSE THEN IC := LIC
	    END
	  ELSE PUTLABEL(LCIX2)
	END
      ELSE
	IF NOT CONDCOMPILE THEN PUTLABEL(LCIX1)
    END (*IFSTATEMENT*) ;

    PROCEDURE CASESTATEMENT;
      LABEL 1;
      TYPE CIP = ^CASEINFO;
	   CASEINFO = RECORD
			NEXT: CIP;
			CSSTART: INTEGER;
			CSLAB: INTEGER
		      END;
      VAR LSP,LSP1: STP; FSTPTR,LPT1,LPT2,LPT3: CIP; LVAL: VALU;
	  LADDR, LCIX: LBP; NULSTMT, LMIN, LMAX: INTEGER;
    BEGIN EXPRESSION(FSYS + [OFSY,COMMA,COLON]);
      LOAD; GENLABEL(LCIX); GENJMP(57(*UJP*),LCIX);
      LSP := GATTR.TYPTR;
      IF LSP <> NIL THEN
	IF (LSP^.FORM <> SCALAR) OR (LSP = REALPTR) THEN
	  BEGIN ERROR(144); LSP := NIL END;
      IF SY = OFSY THEN INSYMBOL ELSE ERROR(8);
      FSTPTR := NIL; GENLABEL(LADDR);
      REPEAT
	LPT3 := NIL;
	REPEAT CONSTANT(FSYS + [COMMA,COLON],LSP1,LVAL);
	  IF LSP <> NIL THEN
	    IF COMPTYPES(LSP,LSP1) THEN
	      BEGIN LPT1 := FSTPTR; LPT2 := NIL;
		WHILE LPT1 <> NIL DO
		  WITH LPT1^ DO
		    BEGIN
		      IF CSLAB <= LVAL.IVAL THEN
			BEGIN IF CSLAB = LVAL.IVAL THEN ERROR(156);
			  GOTO 1
			END;
		      LPT2 := LPT1; LPT1 := NEXT
		    END;
    1:          NEW(LPT3);
		WITH LPT3^ DO
		  BEGIN NEXT := LPT1; CSLAB := LVAL.IVAL;
		    CSSTART := IC
		  END;
		IF LPT2 = NIL THEN FSTPTR := LPT3
		ELSE LPT2^.NEXT := LPT3
	      END
	    ELSE ERROR(147);
	  TEST := SY <> COMMA;
	  IF NOT TEST THEN INSYMBOL
	UNTIL TEST;
	IF SY = COLON THEN INSYMBOL ELSE ERROR(5);
	REPEAT STATEMENT(FSYS + [SEMICOLON])
	UNTIL NOT (SY IN STATBEGSYS);
	IF LPT3 <> NIL THEN
	  GENJMP(57(*UJP*),LADDR);
	TEST := SY <> SEMICOLON;
	IF NOT TEST THEN INSYMBOL
      UNTIL TEST OR (SY = ENDSY);
      PUTLABEL(LCIX);
      IF FSTPTR <> NIL THEN
	BEGIN LMAX := FSTPTR^.CSLAB;
	  LPT1 := FSTPTR; FSTPTR := NIL;
	  REPEAT LPT2 := LPT1^.NEXT; LPT1^.NEXT := FSTPTR;
	    FSTPTR := LPT1; LPT1 := LPT2
	  UNTIL LPT1 = NIL;
	  LMIN := FSTPTR^.CSLAB;
	      GEN0(44(*XJP*));
	      GENWORD(LMIN); GENWORD(LMAX);
	      NULSTMT := IC;
	      GENJMP(57(*UJP*),LADDR);
	      REPEAT
		WITH FSTPTR^ DO
		  BEGIN
		    WHILE CSLAB > LMIN DO
		      BEGIN GENWORD(IC-NULSTMT); LMIN := LMIN + 1 END;
		    GENWORD(IC-CSSTART);
		    FSTPTR := NEXT; LMIN := LMIN + 1
		  END
	      UNTIL FSTPTR = NIL;
	      PUTLABEL(LADDR)
	END;
	IF SY = ENDSY THEN INSYMBOL ELSE ERROR(13)
    END (*CASESTATEMENT*) ;

    PROCEDURE REPEATSTATEMENT;
      VAR LADDR: LBP;
    BEGIN GENLABEL(LADDR); PUTLABEL(LADDR);
      REPEAT
	REPEAT STATEMENT(FSYS + [SEMICOLON,UNTILSY])
	UNTIL NOT (SY IN STATBEGSYS);
	TEST := SY <> SEMICOLON;
	IF NOT TEST THEN INSYMBOL
      UNTIL TEST;
      IF SY = UNTILSY THEN
	BEGIN INSYMBOL; EXPRESSION(FSYS); GENFJP(LADDR)
	END
      ELSE ERROR(53)
    END (*REPEATSTATEMENT*) ;

    PROCEDURE WHILESTATEMENT;
      VAR LADDR, LCIX: LBP;
    BEGIN GENLABEL(LADDR); PUTLABEL(LADDR);
      EXPRESSION(FSYS + [DOSY]); GENLABEL(LCIX); GENFJP(LCIX);
      IF SY = DOSY THEN INSYMBOL ELSE ERROR(54);
      STATEMENT(FSYS); GENJMP(57(*UJP*),LADDR); PUTLABEL(LCIX)
    END (*WHILESTATEMENT*) ;

    PROCEDURE FORSTATEMENT;
      VAR LATTR: ATTR; LSP: STP;  LSY: SYMBOL;
	  LCIX, LADDR: LBP;
    BEGIN
      IF SY = IDENT THEN
	BEGIN SEARCHID(VARS,LCP);
	  WITH LCP^, LATTR DO
	    BEGIN TYPTR := IDTYPE; KIND := VARBL;
	      IF KLASS = ACTUALVARS THEN
		BEGIN ACCESS := DRCT; VLEVEL := VLEV;
		  DPLMT := VADDR
		END
	      ELSE BEGIN ERROR(155); TYPTR := NIL END
	    END;
	  IF LATTR.TYPTR <> NIL THEN
	    IF (LATTR.TYPTR^.FORM > SUBRANGE)
	       OR COMPTYPES(REALPTR,LATTR.TYPTR) THEN
	      BEGIN ERROR(143); LATTR.TYPTR := NIL END;
	  INSYMBOL
	END
      ELSE
	BEGIN ERROR(2); SKIP(FSYS + [BECOMES,TOSY,DOWNTOSY,DOSY])
	END;
      IF SY = BECOMES THEN
	BEGIN INSYMBOL; EXPRESSION(FSYS + [TOSY,DOWNTOSY,DOSY]);
	  IF GATTR.TYPTR <> NIL THEN
	    IF GATTR.TYPTR^.FORM <> SCALAR THEN ERROR(144)
	      ELSE
		IF COMPTYPES(LATTR.TYPTR,GATTR.TYPTR) THEN
		  BEGIN LOAD;
		    IF LATTR.TYPTR <> NIL THEN
		      IF (LATTR.TYPTR^.FORM = SUBRANGE) AND RANGECHECK THEN
			BEGIN
			  GENLDC(LATTR.TYPTR^.MIN.IVAL);
			  GENLDC(LATTR.TYPTR^.MAX.IVAL);
			  GEN0(8(*CHK*))
			END;
		    STORE(LATTR)
		  END
		ELSE ERROR(145)
	END
      ELSE
	BEGIN ERROR(51); SKIP(FSYS + [TOSY,DOWNTOSY,DOSY]) END;
      GENLABEL(LADDR);
      IF SY IN [TOSY,DOWNTOSY] THEN
	BEGIN LSY := SY; INSYMBOL; EXPRESSION(FSYS + [DOSY]);
	  IF GATTR.TYPTR <> NIL THEN
	    IF GATTR.TYPTR^.FORM <> SCALAR THEN ERROR(144)
	    ELSE
	      IF COMPTYPES(LATTR.TYPTR,GATTR.TYPTR) THEN
		BEGIN LOAD;
		  IF LATTR.TYPTR <> NIL THEN
		    IF (LATTR.TYPTR^.FORM = SUBRANGE) AND RANGECHECK THEN
		      BEGIN
			GENLDC(LATTR.TYPTR^.MIN.IVAL);
			GENLDC(LATTR.TYPTR^.MAX.IVAL);
			GEN0(8(*CHK*))
		      END;
		  GEN2(56(*STR*),0,LC); PUTLABEL(LADDR);
		  GATTR := LATTR; LOAD; GEN2(54(*LOD*),0,LC);
		  LC := LC + INTSIZE;
		  IF LC > LCMAX THEN LCMAX := LC;
		  IF LSY = TOSY THEN GEN2(52(*LEQ*),0,INTSIZE)
		  ELSE GEN2(48(*GEQ*),0,INTSIZE);
		END
	      ELSE ERROR(145)
	END
      ELSE BEGIN ERROR(55); SKIP(FSYS + [DOSY]) END;
      GENLABEL(LCIX); GENJMP(33(*FJP*),LCIX);
      IF SY = DOSY THEN INSYMBOL ELSE ERROR(54);
      STATEMENT(FSYS);
      GATTR := LATTR; LOAD; GENLDC(1);
      IF LSY = TOSY THEN GEN0(2(*ADI*)) ELSE GEN0(21(*SBI*));
      STORE(LATTR); GENJMP(57(*UJP*),LADDR); PUTLABEL(LCIX);
      LC := LC - INTSIZE
    END (*FORSTATEMENT*) ;


    PROCEDURE WITHSTATEMENT;
      VAR LCP: CTP; LCNT1,LCNT2: DISPRANGE;
    BEGIN LCNT1 := 0; LCNT2 := 0;
      REPEAT
	IF SY = IDENT THEN
	  BEGIN SEARCHID(VARS + [FIELD],LCP); INSYMBOL END
	ELSE BEGIN ERROR(2); LCP := UVARPTR END;
	SELECTOR(FSYS + [COMMA,DOSY],LCP);
	IF GATTR.TYPTR <> NIL THEN
	  IF GATTR.TYPTR^.FORM = RECORDS THEN
	    IF TOP < DISPLIMIT THEN
	      BEGIN TOP := TOP + 1; LCNT1 := LCNT1 + 1;
		WITH DISPLAY[TOP] DO
		  BEGIN FNAME := GATTR.TYPTR^.FSTFLD END;
		IF GATTR.ACCESS = DRCT THEN
		  WITH DISPLAY[TOP] DO
		    BEGIN OCCUR := CREC; CLEV := GATTR.VLEVEL;
		      CDSPL := GATTR.DPLMT
		    END
		ELSE
		  BEGIN LOADADDRESS; GEN2(56(*STR*),0,LC);
		    WITH DISPLAY[TOP] DO
		      BEGIN OCCUR := VREC; VDSPL := LC END;
		    LC := LC + PTRSIZE; LCNT2 := LCNT2 + PTRSIZE;
		    IF LC > LCMAX THEN LCMAX := LC
		  END
	      END
	    ELSE ERROR(250)
	  ELSE ERROR(140);
	TEST := SY <> COMMA;
	IF NOT TEST THEN INSYMBOL
      UNTIL TEST;
      IF SY = DOSY THEN INSYMBOL ELSE ERROR(54);
      STATEMENT(FSYS);
      TOP := TOP - LCNT1; LC := LC - LCNT2;
    END (*WITHSTATEMENT*) ;

  BEGIN (*STATEMENT*)
    STMTLEV := STMTLEV + 1;
    IF SY = INTCONST THEN (*LABEL*)
      BEGIN TTOP := TOP;
	WHILE DISPLAY[TTOP].OCCUR <> BLCK DO TTOP := TTOP-1;
	LLP := DISPLAY[TTOP].FLABEL;
	WHILE LLP <> NIL DO
	  WITH LLP^ DO
	    IF LABVAL = VAL.IVAL THEN
	      BEGIN
		IF CODELBP^.DEFINED THEN ERROR(165);
		PUTLABEL(CODELBP); GOTO 1
	      END
	    ELSE LLP := NEXTLAB;
	ERROR(167);
  1:    INSYMBOL;
	IF SY = COLON THEN INSYMBOL ELSE ERROR(5)
      END;
    IF DEBUGGING THEN
      BEGIN GEN1(85(*BPT*),SCREENDOTS+1); BPTONLINE := TRUE END;
    IF NOT (SY IN FSYS + [IDENT]) THEN
      BEGIN ERROR(6); SKIP(FSYS) END;
    IF SY IN STATBEGSYS + [IDENT] THEN
      BEGIN MARK(HEAP); (*FOR LABEL CLEANUP*)
	CASE SY OF
	  IDENT:    BEGIN SEARCHID(VARS + [FIELD,FUNC,PROC],LCP);
		      INSYMBOL;
		      IF LCP^.KLASS = PROC THEN CALL(FSYS,LCP)
		      ELSE ASSIGNMENT(LCP)
		    END;
	  BEGINSY:  BEGIN INSYMBOL; COMPOUNDSTATEMENT END;
	  GOTOSY:   BEGIN INSYMBOL; GOTOSTATEMENT END;
	  IFSY:     BEGIN INSYMBOL; IFSTATEMENT END;
	  CASESY:   BEGIN INSYMBOL; CASESTATEMENT END;
	  WHILESY:  BEGIN INSYMBOL; WHILESTATEMENT END;
	  REPEATSY: BEGIN INSYMBOL; REPEATSTATEMENT END;
	  FORSY:    BEGIN INSYMBOL; FORSTATEMENT END;
	  WITHSY:   BEGIN INSYMBOL; WITHSTATEMENT END
	END;
	RELEASE(HEAP);
	IF IC + 100 > MAXCODE THEN
	  BEGIN ERROR(253); IC := 0 END;
	IF NOT (SY IN [SEMICOLON,ENDSY,ELSESY,UNTILSY]) THEN
	  BEGIN ERROR(6); SKIP(FSYS) END
      END;
    STMTLEV := STMTLEV - 1
  END (*STATEMENT*) ;

PROCEDURE BODY;
VAR LLC1,EXITIC: ADDRRANGE;  LCP: CTP;  LOP: OPRANGE;
     LLP: LABELP;  LMIN,LMAX: INTEGER;  JTINX: JTABRANGE;
     DUMMYVAR: ARRAY[0..0] OF INTEGER; (*FOR PRETTY DISPLAY OF STACK AND HEAP*)

{.fs} { generate RELSEG instructions }
{.fs} { These must be in opposite order of GETSEG. }
{.fs} PROCEDURE GENRELSEG(LCP{tail}: CTP);
{.fs} BEGIN
{.fs}   IF LCP <> NIL THEN BEGIN
{.fs}     GENRELSEG(LCP^.NEXT); { do tail first, to get them in reverse order }
{.fs}     IF LCP^.SEGID >= 0 THEN
{.fs}       BEGIN GENLDC(LCP^.SEGID); GEN1(30(*CSP*),22(*RELSEG*)) END;
{.fs}   END
{.fs} END;

BEGIN
  IF (NOSWAP) AND (STARTINGUP) THEN 
    BEGIN
      DECLARATIONPART(FSYS); (* BRING IN DECLARATIONPART *)
      EXIT(BODYPART);
    END;
  NEXTJTAB := 1;
  IF NOISY THEN
    BEGIN WRITELN(OUTPUT);
      IF NOT NOSWAP THEN (*MUST ADJUST DISPLAY OF STACK AND HEAP*)
	UNITWRITE(3,DUMMYVAR[-1600],35); 
      DUMMYVAR[0]:=MEMAVAIL;
      IF DUMMYVAR[0] < SMALLESTSPACE THEN SMALLESTSPACE:=DUMMYVAR[0];
      IF FPROCP <> NIL THEN
	  WRITELN(OUTPUT,FPROCP^.NAME,' [',DUMMYVAR[0]:5,' words]');
      WRITE(OUTPUT,'<',SCREENDOTS:4,'>')
    END;
  IF FPROCP <> NIL THEN
    BEGIN
      LLC1 := FPROCP^.LOCALLC; LCP := FPROCP^.NEXT;
      WHILE LCP <> NIL DO
	WITH LCP^ DO
	  BEGIN
	      IF IDTYPE <> NIL THEN
		IF (KLASS = ACTUALVARS) THEN
		  IF (IDTYPE^.FORM > POWER) THEN
		    BEGIN LLC1 := LLC1 - PTRSIZE;
		      GEN2(50(*LDA*),0,VADDR);
		      GEN2(54(*LOD*),0,LLC1);
		      IF PAOFCHAR(IDTYPE) THEN
			WITH IDTYPE^ DO
			  IF AISSTRNG THEN GEN1(42(*SAS*),MAXLENG)
			  ELSE
			    IF INXTYPE <> NIL THEN
			      BEGIN GETBOUNDS(INXTYPE,LMIN,LMAX);
				GEN1(40(*MOV*),(LMAX-LMIN+1+1) DIV 2)
			      END
			    ELSE
		      ELSE GEN1(40(*MOV*),IDTYPE^.SIZE)
		    END
		  ELSE LLC1 := LLC1 - IDTYPE^.SIZE
		ELSE
		  IF KLASS = FORMALVARS THEN LLC1 := LLC1 - PTRSIZE;
	    LCP := NEXT
	  END;
    END;
  STARTDOTS := SCREENDOTS;
  LCMAX := LC;
  LLP := DISPLAY[TOP].FLABEL;
  WHILE LLP <> NIL DO
    BEGIN GENLABEL(LLP^.CODELBP);
      LLP := LLP^.NEXTLAB
    END;
  IF NOT INMODULE THEN
    IF LEVEL = 1 THEN
      BEGIN LCP := USINGLIST;
	WHILE LCP <> NIL DO
	  BEGIN
	    IF LCP^.SEGID >= 0 THEN
	      BEGIN GENLDC(LCP^.SEGID); GEN1(30(*CSP*),21(*GETSEG*)) END;
	    LCP := LCP^.NEXT
	  END;
	IF USERINFO.STUPID THEN
	    GEN2(77(*CXP*),6(*TURTLE*),1(*INIT*))
      END;
  LCP := DISPLAY[TOP].FFILE;
  WHILE LCP <> NIL DO
    WITH LCP^,IDTYPE^ DO
      BEGIN
	GEN2(50(*LDA*),0,VADDR);
	GEN2(50(*LDA*),0,VADDR+FILESIZE);
	IF FILTYPE = NIL THEN GENLDC(-1)
	ELSE
	  IF IDTYPE = INTRACTVPTR THEN GENLDC(0)
	  ELSE
	    IF FILTYPE = CHARPTR THEN GENLDC(-2)
	    ELSE GENLDC(FILTYPE^.SIZE);
	GEN2(77(*CXP*),0(*SYS*),3(*FINIT*));
	LCP := NEXT
      END;
  IF (LEVEL = 1) AND NOT SYSCOMP THEN
    GEN1(85(*BPT*),SCREENDOTS+1);
  REPEAT
    REPEAT STATEMENT(FSYS + [SEMICOLON,ENDSY])
    UNTIL NOT (SY IN STATBEGSYS);
    TEST := SY <> SEMICOLON;
    IF NOT TEST THEN INSYMBOL
  UNTIL TEST;
  IF SY = ENDSY THEN INSYMBOL ELSE ERROR(13);
  EXITIC := IC;
  LCP := DISPLAY[TOP].FFILE;
  WHILE LCP <> NIL DO
    WITH LCP^ DO
      BEGIN
	GEN2(50(*LDA*),0,VADDR);
	GENLDC(0); GEN2(77(*CXP*),0(*SYS*),6(*FCLOSE*));
	LCP := NEXT
      END;
  IF NOT INMODULE THEN
    IF LEVEL = 1 THEN
{.fs} GENRELSEG(USINGLIST);
{.fs#} { this original code will generate the RELSEG calls in wrong order }
{.fs# BEGIN                                                               }
{.fs#	LCP := USINGLIST;                                                 }
{.fs#	WHILE LCP <> NIL DO                                               }
{.fs#	  BEGIN                                                           }
{.fs#	    IF LCP^.SEGID >= 0 THEN                                       }
{.fs#	      BEGIN GENLDC(LCP^.SEGID); GEN1(30(*CSP*),22(*RELSEG*)) END; }
{.fs#	    LCP := LCP^.NEXT                                              }
{.fs#	  END                                                             }
{.fs#  END;                                                               }
  IF FPROCP = NIL THEN GEN0(86(*XIT*))
  ELSE
    BEGIN
      IF FPROCP^.PFLEV = 0 THEN LOP := 65(*RBP*)
      ELSE LOP := 45(*RNP*);
      IF FPROCP^.IDTYPE = NIL THEN GEN1(LOP,0)
      ELSE GEN1(LOP,FPROCP^.IDTYPE^.SIZE)
    END;
  LLP := DISPLAY[TOP].FLABEL;  (* CHECK UNDEFINED LABELS *)
  WHILE LLP <> NIL DO
    WITH LLP^,CODELBP^ DO
      BEGIN
	IF NOT DEFINED THEN
	  IF REFLIST <> MAXADDR THEN ERROR(168);
	LLP := NEXTLAB
      END;
  JTINX := NEXTJTAB - 1;
  IF ODD(IC) THEN IC := IC + 1;
  WHILE JTINX > 0 DO
    BEGIN GENWORD(IC-JTAB[JTINX]); JTINX := JTINX-1 END;
  IF FPROCP = NIL THEN
    BEGIN GENWORD((LCMAX-LCAFTERMARKSTACK)*2); GENWORD(0) END
  ELSE
    WITH FPROCP^ DO
      BEGIN GENWORD((LCMAX-LOCALLC)*2);
	GENWORD((LOCALLC-LCAFTERMARKSTACK)*2)
      END;
  GENWORD(IC-EXITIC); GENWORD(IC);
  GENBYTE(CURPROC); GENBYTE(LEVEL-1);
  IF NOT CODEINSEG THEN
    BEGIN CODEINSEG := TRUE;
      SEGTABLE[SEG].DISKADDR := CURBLK
    END;
  WRITECODE(FALSE);
  SEGINX := SEGINX + IC;
  PROCTABLE[CURPROC] := SEGINX - 2
END (*BODY*) ;

BEGIN (*BODYPART*)
  BODY
END ;
