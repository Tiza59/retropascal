
  PROCEDURE EXPRESSION;
    VAR LATTR: ATTR; LOP: OPERATOR; TYPIND: INTEGER;
	LSIZE: ADDRRANGE; LSTRING,GSTRING: BOOLEAN;
	LMIN,LMAX: INTEGER;

    PROCEDURE FLOATIT(VAR FSP: STP);
    BEGIN
      IF GATTR.TYPTR = INTPTR THEN
	BEGIN GEN0(10(*FLT*)); GATTR.TYPTR := REALPTR END;
      IF FSP = INTPTR THEN
	BEGIN GEN0(9(*FLO*)); FSP := REALPTR END
    END (*FLOATIT*) ;

    PROCEDURE SIMPLEEXPRESSION(FSYS: SETOFSYS);
      VAR LATTR: ATTR; LOP: OPERATOR; SIGNED: BOOLEAN;

      PROCEDURE TERM(FSYS: SETOFSYS);
	VAR LATTR: ATTR; LOP: OPERATOR;

	PROCEDURE FACTOR(FSYS: SETOFSYS);
	  VAR LCP: CTP; LVP: CSP; VARPART,ALLCONST: BOOLEAN;
	      LSP: STP; HIGHVAL,LOWVAL,LIC,LOP: INTEGER;
	      CSTPART: SET OF 0..127;
	BEGIN
	  IF NOT (SY IN FACBEGSYS) THEN
	    BEGIN ERROR(58); SKIP(FSYS + FACBEGSYS);
	      GATTR.TYPTR := NIL
	    END;
	  WHILE SY IN FACBEGSYS DO
	    BEGIN
	      CASE SY OF
	(*ID*)  IDENT:
		  BEGIN SEARCHID([KONST,VARS,FIELD,FUNC],LCP); INSYMBOL;
		    IF LCP^.KLASS = FUNC THEN
		      BEGIN CALL(FSYS,LCP); GATTR.KIND := EXPR END
		    ELSE
		      IF LCP^.KLASS = KONST THEN
			WITH GATTR, LCP^ DO
			  BEGIN TYPTR := IDTYPE; KIND := CST;
			    CVAL := VALUES
			  END
		      ELSE SELECTOR(FSYS,LCP);
		    IF GATTR.TYPTR <> NIL THEN
		      WITH GATTR,TYPTR^ DO
			IF FORM = SUBRANGE THEN TYPTR := RANGETYPE
		  END;
	(*CST*) INTCONST:
		  BEGIN
		    WITH GATTR DO
		      BEGIN TYPTR := INTPTR; KIND := CST;
			CVAL := VAL
		      END;
		    INSYMBOL
		  END;
		REALCONST:
		  BEGIN
		    WITH GATTR DO
		      BEGIN TYPTR := REALPTR; KIND := CST;
			CVAL := VAL
		      END;
		    INSYMBOL
		  END;
		STRINGCONST:
		  BEGIN
		    WITH GATTR DO
		      BEGIN
			IF LGTH = 1 THEN TYPTR := CHARPTR
			ELSE
			  BEGIN NEW(LSP,ARRAYS,TRUE,TRUE);
			    LSP^ := STRGPTR^;
			    LSP^.MAXLENG := LGTH;
			    TYPTR := LSP
			  END;
			KIND := CST; CVAL := VAL
		      END;
		    INSYMBOL
		  END;
	(*(*)   LPARENT:
		  BEGIN INSYMBOL; EXPRESSION(FSYS + [RPARENT]);
		    IF SY = RPARENT THEN INSYMBOL ELSE ERROR(4)
		  END;
	(*NOT*) NOTSY:
		  BEGIN INSYMBOL; FACTOR(FSYS);
		    LOAD; GEN0(19(*NOT*));
		    IF GATTR.TYPTR <> NIL THEN
		      IF GATTR.TYPTR <> BOOLPTR THEN
			BEGIN ERROR(135); GATTR.TYPTR := NIL END;
		  END;
	(*[*)   LBRACK:
		  BEGIN INSYMBOL; CSTPART := [ ]; VARPART := FALSE;
		    NEW(LSP,POWER);
		    WITH LSP^ DO
		      BEGIN ELSET := NIL; SIZE := 0; FORM := POWER END;
		    IF SY = RBRACK THEN
		      BEGIN
			WITH GATTR DO
			  BEGIN TYPTR := LSP; KIND := CST END;
			INSYMBOL
		      END
		    ELSE
		      BEGIN
			REPEAT EXPRESSION(FSYS + [COMMA,RBRACK,COLON]);
			  IF GATTR.TYPTR <> NIL THEN
			    IF GATTR.TYPTR^.FORM <> SCALAR THEN
			      BEGIN ERROR(136); GATTR.TYPTR := NIL END
			    ELSE
			      IF COMPTYPES(LSP^.ELSET,GATTR.TYPTR) THEN
				BEGIN ALLCONST := FALSE; LOP := 23(*SGS*);
				  IF (GATTR.KIND = CST) AND
				     (GATTR.CVAL.IVAL <= 127) THEN
				    BEGIN ALLCONST := TRUE;
				      LOWVAL := GATTR.CVAL.IVAL;
				      HIGHVAL := LOWVAL
				    END;
				  LIC := IC; LOAD;
				  IF SY = COLON THEN
				    BEGIN INSYMBOL; LOP := 20(*SRS*);
				      EXPRESSION(FSYS + [COMMA,RBRACK]);
				      IF COMPTYPES(LSP^.ELSET,GATTR.TYPTR) THEN
				      ELSE
					BEGIN ERROR(137); GATTR.TYPTR:=NIL END;
				      IF ALLCONST THEN
					IF (GATTR.KIND = CST) AND
					   (GATTR.CVAL.IVAL <= 127) THEN
					    HIGHVAL := GATTR.CVAL.IVAL
					ELSE
					  BEGIN LOAD; ALLCONST := FALSE END
				      ELSE LOAD
				    END;
				  IF ALLCONST THEN
				    BEGIN IC := LIC; (*FORGET FIRST CONST*)
				      CSTPART := CSTPART + [LOWVAL..HIGHVAL]
				    END
				  ELSE
				    BEGIN GEN0(LOP);
				      IF VARPART THEN GEN0(28(*UNI*))
				      ELSE VARPART := TRUE
				    END;
				  LSP^.ELSET := GATTR.TYPTR;
				  GATTR.TYPTR := LSP
				END
			      ELSE ERROR(137);
			  TEST := SY <> COMMA;
			  IF NOT TEST THEN INSYMBOL
			UNTIL TEST;
			IF SY = RBRACK THEN INSYMBOL ELSE ERROR(12)
		      END;
		    IF VARPART THEN
		      BEGIN
			IF CSTPART <> [ ] THEN
			  BEGIN
			    SCONST^.PVAL := CSTPART;
			    SCONST^.CCLASS := PSET;
			    GATTR.CVAL.VALP := SCONST;
			    GATTR.KIND := CST;
			    LOAD; GEN0(28(*UNI*))
			  END;
			GATTR.KIND := EXPR
		      END
		    ELSE
		      BEGIN
			SCONST^.PVAL := CSTPART;
			SCONST^.CCLASS := PSET;
			GATTR.CVAL.VALP := SCONST;
			GATTR.KIND := CST
		      END
		  END
	      END (*CASE*) ;
	      IF NOT (SY IN FSYS) THEN
		BEGIN ERROR(6); SKIP(FSYS + FACBEGSYS) END
	    END (*WHILE*)
	END (*FACTOR*) ;

      BEGIN (*TERM*)
	FACTOR(FSYS + [MULOP]);
	WHILE SY = MULOP DO
	  BEGIN LOAD; LATTR := GATTR; LOP := OP;
	    INSYMBOL; FACTOR(FSYS + [MULOP]); LOAD;
	    IF (LATTR.TYPTR <> NIL) AND (GATTR.TYPTR <> NIL) THEN
	      CASE LOP OF
      (***)     MUL:  IF (LATTR.TYPTR = INTPTR) AND (GATTR.TYPTR = INTPTR)
			THEN GEN0(15(*MPI*))
		      ELSE
			BEGIN FLOATIT(LATTR.TYPTR);
			  IF (LATTR.TYPTR = REALPTR) AND
			     (GATTR.TYPTR = REALPTR) THEN GEN0(16(*MPR*))
			  ELSE
			    IF (LATTR.TYPTR^.FORM = POWER)
				AND COMPTYPES(LATTR.TYPTR,GATTR.TYPTR) THEN
			      GEN0(12(*INT*))
			    ELSE BEGIN ERROR(134); GATTR.TYPTR:=NIL END
			END;
      (*/*)     RDIV: BEGIN FLOATIT(LATTR.TYPTR);
			IF (LATTR.TYPTR = REALPTR) AND
			   (GATTR.TYPTR = REALPTR) THEN GEN0(7(*DVR*))
			ELSE BEGIN ERROR(134); GATTR.TYPTR := NIL END
		      END;
      (*DIV*)   IDIV: IF (LATTR.TYPTR = INTPTR) AND
			 (GATTR.TYPTR = INTPTR) THEN GEN0(6(*DVI*))
		      ELSE BEGIN ERROR(134); GATTR.TYPTR := NIL END;
      (*MOD*)   IMOD: IF (LATTR.TYPTR = INTPTR) AND
			 (GATTR.TYPTR = INTPTR) THEN GEN0(14(*MOD*))
		      ELSE BEGIN ERROR(134); GATTR.TYPTR := NIL END;
      (*AND*)   ANDOP:IF (LATTR.TYPTR = BOOLPTR) AND
			 (GATTR.TYPTR = BOOLPTR) THEN GEN0(4(*AND*))
		      ELSE BEGIN ERROR(134); GATTR.TYPTR := NIL END
	      END (*CASE*)
	    ELSE GATTR.TYPTR := NIL
	  END (*WHILE*)
      END (*TERM*) ;

    BEGIN (*SIMPLEEXPRESSION*)
      SIGNED := FALSE;
      IF (SY = ADDOP) AND (OP IN [PLUS,MINUS]) THEN
	BEGIN SIGNED := OP = MINUS; INSYMBOL END;
      TERM(FSYS + [ADDOP]);
      IF SIGNED THEN
	BEGIN LOAD;
	  IF GATTR.TYPTR = INTPTR THEN GEN0(17(*NGI*))
	  ELSE
	    IF GATTR.TYPTR = REALPTR THEN GEN0(18(*NGR*))
	    ELSE BEGIN ERROR(134); GATTR.TYPTR := NIL END
	END;
      WHILE SY = ADDOP DO
	BEGIN LOAD; LATTR := GATTR; LOP := OP;
	  INSYMBOL; TERM(FSYS + [ADDOP]); LOAD;
	  IF (LATTR.TYPTR <> NIL) AND (GATTR.TYPTR <> NIL) THEN
	    CASE LOP OF
    (*+*)     PLUS:
		IF (LATTR.TYPTR = INTPTR)AND(GATTR.TYPTR = INTPTR) THEN
		  GEN0(2(*ADI*))
		ELSE
		  BEGIN FLOATIT(LATTR.TYPTR);
		    IF (LATTR.TYPTR = REALPTR)AND(GATTR.TYPTR = REALPTR)
		      THEN GEN0(3(*ADR*))
		    ELSE IF (LATTR.TYPTR^.FORM = POWER)
			     AND COMPTYPES(LATTR.TYPTR,GATTR.TYPTR) THEN
			   GEN0(28(*UNI*))
			 ELSE BEGIN ERROR(134); GATTR.TYPTR := NIL END
		  END;
    (*-*)     MINUS:
		IF (LATTR.TYPTR = INTPTR) AND (GATTR.TYPTR = INTPTR) THEN
		  GEN0(21(*SBI*))
		ELSE
		  BEGIN FLOATIT(LATTR.TYPTR);
		    IF (LATTR.TYPTR = REALPTR) AND (GATTR.TYPTR = REALPTR)
		      THEN GEN0(22(*SBR*))
		    ELSE
		      IF (LATTR.TYPTR^.FORM = POWER)
			  AND COMPTYPES(LATTR.TYPTR,GATTR.TYPTR) THEN
			GEN0(5(*DIF*))
		      ELSE BEGIN ERROR(134); GATTR.TYPTR := NIL END
		  END;
    (*OR*)    OROP:
		IF (LATTR.TYPTR = BOOLPTR) AND (GATTR.TYPTR = BOOLPTR) THEN
		  GEN0(13(*IOR*))
		ELSE BEGIN ERROR(134); GATTR.TYPTR := NIL END
	    END (*CASE*)
	  ELSE GATTR.TYPTR := NIL
	END (*WHILE*)
    END (*SIMPLEEXPRESSION*) ;

    PROCEDURE MAKEPA(VAR STRGFSP: STP; PAFSP: STP);
      VAR LMIN,LMAX: INTEGER;
    BEGIN
      IF PAFSP^.INXTYPE <> NIL THEN
	BEGIN GETBOUNDS(PAFSP^.INXTYPE,LMIN,LMAX);
	  IF LMAX-LMIN+1 <> STRGFSP^.MAXLENG THEN ERROR(129)
	END;
      STRGFSP := PAFSP
    END (*MAKEPA*) ;

  BEGIN (*EXPRESSION*)
    SIMPLEEXPRESSION(FSYS + [RELOP]);
    IF SY = RELOP THEN
      BEGIN
	LSTRING := STRGTYPE(GATTR.TYPTR) AND (GATTR.KIND = CST);
	IF GATTR.TYPTR <> NIL THEN
	  IF GATTR.TYPTR^.FORM <= POWER THEN LOAD
	  ELSE LOADADDRESS;
	LATTR := GATTR; LOP := OP;
	INSYMBOL; SIMPLEEXPRESSION(FSYS);
	GSTRING := STRGTYPE(GATTR.TYPTR) AND (GATTR.KIND = CST);
	IF GATTR.TYPTR <> NIL THEN
	  IF GATTR.TYPTR^.FORM <= POWER THEN LOAD
	  ELSE LOADADDRESS;
	IF (LATTR.TYPTR <> NIL) AND (GATTR.TYPTR <> NIL) THEN
	  IF LOP = INOP THEN
	    IF GATTR.TYPTR^.FORM = POWER THEN
	      IF COMPTYPES(LATTR.TYPTR,GATTR.TYPTR^.ELSET) THEN
		GEN0(11(*INN*))
	      ELSE BEGIN ERROR(129); GATTR.TYPTR := NIL END
	    ELSE BEGIN ERROR(130); GATTR.TYPTR := NIL END
	  ELSE
	    BEGIN
	      IF LATTR.TYPTR <> GATTR.TYPTR THEN FLOATIT(LATTR.TYPTR);
	      IF LSTRING THEN
		BEGIN
		  IF PAOFCHAR(GATTR.TYPTR) THEN
		    IF NOT GATTR.TYPTR^.AISSTRNG THEN
		      BEGIN GEN0(29(*S2P*));
			MAKEPA(LATTR.TYPTR,GATTR.TYPTR)
		      END
		END
	      ELSE
		IF GSTRING THEN
		  BEGIN
		    IF PAOFCHAR(LATTR.TYPTR) THEN
		      IF NOT LATTR.TYPTR^.AISSTRNG THEN
			BEGIN GEN0(80(*S1P*));
			  MAKEPA(GATTR.TYPTR,LATTR.TYPTR)
			END;
		  END;
	      IF COMPTYPES(LATTR.TYPTR,GATTR.TYPTR) THEN
		BEGIN LSIZE := LATTR.TYPTR^.SIZE;
		  CASE LATTR.TYPTR^.FORM OF
		    SCALAR:
		      IF LATTR.TYPTR = REALPTR THEN TYPIND := 1
		      ELSE
			IF LATTR.TYPTR = BOOLPTR THEN TYPIND := 3
			ELSE TYPIND := 0;
		    POINTER:
		      BEGIN
			IF LOP IN [LTOP,LEOP,GTOP,GEOP] THEN ERROR(131);
			TYPIND := 0
		      END;
		    POWER:
		      BEGIN
			IF LOP IN [LTOP,GTOP] THEN ERROR(132);
			TYPIND := 4
		      END;
		    ARRAYS:
		      BEGIN
			TYPIND := 6;
			IF PAOFCHAR(LATTR.TYPTR) THEN
			  IF LATTR.TYPTR^.AISSTRNG THEN TYPIND := 2
			  ELSE
			    BEGIN TYPIND := 5;
			      IF LATTR.TYPTR^.INXTYPE <> NIL THEN
				BEGIN
				  GETBOUNDS(LATTR.TYPTR^.INXTYPE,LMIN,LMAX);
				  LSIZE := LMAX - LMIN + 1
				END
			    END
			ELSE
			  IF LOP IN [LTOP,LEOP,GTOP,GEOP] THEN ERROR(131)
		      END;
		    RECORDS:
		      BEGIN
			IF LOP IN [LTOP,LEOP,GTOP,GEOP] THEN ERROR(131);
			TYPIND := 6
		      END;
		    FILES:
		      BEGIN ERROR(133); TYPIND := 0 END
		  END;
		  CASE LOP OF
		    LTOP: GEN2(53(*LES*),TYPIND,LSIZE);
		    LEOP: GEN2(52(*LEQ*),TYPIND,LSIZE);
		    GTOP: GEN2(49(*GRT*),TYPIND,LSIZE);
		    GEOP: GEN2(48(*GEQ*),TYPIND,LSIZE);
		    NEOP: GEN2(55(*NEQ*),TYPIND,LSIZE);
		    EQOP: GEN2(47(*EQU*),TYPIND,LSIZE)
		  END
		END
	      ELSE ERROR(129)
	    END;
	GATTR.TYPTR := BOOLPTR; GATTR.KIND := EXPR
      END (*SY = RELOP*)
  END (*EXPRESSION*) ;

  PROCEDURE STATEMENT(FSYS: SETOFSYS);
    LABEL 1;
    VAR LCP: CTP; TTOP: DISPRANGE; LLP: LABELP; HEAP: ^INTEGER;

    PROCEDURE ASSIGNMENT(FCP: CTP);
      VAR LATTR: ATTR; CSTRING,PAONLEFT: BOOLEAN; LMIN,LMAX: INTEGER;
    BEGIN SELECTOR(FSYS + [BECOMES],FCP);
      IF SY = BECOMES THEN
	BEGIN LMAX := 0; CSTRING := FALSE;
	  IF GATTR.TYPTR <> NIL THEN
	    IF (GATTR.ACCESS = INDRCT) OR (GATTR.TYPTR^.FORM > POWER) THEN
	      LOADADDRESS;
	  PAONLEFT := PAOFCHAR(GATTR.TYPTR);
	  LATTR := GATTR;
	  INSYMBOL; EXPRESSION(FSYS);
	  IF GATTR.KIND = CST THEN
	    CSTRING := (GATTR.TYPTR = CHARPTR) OR STRGTYPE(GATTR.TYPTR);
	  IF GATTR.TYPTR <> NIL THEN
	    IF GATTR.TYPTR^.FORM <= POWER THEN LOAD
	    ELSE LOADADDRESS;
	  IF (LATTR.TYPTR <> NIL) AND (GATTR.TYPTR <> NIL) THEN
	    BEGIN
	      IF GATTR.TYPTR = INTPTR THEN
		IF COMPTYPES(REALPTR,LATTR.TYPTR) THEN
		  BEGIN GEN0(10(*FLT*)); GATTR.TYPTR := REALPTR END;
	      IF PAONLEFT THEN
		IF LATTR.TYPTR^.AISSTRNG THEN
		  IF CSTRING AND (GATTR.TYPTR = CHARPTR) THEN
		    GATTR.TYPTR := STRGPTR
		  ELSE
		ELSE
		  IF LATTR.TYPTR^.INXTYPE <> NIL THEN
		    BEGIN GETBOUNDS(LATTR.TYPTR^.INXTYPE,LMIN,LMAX);
		      LMAX := LMAX - LMIN + 1;
		      IF CSTRING AND (GATTR.TYPTR <> CHARPTR) THEN
			BEGIN GEN0(80(*S1P*));
			  IF LMAX <> GATTR.TYPTR^.MAXLENG THEN ERROR(129);
			  GATTR.TYPTR := LATTR.TYPTR
			END
		    END
		  ELSE GATTR.TYPTR := LATTR.TYPTR;
	      IF COMPTYPES(LATTR.TYPTR,GATTR.TYPTR) THEN
		CASE LATTR.TYPTR^.FORM OF
		  SUBRANGE: BEGIN
			      IF RANGECHECK THEN
				BEGIN
				  GENLDC(LATTR.TYPTR^.MIN.IVAL);
				  GENLDC(LATTR.TYPTR^.MAX.IVAL);
				  GEN0(8(*CHK*))
				END;
			      STORE(LATTR)
			    END;
		  POWER:    BEGIN
			      GEN1(32(*ADJ*),LATTR.TYPTR^.SIZE);
			      STORE(LATTR)
			    END;
		  SCALAR,
		  POINTER: STORE(LATTR);
		  ARRAYS:  IF PAONLEFT THEN
			     IF LATTR.TYPTR^.AISSTRNG THEN
			       GEN1(42(*SAS*),LATTR.TYPTR^.MAXLENG)
			     ELSE GEN1(41(*MVB*),LMAX)
			   ELSE GEN1(40(*MOV*),LATTR.TYPTR^.SIZE);
		  RECORDS: GEN1(40(*MOV*),LATTR.TYPTR^.SIZE);
		  FILES:   ERROR(146)
		END
	      ELSE ERROR(129)
	    END
	END (*SY = BECOMES*)
      ELSE ERROR(51)
    END (*ASSIGNMENT*) ;

    PROCEDURE GOTOSTATEMENT;
      VAR LLP: LABELP; FOUND: BOOLEAN; TTOP: DISPRANGE;
    BEGIN
      IF NOT GOTOOK THEN ERROR(6);
      IF SY = INTCONST THEN
	BEGIN
	  FOUND := FALSE; TTOP := TOP;
	  WHILE DISPLAY[TTOP].OCCUR <> BLCK DO TTOP := TTOP - 1;
	  LLP := DISPLAY[TTOP].FLABEL;
	  WHILE (LLP <> NIL) AND NOT FOUND DO
	    WITH LLP^ DO
	      IF LABVAL = VAL.IVAL THEN
		BEGIN FOUND := TRUE;
		  GENJMP(57(*UJP*),CODELBP)
		END
	      ELSE LLP := NEXTLAB;
	  IF NOT FOUND THEN ERROR(167);
	  INSYMBOL
	END
      ELSE ERROR(15)
    END (*GOTOSTATEMENT*) ;

    PROCEDURE COMPOUNDSTATEMENT;
    BEGIN
      REPEAT
	REPEAT STATEMENT(FSYS + [SEMICOLON,ENDSY])
	UNTIL NOT (SY IN STATBEGSYS);
	TEST := SY <> SEMICOLON;
	IF NOT TEST THEN INSYMBOL
      UNTIL TEST;
      IF SY = ENDSY THEN INSYMBOL ELSE ERROR(13)
    END (*COMPOUNDSTATEMENET*) ;

    PROCEDURE IFSTATEMENT;
      VAR LCIX1,LCIX2: LBP;
    BEGIN EXPRESSION(FSYS + [THENSY]);
      GENLABEL(LCIX1); GENFJP(LCIX1);
      IF SY = THENSY THEN INSYMBOL ELSE ERROR(52);
      STATEMENT(FSYS + [ELSESY]);
      IF SY = ELSESY THEN
	BEGIN GENLABEL(LCIX2); GENJMP(57(*UJP*),LCIX2);
	  PUTLABEL(LCIX1);
	  INSYMBOL; STATEMENT(FSYS);
	  PUTLABEL(LCIX2)
	END
      ELSE PUTLABEL(LCIX1)
    END (*IFSTATEMENT*) ;

    PROCEDURE CASESTATEMENT;
      LABEL 1;
      TYPE CIP = ^CASEINFO;
	   CASEINFO = RECORD
			NEXT: CIP;
			CSSTART: INTEGER;
			CSLAB: INTEGER
		      END;
      VAR LSP,LSP1: STP; FSTPTR,LPT1,LPT2,LPT3: CIP; LVAL: VALU;
	  LADDR, LCIX: LBP; NULSTMT, LMIN, LMAX: INTEGER;
    BEGIN EXPRESSION(FSYS + [OFSY,COMMA,COLON]);
      LOAD; GENLABEL(LCIX); GENJMP(57(*UJP*),LCIX);
      LSP := GATTR.TYPTR;
      IF LSP <> NIL THEN
	IF (LSP^.FORM <> SCALAR) OR (LSP = REALPTR) THEN
	  BEGIN ERROR(144); LSP := NIL END;
      IF SY = OFSY THEN INSYMBOL ELSE ERROR(8);
      FSTPTR := NIL; GENLABEL(LADDR);
      REPEAT
	LPT3 := NIL;
	REPEAT CONSTANT(FSYS + [COMMA,COLON],LSP1,LVAL);
	  IF LSP <> NIL THEN
	    IF COMPTYPES(LSP,LSP1) THEN
	      BEGIN LPT1 := FSTPTR; LPT2 := NIL;
		WHILE LPT1 <> NIL DO
		  WITH LPT1^ DO
		    BEGIN
		      IF CSLAB <= LVAL.IVAL THEN
			BEGIN IF CSLAB = LVAL.IVAL THEN ERROR(156);
			  GOTO 1
			END;
		      LPT2 := LPT1; LPT1 := NEXT
		    END;
    1:          NEW(LPT3);
		WITH LPT3^ DO
		  BEGIN NEXT := LPT1; CSLAB := LVAL.IVAL;
		    CSSTART := IC
		  END;
		IF LPT2 = NIL THEN FSTPTR := LPT3
		ELSE LPT2^.NEXT := LPT3
	      END
	    ELSE ERROR(147);
	  TEST := SY <> COMMA;
	  IF NOT TEST THEN INSYMBOL
	UNTIL TEST;
	IF SY = COLON THEN INSYMBOL ELSE ERROR(5);
	REPEAT STATEMENT(FSYS + [SEMICOLON])
	UNTIL NOT (SY IN STATBEGSYS);
	IF LPT3 <> NIL THEN
	  GENJMP(57(*UJP*),LADDR);
	TEST := SY <> SEMICOLON;
	IF NOT TEST THEN INSYMBOL
      UNTIL TEST;
      PUTLABEL(LCIX);
      IF FSTPTR <> NIL THEN
	BEGIN LMAX := FSTPTR^.CSLAB;
	  LPT1 := FSTPTR; FSTPTR := NIL;
	  REPEAT LPT2 := LPT1^.NEXT; LPT1^.NEXT := FSTPTR;
	    FSTPTR := LPT1; LPT1 := LPT2
	  UNTIL LPT1 = NIL;
	  LMIN := FSTPTR^.CSLAB;
	      GEN0(44(*XJP*));
	      GENWORD(LMIN); GENWORD(LMAX);
	      NULSTMT := IC;
	      GENJMP(57(*UJP*),LADDR);
	      REPEAT
		WITH FSTPTR^ DO
		  BEGIN
		    WHILE CSLAB > LMIN DO
		      BEGIN GENWORD(IC-NULSTMT); LMIN := LMIN + 1 END;
		    GENWORD(IC-CSSTART);
		    FSTPTR := NEXT; LMIN := LMIN + 1
		  END
	      UNTIL FSTPTR = NIL;
	      PUTLABEL(LADDR)
	END;
	IF SY = ENDSY THEN INSYMBOL ELSE ERROR(13)
    END (*CASESTATEMENT*) ;

    PROCEDURE REPEATSTATEMENT;
      VAR LADDR: LBP;
    BEGIN GENLABEL(LADDR); PUTLABEL(LADDR);
      REPEAT
	REPEAT STATEMENT(FSYS + [SEMICOLON,UNTILSY])
	UNTIL NOT (SY IN STATBEGSYS);
	TEST := SY <> SEMICOLON;
	IF NOT TEST THEN INSYMBOL
      UNTIL TEST;
      IF SY = UNTILSY THEN
	BEGIN INSYMBOL; EXPRESSION(FSYS); GENFJP(LADDR)
	END
      ELSE ERROR(53)
    END (*REPEATSTATEMENT*) ;

    PROCEDURE WHILESTATEMENT;
      VAR LADDR, LCIX: LBP;
    BEGIN GENLABEL(LADDR); PUTLABEL(LADDR);
      EXPRESSION(FSYS + [DOSY]); GENLABEL(LCIX); GENFJP(LCIX);
      IF SY = DOSY THEN INSYMBOL ELSE ERROR(54);
      STATEMENT(FSYS); GENJMP(57(*UJP*),LADDR); PUTLABEL(LCIX)
    END (*WHILESTATEMENT*) ;

    PROCEDURE FORSTATEMENT;
      VAR LATTR: ATTR; LSP: STP;  LSY: SYMBOL;
	  LCIX, LADDR: LBP;
    BEGIN
      IF SY = IDENT THEN
	BEGIN SEARCHID([VARS],LCP);
	  WITH LCP^, LATTR DO
	    BEGIN TYPTR := IDTYPE; KIND := VARBL;
	      IF VKIND = ACTUAL THEN
		BEGIN ACCESS := DRCT; VLEVEL := VLEV;
		  DPLMT := VADDR
		END
	      ELSE BEGIN ERROR(155); TYPTR := NIL END
	    END;
	  IF LATTR.TYPTR <> NIL THEN
	    IF (LATTR.TYPTR^.FORM > SUBRANGE)
	       OR COMPTYPES(REALPTR,LATTR.TYPTR) THEN
	      BEGIN ERROR(143); LATTR.TYPTR := NIL END;
	  INSYMBOL
	END
      ELSE
	BEGIN ERROR(2); SKIP(FSYS + [BECOMES,TOSY,DOWNTOSY,DOSY])
	END;
      IF SY = BECOMES THEN
	BEGIN INSYMBOL; EXPRESSION(FSYS + [TOSY,DOWNTOSY,DOSY]);
	  IF GATTR.TYPTR <> NIL THEN
	    IF GATTR.TYPTR^.FORM <> SCALAR THEN ERROR(144)
	      ELSE
		IF COMPTYPES(LATTR.TYPTR,GATTR.TYPTR) THEN
		  BEGIN LOAD;
		    IF LATTR.TYPTR <> NIL THEN
		      IF (LATTR.TYPTR^.FORM = SUBRANGE) AND RANGECHECK THEN
			BEGIN
			  GENLDC(LATTR.TYPTR^.MIN.IVAL);
			  GENLDC(LATTR.TYPTR^.MAX.IVAL);
			  GEN0(8(*CHK*))
			END;
		    STORE(LATTR)
		  END
		ELSE ERROR(145)
	END
      ELSE
	BEGIN ERROR(51); SKIP(FSYS + [TOSY,DOWNTOSY,DOSY]) END;
      GENLABEL(LADDR);
      IF SY IN [TOSY,DOWNTOSY] THEN
	BEGIN LSY := SY; INSYMBOL; EXPRESSION(FSYS + [DOSY]);
	  IF GATTR.TYPTR <> NIL THEN
	    IF GATTR.TYPTR^.FORM <> SCALAR THEN ERROR(144)
	    ELSE
	      IF COMPTYPES(LATTR.TYPTR,GATTR.TYPTR) THEN
		BEGIN LOAD;
		  IF LATTR.TYPTR <> NIL THEN
		    IF (LATTR.TYPTR^.FORM = SUBRANGE) AND RANGECHECK THEN
		      BEGIN
			GENLDC(LATTR.TYPTR^.MIN.IVAL);
			GENLDC(LATTR.TYPTR^.MAX.IVAL);
			GEN0(8(*CHK*))
		      END;
		  GEN2(56(*STR*),0,LC); PUTLABEL(LADDR);
		  GATTR := LATTR; LOAD; GEN2(54(*LOD*),0,LC);
		  LC := LC + INTSIZE;
		  IF LC > LCMAX THEN LCMAX := LC;
		  IF LSY = TOSY THEN GEN2(52(*LEQ*),0,INTSIZE)
		  ELSE GEN2(48(*GEQ*),0,INTSIZE);
		END
	      ELSE ERROR(145)
	END
      ELSE BEGIN ERROR(55); SKIP(FSYS + [DOSY]) END;
      GENLABEL(LCIX); GENJMP(33(*FJP*),LCIX);
      IF SY = DOSY THEN INSYMBOL ELSE ERROR(54);
      STATEMENT(FSYS);
      GATTR := LATTR; LOAD; GENLDC(1);
      IF LSY = TOSY THEN GEN0(2(*ADI*)) ELSE GEN0(21(*SBI*));
      STORE(LATTR); GENJMP(57(*UJP*),LADDR); PUTLABEL(LCIX);
      LC := LC - INTSIZE
    END (*FORSTATEMENT*) ;


    PROCEDURE WITHSTATEMENT;
      VAR LCP: CTP; LCNT1,LCNT2: DISPRANGE;
    BEGIN LCNT1 := 0; LCNT2 := 0;
      REPEAT
	IF SY = IDENT THEN
	  BEGIN SEARCHID([VARS,FIELD],LCP); INSYMBOL END
	ELSE BEGIN ERROR(2); LCP := UVARPTR END;
	SELECTOR(FSYS + [COMMA,DOSY],LCP);
	IF GATTR.TYPTR <> NIL THEN
	  IF GATTR.TYPTR^.FORM = RECORDS THEN
	    IF TOP < DISPLIMIT THEN
	      BEGIN TOP := TOP + 1; LCNT1 := LCNT1 + 1;
		WITH DISPLAY[TOP] DO
		  BEGIN FNAME := GATTR.TYPTR^.FSTFLD END;
		IF GATTR.ACCESS = DRCT THEN
		  WITH DISPLAY[TOP] DO
		    BEGIN OCCUR := CREC; CLEV := GATTR.VLEVEL;
		      CDSPL := GATTR.DPLMT
		    END
		ELSE
		  BEGIN LOADADDRESS; GEN2(56(*STR*),0,LC);
		    WITH DISPLAY[TOP] DO
		      BEGIN OCCUR := VREC; VDSPL := LC END;
		    LC := LC + PTRSIZE; LCNT2 := LCNT2 + PTRSIZE;
		    IF LC > LCMAX THEN LCMAX := LC
		  END
	      END
	    ELSE ERROR(250)
	  ELSE ERROR(140);
	TEST := SY <> COMMA;
	IF NOT TEST THEN INSYMBOL
      UNTIL TEST;
      IF SY = DOSY THEN INSYMBOL ELSE ERROR(54);
      STATEMENT(FSYS);
      TOP := TOP - LCNT1; LC := LC - LCNT2;
    END (*WITHSTATEMENT*) ;

  BEGIN (*STATEMENT*)
    IF SY = INTCONST THEN (*LABEL*)
      BEGIN TTOP := TOP;
	WHILE DISPLAY[TTOP].OCCUR <> BLCK DO TTOP := TTOP-1;
	LLP := DISPLAY[TTOP].FLABEL;
	WHILE LLP <> NIL DO
	  WITH LLP^ DO
	    IF LABVAL = VAL.IVAL THEN
	      BEGIN
		IF CODELBP^.DEFINED THEN ERROR(165);
		PUTLABEL(CODELBP); GOTO 1
	      END
	    ELSE LLP := NEXTLAB;
	ERROR(167);
  1:    INSYMBOL;
	IF SY = COLON THEN INSYMBOL ELSE ERROR(5)
      END;
    IF NOT (SY IN FSYS + [IDENT]) THEN
      BEGIN ERROR(6); SKIP(FSYS) END;
    IF SY IN STATBEGSYS + [IDENT] THEN
      BEGIN MARK(HEAP); (*FOR LABEL CLEANUP*)
	CASE SY OF
	  IDENT:    BEGIN SEARCHID([VARS,FIELD,FUNC,PROC],LCP);
		      INSYMBOL;
		      IF LCP^.KLASS = PROC THEN CALL(FSYS,LCP)
		      ELSE ASSIGNMENT(LCP)
		    END;
	  BEGINSY:  BEGIN INSYMBOL; COMPOUNDSTATEMENT END;
	  GOTOSY:   BEGIN INSYMBOL; GOTOSTATEMENT END;
	  IFSY:     BEGIN INSYMBOL; IFSTATEMENT END;
	  CASESY:   BEGIN INSYMBOL; CASESTATEMENT END;
	  WHILESY:  BEGIN INSYMBOL; WHILESTATEMENT END;
	  REPEATSY: BEGIN INSYMBOL; REPEATSTATEMENT END;
	  FORSY:    BEGIN INSYMBOL; FORSTATEMENT END;
	  WITHSY:   BEGIN INSYMBOL; WITHSTATEMENT END
	END;
	RELEASE(HEAP);
	IF IC + 100 > MAXCODE THEN
	  BEGIN ERROR(253); IC := 0 END;
	IF NOT (SY IN [SEMICOLON,ENDSY,ELSESY,UNTILSY]) THEN
	  BEGIN ERROR(6); SKIP(FSYS) END
      END
  END (*STATEMENT*) ;
